





## 1、IP分类以及每个分类可以分配的IP数量

### 1.1 IP地址组成

唯一标识 IP 网络中的每台设备 ，每台主机（计算机、网络设备、外围设备）必须具有唯一的地址

**IP地址由两部分组成**

> 网络ID：标识网络，每个网段分配一个网络ID，处于高位
>
> 主机 ID：标识单个主机，由组织分配给各设备，处于低位

**IPv4地址格式：点分十进制记法**
**IP地址是一个32位二进制数，如：10101100 00010000 10000000 00010001**

|   可将此32位二进制数划分为四组8位二进制数    | 10101100 | 00010000 | 10000000 | 00010001 |
| :------------------------------------------: | :------- | :------- | :------- | :------- |
| 每组二进制八位数（或字节）均可转换成十进制数 | 172      | 16       | 128      | 17       |
|         地址可使用点分十进制记法记录         | 172.     | 16.      | 128.     | 17       |

### 1.2 IP地址分类

![img](https://typora-images-1307361841.cos.ap-beijing.myqcloud.com/img/646b2d2e8955061d4fbfc91ebd67a03d.jpg) 

|                    | A类                                              | B类                         | C类                          | D类                         | E类        |
| ------------------ | ------------------------------------------------ | --------------------------- | ---------------------------- | --------------------------- | ---------- |
| 二进制表示         | 0 0000000 - 0 1111111.X.Y.Z                      | 10 000000 - 10 111111.X.Y.Z | 110 00000 - 110 1 1111.X.Y.Z | 1110 0000 - 1110 1111.X.Y.Z | 保留未使用 |
| 十进制表示法       | 0-127.X.Y.Z                                      | 128-191.X.Y.Z               | 192-223.X.Y.Z                | 224-239.X.Y.Z               | 240-255    |
| 网络ID             | 网络ID位是最高8位                                | 网络ID位是最高16位          | 网络ID位是最高24位           | 组（多）播                  |            |
| 主机ID             | 主机ID是24位低位                                 | 主机ID是16位低位            | 主机ID是8位低位              |                             |            |
| 网络数             | 126=2^7(可变是的网络ID位数)-2                    | 2^14=16384                  | 2^21=2097152                 |                             |            |
| 每个网络中的主机数 | 2^24-2=16777214                                  | 2^16-2=65534                | 2^8-2=254                    |                             |            |
| 默认子网掩码       | 255.0.0.0                                        | 255.255.0.0                 | 255.255.255.0                |                             |            |
| 私网地址           | 10.0.0.0                                         | 172.16.0.0-172.31.0.0       | 192.168.0.0-192.168.255.0    |                             |            |
| 范例               | 114.114.114.114,1.1.1.1，58.87.87.99119.29.29.29 | 180.76.76.76，172.16.0.1    | 223.6.6.6                    |                             |            |

A类地址的网络部分占用了8位，其中最高位固定为0。所以，实际可用于表示A类网络的位数为7位。因此，A类地址的网络数计算公式为2^7 - 2，这里减去的2代表全0（保留地址）和全1（广播地址）的网络地址。所以，A类地址总共有126个网络。

B类地址的网络部分占用了16位，其中最高两位固定为10。实际上，用于表示B类网络的位数为14位。所以，B类地址的网络数计算公式为2^14。与A类地址不同，B类地址计算时没有减去2，因为B类网络地址中没有全0和全1的情况。所以，B类地址总共有16,384个网络。

C类地址的网络部分占用了24位，其中最高三位固定为110。实际上，用于表示C类网络的位数为21位。所以，C类地址的网络数计算公式为2^21。同样地，C类地址计算时也没有减去2，因为C类网络地址中没有全0和全1的情况。所以，C类地址总共有2,097,152个网络。

总之，A类地址在计算网络数时需要减去2，是因为需要排除全0和全1的保留地址和广播地址。而B类和C类地址在计算网络数时没有这种限制，因为它们的网络地址中没有全0和全1的情况。

### 1.3 公共和私有IP地址

私有IP地址：不直接用于互联网，通常在局域网中使用

* A类：10.0.0.0到10.255.255.255 （一个网段）

* B类：172.16.0.0到172.31.255.255 （16个网段）

* C类：192.168.0.0到192.168.255.255 （256个网段）

  公共IP地址：互联网上设备拥有的唯一地址

A类：1.0.0.0到9.255.255.255 11.0.0.0到126.255.255.255

B类：128.0.0.0到172.15.255.255 172.32.0.0到191.255.255.255

C类：192.0.0.0到192.167.255.255 192.169.0.0到223.255.255.255

### 1.4 特殊地址

* 0.0.0.0：

不是一个真正意义上的IP地址。它表示所有不清楚的主机和目的网络。

* 255.255.255.255：

限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。

* 127.0.0.1～127.255.255.254：

本机回环地址，主要用于测试。在传输介质上永远不应该出现目的地址为“127.0.0.1”的 数据包。

* 224.0.0.0到239.255.255.255：

组播地址，224.0.0.1特指所有主机，224.0.0.2特指所有路由器。224.0.0.5指OSPF 路由器，地址多用于一些特定的程序以及多媒体程序。

* 169.254.x.x：

如果Windows主机使用了DHCP自动分配IP地址，而又无法从DHCP服务器获取地址，系统会为主机分配这样地址。

### 1.5 保留地址

主机位是全0或全1

范例:

```css
172.16.0.0 网络中的两个地址：172.16.0.0和172.16.255.255
```

### 1.6 子网掩码

**CIDR：**无类域间路由，目前的网络已不再按A，B，C类划分网段，可以任意指定网段的范围。

**CIDR 无类域间路由表示法：**IP/网络ID位数，如：172.16.0.100/16

**netmask子网掩码：**32位或128位（IPv6）的数字，和IP成对使用，用来确认IP地址中的网络ID和主机ID，对应网络ID的位为1，对应主机ID的位为0。

范例:255.255.255.0 ，表现为连续的高位为1，连续的低位为0

子网掩码的八位

![IP地址分类及网络配置方法和多网卡绑定技术应用_多网卡绑定_02](https://typora-images-1307361841.cos.ap-beijing.myqcloud.com/img/f693fcd86b6aef7051cb2ec39c9e9259.jpg) 

**相关公式：**

* 一个网络的最多的主机数＝2^主机ID位数-2

* 网络（段）数=2^网络ID中可变的位数

* 网络ID=IP与netmask

  范例:

  ```css
  netmask: 255.255.224.0，即网络ID位是19，那么主机ID位是13，主机数=2^13-2=8190
  ```

**判断对方主机是否在同一个网段**

用自已的子网掩码分别和自已的IP及对方的IP相与，比较结果，相同则同一网络，不同则不同网段。

范例：判断A和B是否在网一个网段

```css
A: 192.168.1.100 netmask:255.255.255.0
B: 192.168.2.100 netmask:255.255.0.0

1）用A主机子网掩码分别与A及B的IP与
A主机网络地址11000000.10101000.00000001.01100100与
A主机子网掩码11111111.11111111.11111111.00000000得
		   11000000.10101000.00000001.00000000即
192.168.1.0

B主机网络地址11000000.10101000.00000010.01100100与
A主机子网掩码11111111.11111111.11111111.00000000得
		   11000000.10101000.00000010.00000000即
192.168.2.0

192.168.1.0<>192.168.2.0，所以A和B不在同一网段


2）用B主机子网掩码分别与A及B的IP与
A主机网络地址11000000.10101000.00000001.01100100与
B主机子网掩码11111111.11111111.00000000.00000000得
		   11000000.10101000.00000000.00000000即
192.168.0.0

B主机网络地址11000000.10101000.00000010.01100100与
B主机子网掩码11111111.11111111.00000000.00000000得
		   11000000.10101000.00000000.00000000即
192.168.0.0

192.168.0.0<>192.168.0.0，所以A和B在同一网段

通过以上比较判断，两次的结果不一致，A和B是无法通讯的。
```

范例：计算网络ID、主机数

```css
1）主机IP：172.16.1.100/28
#此主机所在的网段最多有多少主机?
	#主机数=2^主机ID位数-2，即2^(32-28)-2=14
#网络ID? IP和子网掩码相与，172.16.1.96
	#即IP地址和子网掩码都转换成二进制后相与的结果
	172.16.1.100转换成二进制是：10101100.00010000.00000001.01100100
	 28位子网掩码转换成二进制是: 11111111.11111111.11111111.11110000
	 相与的结果是：             10101100.00010000.00000001.01100000
	 即：						 172.16.1.96
	 
#此网段的主机中最小的IP：主机位是0001，即172.16.1.0110 0001，转换成十进制是：172.16.1.97
#此网段的主机中最大的IP：主机位是1110，即172.16.1.0110 1110，转换成十进制是：172.16.1.110

2）主机IP：203.110.228.200/26
#主机数：2^(32-26)-2=62
#网络ID：因26=24+2，所以前3位不变203.110.228，最后一位11001000和掩码11000000相与，即11000000=192，所以网络ID就是203.110.228.192

#此网段的主机中最小的IP：主机位是00 0001，即203.110.228.1100 0001，转换成十进制是：203.110.228.193
#此网段的主机中最大的IP：主机位是00 1110，即203.110.228.1111 1110，转换成十进制是：203.110.228.254

```

### 1.7 划分子网

划分子网：将一个大的网络（主机数多）划分成多个小的网络（主机数少），主机ID位数变少，网络ID位数变多，网络ID位向主机ID位借位。

范例：

```css
1、把10.0.0.0/8网段划分为2个子网
#首先需要向主机ID借位，因为是2个子网，所以借1位就可以了
10.0    0000000.0.0/8	10.0.0.1~10.255.255.254
#网络ID向主机ID借1位，划分了2^1=2个子网
10.0    0000000.0.0
10.1    0000000.0.0
第一个子网：10.0.0.0/9	主机数：2^23-2
第二个子网：10.128.0.0/9	主机数：2^23-2

2、把10.0.0.0/8网段划分为4个子网
#网络ID需向主机ID借2位，划分2^2=4个子网
10.00   000000.0.0
10.01   000000.0.0
10.10   000000.0.0
10.11   000000.0.0
第一个子网：10.0.0.0/10	  主机数：2^22-2
第二个子网：10.64.0.0/10	  主机数：都同上
第三个子网：10.128.0.0/10
第四个子网：10.192.0.0/10
```

范例：

```css
中国移动10.0.0.0/8 给32个各省公司划分对应的子网
1）每个省公司的子网的netmask？
32个分公司，需要至少32个子网，因为2^5=32，所以需要借5位主机的ID。
即网络位就是8+5=13
子网掩码就是：11111111.11111000.0.0即255.248.0.0

2）每个省公司的子网的主机数有多少？
2^(32-13)-2=524286

3）河南省得到第10个子网，网络ID是多少？
因为10.00000 000.0.0/13是第1个子网，所以第10个子网就是10.01001 000.0.0/13，
转换成二进制就是10.72.0.0/13

4）河南省得到第10个子网的最小IP和最大的IP？
最小IP地址：10.01001 000.0.1，即10.72.0.1
最大IP地址：10.01001 111.11111111.11111110，即10.79.255.254

5）所有子网中最小和最大的子网的netid？
最小的网络ID：10.00000 000.0.0/13，即10.0.0.0/13
最大的网络ID：10.11111 000.0.0/13，即10.248.0.0/13

```

范例：

```css
中国移动10.0.0.0/8 给32个各省公司划分对应的子网，河南省得到第10个子网，再给省内的16个地市划分子
网。

#由上例得知，河南省得到的第10个子网的网络ID是10.01001 000.0.0/13，即10.72.0.0/13
#省内需再划分16个子网，即再从主机ID借4位，那网络ID就是17
1）每个市公司的子网的netmask？
#网络ID是17，所以子网掩码是255.255.128.0

2）每个市公司的子网的主机数有多少？
2^(32-17)-2=32766

3）各地市的最小netid和最大的netid？
最小的网络ID：10.01001 000.0 0000000.0，即10.72.0.0/17
最大的网络ID：10.01001 111.1 0000000.0，即10.79.128.0/17

4）洛阳市第2个子网，最小IP和最大IP？
第一个子网是10.01001 000.0 0000000.0，即10.72.0.0/17
第二个子网是10.01001 000.1 0000000.0，即10.72.128.0/17
第3~16个子网是：
10.73.0.0/17
10.73.128.0
10.74.0.0
10.74.128.0
10.75.0.0
10.75.128.0
10.76.0.0
10.76.128.0
10.77.0.0
10.77.128.0
10.78.0.0
10.78.128.0
10.79.0.0
10.79.128.0

洛阳第二个子网，最小IP和最大IP
最小IP：10.01001 000.1 0000000.00000001，即10.72.128.1/17
最大IP：10.01001 000.1 1111111.11111110，即10.72.255.254/17

```

1.8 优化IP地址分配

合并超网：将多个小网络合并成一个大网，主机ID位向网络ID位借位，实现路由表的优化，可以一条命令覆盖几个小网段。

范例:

```css
有8条路由记录，分别是
220.78.168.0/24
220.78.169.0/24
220.78.170.0/24
220.78.171.0/24
220.78.172.0/24
220.78.173.0/24
220.78.174.0/24
220.78.175.0/24
合并成一个大网，主机ID向网络ID借位，需要转换成二进制
220.78.10101 000.0
220.78.10101 001.0
220.78.10101 010.0
220.78.10101 011.0
202.78.10101 100.0
202.78.10101 101.0
202.78.10101 110.0
202.78.10101 111.0
可以看到168~175的前5位二进制相同，所以需要借5位给网络ID
网络ID：202.78.10101 000.0/21，即202.78.168.0/21
```

## 2、IP配置方法

### 2.1 网络配置方式

静态IP地址配置方法:

* ifconfig命令

* ip命令

* system-config-network-tui，setup

* 添加配置文件

* 动态分配：DHCP: Dynamic Host Configuration Protocol

### 2.2 ifconfig命令

来自于net-tools包，建议使用 ip 代替

```css
[root@repo-client ~]# rpm -qi net-tools
Name        : net-tools
Version     : 2.0
Release     : 0.25.20131004git.el7
Architecture: x86_64
Install Date: Sat 19 Dec 2020 08:05:53 PM CST
Group       : System Environment/Base
Size        : 938978
License     : GPLv2+
Signature   : RSA/SHA256, Fri 23 Aug 2019 05:36:04 AM CST, Key ID 24c6a8a7f4a80eb5
Source RPM  : net-tools-2.0-0.25.20131004git.el7.src.rpm
Build Date  : Fri 09 Aug 2019 09:10:26 AM CST
Build Host  : x86-02.bsys.centos.org
Relocations : (not relocatable)
Packager    : CentOS BuildSystem <http://bugs.centos.org>
Vendor      : CentOS
URL         : http://sourceforge.net/projects/net-tools/
Summary     : Basic networking tools
Description :
The net-tools package contains basic networking tools,
including ifconfig, netstat, route, and others.
Most of them are obsolete. For replacement check iproute package.

```

常用选项：

```css
ifconfig [interface]
ifconfig -a
ifconfig IFACE [up|down]
ifconfig interface [aftype] options | address ...
ifconfig IFACE IP/netmask [up]
ifconfig IFACE IP netmask NETMASK
```

范例：

```css
[root@repo-client ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.100.11  netmask 255.255.255.0  broadcast 192.168.100.255
        inet6 fe80::20c:29ff:feca:8ca2  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:ca:8c:a2  txqueuelen 1000  (Ethernet)
        RX packets 207  bytes 20062 (19.5 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 165  bytes 24380 (23.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@repo-client ~]# ifconfig -a
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.100.11  netmask 255.255.255.0  broadcast 192.168.100.255
        inet6 fe80::20c:29ff:feca:8ca2  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:ca:8c:a2  txqueuelen 1000  (Ethernet)
        RX packets 257  bytes 24070 (23.5 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 192  bytes 27358 (26.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

#添加ip地址
[root@repo-client ~]# ifconfig eth1 172.16.0.11 netmask 255.255.0.0
[root@repo-client ~]# ifconfig eth1
eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.16.0.11  netmask 255.255.0.0  broadcast 172.16.255.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
#清除eth1上的ip地址
[root@repo-client ~]# ifconfig eth1 0.0.0.0
[root@repo-client ~]# ifconfig eth1
eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


#禁用eth1
[root@repo-client ~]# ifconfig eth1 172.16.0.11/16
[root@repo-client ~]# ifconfig eth1
eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500		##UP状态
        inet 172.16.0.11  netmask 255.255.0.0  broadcast 172.16.255.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@repo-client ~]# ifconfig eth1 down
[root@repo-client ~]# ifconfig eth1				
eth1: flags=4098<BROADCAST,MULTICAST>  mtu 1500			#禁用，无UP
        inet 172.16.0.11  netmask 255.255.0.0  broadcast 172.16.255.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
#启用
[root@repo-client ~]# ifconfig eth1 up
[root@repo-client ~]# ifconfig eth1
eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.16.0.11  netmask 255.255.0.0  broadcast 172.16.255.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


#对一个网卡设置多个IP地址
[root@repo-client ~]# ifconfig eth1:1 192.168.0.11/24
[root@repo-client ~]# ifconfig eth1:1
eth1:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.11  netmask 255.255.255.0  broadcast 192.168.0.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
[root@repo-client ~]# ifconfig eth1:aaa 192.168.0.111/24	#可以用字符，一般用数字表示
[root@repo-client ~]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.100.11  netmask 255.255.255.0  broadcast 192.168.100.255
        inet6 fe80::20c:29ff:feca:8ca2  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:ca:8c:a2  txqueuelen 1000  (Ethernet)
        RX packets 1054  bytes 90065 (87.9 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 649  bytes 73792 (72.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.16.0.11  netmask 255.255.0.0  broadcast 172.16.255.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 59  bytes 9494 (9.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth1:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.11  netmask 255.255.255.0  broadcast 192.168.0.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)

eth1:aaa: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.111  netmask 255.255.255.0  broadcast 192.168.0.255
        ether 00:50:56:22:6f:2a  txqueuelen 1000  (Ethernet)
[root@repo-client ~]# ifconfig eth1:aaa down
[root@repo-client ~]# ifconfig eth1:1 down

```

范例：

```css
#统计当前网卡的流量
[root@repo-client ~]# ifconfig -s
Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0             1500     1255      0      0 0           766      0      0      0 BMRU
eth1             1500        0      0      0 0            59      0      0      0 BMRU
lo              65536        0      0      0 0             0      0      0      0 LRU

#监控当前网卡流量的变化（每秒）
[root@repo-client ~]# watch -n1 ifconfig -s		
Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0             1500     1331      0      0 0           818      0      0      0 BMRU
eth1             1500        0      0      0 0            59      0      0      0 BMRU
lo              65536        0      0      0 0             0      0      0      0 LRU


```

### 2.3 ip命令

来自于iproute包，可用于代替ifconfig

#### 2.3.1 配置Linux网络属性

**ip命令格式：**

```css
ip [ OPTIONS ] OBJECT { COMMAND | help }
```

ip 命令说明：

```css
OBJECT := { link | addr | route }
ip link - network device configuration
ip link set [dev IFACE]	[up|down]	#可设置属性，激活或禁用指定接口，相当于 ifup/ifdown
ip link show [dev IFACE] [up]  		#指定接口，up仅显示处于激活状态的接口
```

ip 地址管理：

```css
ip addr { add | del } IFADDR dev STRING [label LABEL] [scope {global|link|host}]
[broadcast ADDRESS]
[label LABEL] 				#添加地址时指明网卡别名
[scope {global|link|host}] 	#指明作用域，global全局可用；link仅链接可用；host本机可用
[broadcast ADDRESS]			#指明广播地址
ip address show				#同 ip a
ip addr flush				#清除网络地址
```

范例：

```css
#禁用网卡
[root@repo-client ~]# ip link set eth1 down
[root@repo-client ~]# ip a |grep eth1
3: eth1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    inet 172.16.0.11/16 brd 172.16.255.255 scope global eth1

#网卡改名并启用
[root@repo-client ~]# ip link set eth1 up
[root@repo-client ~]# ip link set eth1 name wangnet		#网卡使用时不能改名
RTNETLINK answers: Device or resource busy
[root@repo-client ~]# ip link set eth1 down
[root@repo-client ~]# ip link set eth1 name wangnet		#eth1 down后，就能修改名字了
[root@repo-client ~]# ip link set eth1 up
Cannot find device "eth1"
[root@repo-client ~]# ip link set wangnet up			#使用修改后的名字
[root@repo-client ~]# ip a |grep wangnet
3: wangnet: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 172.16.0.11/16 brd 172.16.255.255 scope global wangnet

#网卡别名
#添加网卡别名
[root@repo-client ~]# ip addr add 172.16.100.100/16 dev eth0 label eth0:0
[root@repo-client ~]# ip a |grep eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0
    inet 172.16.100.100/16 scope global eth0:0
#删除网卡别名
[root@repo-client ~]# ip addr del 172.16.100.100/16
Not enough information: "dev" argument is required.
[root@repo-client ~]# ip addr del 172.16.100.100/16 dev eth0
[root@repo-client ~]# ip a |grep eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0
[root@repo-client ~]#

#清除网络地址
[root@repo-client ~]# ip a|grep wangnet
3: wangnet: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 172.16.0.11/16 brd 172.16.255.255 scope global wangnet
[root@repo-client ~]# ip a flush dev wangnet
[root@repo-client ~]# ip a|grep wangnet
3: wangnet: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
[root@repo-client ~]#

```

ip route:

常用选项：

```css
ip route { list | flush } SELECTOR
ip route { add | del | change | append | replace } ROUTE

ip route add TARGET via GW dev IFACE src SOURCE_IP
TARGET:主机路由：IP网络路由：NETWORK/MASK

```

范例：

```css
#添加ip地址
[root@repo-client ~]# ip a a 172.16.0.11/16 dev wangnet
[root@repo-client ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:ca:8c:a2 brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
3: wangnet: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:50:56:22:6f:2a brd ff:ff:ff:ff:ff:ff
    inet 172.16.0.11/16 scope global wangnet
       valid_lft forever preferred_lft forever
#查看路由
[root@repo-client ~]# ip route
default via 192.168.100.2 dev eth0 proto static metric 100
172.16.0.0/16 dev wangnet proto kernel scope link src 172.16.0.11
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.11 metric 100
#增加一条路由
[root@repo-client ~]# ip route add default via 172.16.0.1 dev wangnet
[root@repo-client ~]# ip route
default via 172.16.0.1 dev wangnet
default via 192.168.100.2 dev eth0 proto static metric 100
172.16.0.0/16 dev wangnet proto kernel scope link src 172.16.0.11
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.11 metric 100
[root@repo-client ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.16.0.1      0.0.0.0         UG    0      0        0 wangnet
0.0.0.0         192.168.100.2   0.0.0.0         UG    100    0        0 eth0
172.16.0.0      0.0.0.0         255.255.0.0     U     0      0        0 wangnet
192.168.100.0   0.0.0.0         255.255.255.0   U     100    0        0 eth0
#删除路由
[root@repo-client ~]# ip route del default via 172.16.0.1
[root@repo-client ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.100.2   0.0.0.0         UG    100    0        0 eth0
172.16.0.0      0.0.0.0         255.255.0.0     U     0      0        0 wangnet
192.168.100.0   0.0.0.0         255.255.255.0   U     100    0        0 eth0
[root@repo-client ~]# ip route show
default via 192.168.100.2 dev eth0 proto static metric 100
172.16.0.0/16 dev wangnet proto kernel scope link src 172.16.0.11
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.11 metric 100

#清空wangnet的路由表
[root@repo-client ~]# ip route flush dev wangnet
[root@repo-client ~]# ip route show
default via 192.168.100.2 dev eth0 proto static metric 100
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.11 metric 100
[root@repo-client ~]#

#添加路由
[root@repo-client ~]# ip route add 1.1.1.0/24 via 172.16.0.11 dev wangnet proto static metric 100
[root@repo-client ~]# ip route show
default via 192.168.100.2 dev eth0 proto static metric 100
1.1.1.0/24 via 172.16.0.11 dev wangnet proto static metric 100
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.11 metric 100
[root@repo-client ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.100.2   0.0.0.0         UG    100    0        0 eth0
1.1.1.0         172.16.0.11     255.255.255.0   UG    100    0        0 wangnet
192.168.100.0   0.0.0.0         255.255.255.0   U     100    0        0 eth0
[root@repo-client ~]# ip route del 1.1.1.0/24
[root@repo-client ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.100.2   0.0.0.0         UG    100    0        0 eth0
192.168.100.0   0.0.0.0         255.255.255.0   U     100    0        0 eth0
[root@repo-client ~]# ip route show
default via 192.168.100.2 dev eth0 proto static metric 100
192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.11 metric 100
[root@repo-client ~]#

```

### 2.4 网络配置文件

#### 2.4.1 网络基本配置文件

IP、MASK、GW、DNS相关的配置文件路径：

```css
/etc/sysconfig/network-scripts/ifcfg-IFACE
```

说明参考：

```css
/usr/share/doc/initcripts-*/sysconfig.txt
```

常用配置：

| 设置          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| ***TYPE       | 接口类型常见有的Ethernet, Bridge                             |
| ***NAME       | 此配置文件应用到的设备，nmcli c中显示的name名称              |
| ***DEVICE     | 设备名                                                       |
| HWADDR        | 对应的设备的MAC地址                                          |
| UUID          | 设备的惟一标识                                               |
| ***BOOTPROTO  | 激活此设备时使用的地址配置协议，常用的dhcp, static, none, bootp |
| ***IPADDR     | 指明IP地址                                                   |
| ***NETMASK    | 子网掩码,如:255.255.255.0                                    |
| ***PREFIX     | 网络ID的位数, 如:24                                          |
| ***GATEWAY    | 默认网关,目的是用于生成默认路由                              |
| ***DNS1       | 第一个DNS服务器地址                                          |
| DNS2          | 第二个DNS服务器地址                                          |
| DOMAIN        | 主机不完整时，自动搜索的域名后缀                             |
| ***ONBOOT     | 在系统引导时是否激活此设备                                   |
| USERCTL       | 普通用户是否可控制此设备                                     |
| PEERDNS       | 如果BOOTPROTO的值为“dhcp”，YES将允许dhcp server分配的<br/>dns服务器信息直接覆盖至/etc/resolv.conf文件，NO不允许修改resolv.conf |
| NM_CONTROLLED | NM是NetworkManager的简写，此网卡是否接受NM控制               |

#### 2.4.2 配置当前主机的主机名

```css
#centos6系统之前版本
/etc/sysconfig/network
HOSTNAME=

#centos7系统以后版本
/etc/hostname
HOSTNAME

hostnamectl set-hostname centos7.magedu.com		#直接修改主机名并生效
```

#### 2.4.3 本地主机名数据库和IP地址的映射

优先于使用DNS前检查

```css
getent hosts		#查看/etc/hosts 内容
[root@repo-client ~]# getent hosts
127.0.0.1       localhost localhost.localdomain localhost4 localhost4.localdomain4
127.0.0.1       localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.100.12  repo-server
172.16.100.11   moban
172.16.100.21   lb01
172.16.100.22   lb02
172.16.100.31   web01
172.16.100.32   web02
172.16.100.33   web03
172.16.100.41   db01 db01.etiantian.org
172.16.100.51   backup
172.16.100.61   nfs01
172.16.100.10   m01

```

#### 2.4.4 DNS域名解析

```css
/etc/resolv.conf
nameserver DNS_SERVER_IP1
nameserver DNS_SERVER_IP2
nameserver DNS_SERVER_IP3
search DOMAIN

[root@repo-client ~]# cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 192.168.100.2

#Ubuntu18.04以后用这个命令查看DNS    
[root@ubuntu1804 ~]#systemd-resolve --status
    
```

#### 2.4.5 修改 /etc/hosts和DNS的优先级

```css
[root@repo-client ~]# cat /etc/nsswitch.conf |grep host
#hosts:     db files nisplus nis dns
hosts:      files dns myhostname
```

#### 2.4.6 路由相关的配置文件

```css
/etc/sysconfig/network-scripts/route-IFACE	#需手动创建这个文件，配置好后，重启能保存

#两种风格：
1) TARGET via GW
	10.0.0.0/8 via 172.16.0.1
2) 每三行定义一条路由，比较繁琐，建议使用第一种
ADDRESS#=TARGET
NETMASK#=mask
GATEWAY#=GW
```

### 2.5 网卡别名

将多个IP地址绑定到一个NIC上

每个IP绑定到独立逻辑网卡，即网络别名，命名格式： ethX:Y，如：eth0:1 、eth0:2、eth0:3

范例：ifconfig命令

```css
ifconfig eth0:0 192.168.1.100/24 up
ifconfig eth0:0 down

[root@repo-client ~]# ifconfig|grep eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
[root@repo-client ~]# ifconfig eth0:0 176.16.100.11/16
[root@repo-client ~]# ifconfig|grep eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
eth0:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
[root@repo-client ~]# ifconfig eth0:0 down
[root@repo-client ~]# ifconfig|grep eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500

```

范例：ip 命令

```css
ip addr add 172.16.1.1/16 dev eth0
ip addr add 172.16.1.2/16 dev eth0 label eth0:0
ip addr del 172.16.1.2/16 dev eth0 label eth0:0
ip addr flush dev eth0 label eth0:0

[root@repo-client ~]# ip addr add 172.16.1.100/16 dev eth0 label eth0:0
[root@repo-client ~]# ifconfig|grep eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
eth0:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
[root@repo-client ~]# ip a|grep eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0
    inet 172.16.1.100/16 scope global eth0:0


[root@repo-client ~]# ip addr del 172.16.1.100/16
Not enough information: "dev" argument is required.
[root@repo-client ~]# ip addr del 172.16.1.100/16 dev eth0
[root@repo-client ~]# ip a|grep eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0

[root@repo-client ~]# ip addr flush dev eth0	#清除eth0的ip地址

```

注：ip和ifconfig都是临时生效，重启后无法保存配置。

为每个设备别名生成独立的接口配置文件，格式为：ifcfg-ethX:xxx，保存后，重启也不丢失。

范例：配置eth0:1网卡别名的格式文件，别名中的IP地址只能是静态IP地址，不能使用DHCP服务器分配。

```css
#配置文件
[root@repo-client ~]# cd /etc/sysconfig/network-scripts/
[root@repo-client network-scripts]# cat ifcfg-eth0:1
DEVICE=eth0:1
IPADDR=172.16.100.11
PREFIX=16
[root@repo-client network-scripts]# ls
ifcfg-eth0   ifcfg-eth0:1
#配置后不会立即生效
[root@repo-client network-scripts]# ip a|grep eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0
#需要重新挂载eth0，才能生效
[root@repo-client network-scripts]# nmcli c reload
[root@repo-client network-scripts]# nmcli c up eth0
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/6)
[root@repo-client network-scripts]# ip a|grep eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    inet 192.168.100.11/24 brd 192.168.100.255 scope global noprefixroute eth0
    inet 172.16.100.11/16 brd 172.16.255.255 scope global noprefixroute eth0:1

```

注意：

* 建议 CentOS 6 关闭 NetworkManager 服务
* 网卡别名必须使用静态地址

## 3、使用配置文件实现bonding

### 3.1 多网卡 bonding

`Bonding共7种模式：0-6 Mode`

* Mode 0 (balance-rr)： 轮询（Round-robin）策略，从头到尾顺序的在每一个slave接口上面发送数据包。本模式提供负载均衡和容错的能力
* Mode 1 (active-backup)： 活动-备份（主备）策略，只有一个slave被激活，当且仅当活动的slave接口失败时才会激活其他slave.为了避免交换机发生混乱此时绑定的MAC地址只有一个外部端口上可见。
* Mode 3 (broadcast)：广播策略，在所有的slave接口上传送所有的报文,提供容错能力。

说明：

active-backup、balance-tlb 和 balance-alb 模式不需要交换机的任何特殊配置。

其他绑定模式需要配置交换机以便整合链接。如：Cisco 交换机需要在模式 0、2 和 3 中使用 EtherChannel，但在模式4中需要 LACP和 EtherChannel。

#### 3.1.2 创建bonding设备的配置文件

```css
/etc/sysconfig/network-scripts/ifcfg-bond0
TYPE=bond
DEVICE=bond0
BOOTPROTO=none
IPADDR=10.0.0.100
PREFIX=8
#miimon指定链路监测时间间隔。如果miimon=100，那么系统每100ms 监测一次链路连接状态，如果有一条线路不通就转入另一条线路
BONDING_OPTS="mode=1 miimon=100"

```

查看bond0状态：

```css
/proc/net/bonding/bond0
```

### 3.2 实例：bond mode=1模式

```css
1、配置bond和其他两块网卡
[root@centos8 network-scripts]# cat ifcfg-bond0 ifcfg-ens33 ifcfg-ens37
TYPE=bond
DEVICE=bond0
BOOTPROTO=none
IPADDR=192.168.100.222
PREFIX=24
BONDING_OPTS="mode=1 miimon=100"

DEVICE=ens33
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
ONBOOT=yes

DEVICE=ens37
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
ONBOOT=yes
[root@centos8 network-scripts]# reboot

2、重启后，重新连接
[root@centos8 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc fq_codel master bond0 state UP group default qlen 1000
    link/ether 00:0c:29:f9:bb:44 brd ff:ff:ff:ff:ff:ff
3: ens37: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc fq_codel master bond0 state UP group default qlen 1000
    link/ether 00:0c:29:f9:bb:44 brd ff:ff:ff:ff:ff:ff
4: bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 00:0c:29:f9:bb:44 brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.222/24 brd 192.168.100.255 scope global noprefixroute bond0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fef9:bb44/64 scope link
       valid_lft forever preferred_lft forever
[root@centos8 ~]# nmcli c
NAME          UUID                                  TYPE      DEVICE
Bond bond0    ad33d8b0-1f7b-cab9-9447-ba07f855b143  bond      bond0
System ens33  c96bc909-188e-ec64-3a96-6a90982b08ad  ethernet  ens33
System ens37  4a5516a4-dfa4-24af-b1c4-e843e312e2fd  ethernet  ens37

3、查看bond0状态
[root@centos8 ~]# cat /proc/net/bonding/bond0
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: ens33		#当前使用ens33
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0
Peer Notification Delay (ms): 0

Slave Interface: ens33
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f9:bb:44
Slave queue ID: 0

Slave Interface: ens37
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f9:bb:4e
Slave queue ID: 0

#查看使用的mac地址
[root@centos7 ~]# ping 192.168.100.222
PING 192.168.100.222 (192.168.100.222) 56(84) bytes of data.
64 bytes from 192.168.100.222: icmp_seq=1 ttl=64 time=0.321 ms
64 bytes from 192.168.100.222: icmp_seq=2 ttl=64 time=0.610 ms
64 bytes from 192.168.100.222: icmp_seq=3 ttl=64 time=0.371 ms
64 bytes from 192.168.100.222: icmp_seq=4 ttl=64 time=0.454 ms
64 bytes from 192.168.100.222: icmp_seq=5 ttl=64 time=1.29 ms

[root@centos7 ~]# arp -n
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.100.222          ether   00:0c:29:f9:bb:44   C                     eth0

4、拔掉ens33网线
[root@centos8 ~]# cat /proc/net/bonding/bond0
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: ens37		#使用第二块网卡
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0
Peer Notification Delay (ms): 0

Slave Interface: ens33			#ens33网卡down
MII Status: down
Speed: Unknown
Duplex: Unknown
Link Failure Count: 1
Permanent HW addr: 00:0c:29:f9:bb:44
Slave queue ID: 0

Slave Interface: ens37
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f9:bb:4e
Slave queue ID: 0

#查看网卡的状态，ethtool命令或mii-tool命令
[root@centos8 ~]# ethtool ens33
Settings for ens33:
        Link detected: no
[root@centos8 ~]# ethtool ens37
Settings for ens37:
        Link detected: yes

```

实例：mode=3模式

```css
1、修改mode=3，即broadcast广播模式
[root@centos8 network-scripts]# cat ifcfg-bond0
TYPE=bond
DEVICE=bond0
BOOTPROTO=none
IPADDR=192.168.100.222
PREFIX=24
BONDING_OPTS="mode=3 miimon=100"

#查看bond
[root@centos8 ~]# cat /proc/net/bonding/bond0
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (broadcast)
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0
Peer Notification Delay (ms): 0

Slave Interface: ens33
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f9:bb:44
Slave queue ID: 0

Slave Interface: ens37
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f9:bb:4e
Slave queue ID: 0
[root@centos8 ~]#

2、测试，DUP，会收到2个一样的答复。好处是容错能力强。
这两块网卡同时工作，提供一模一样的数据
[root@repo-client ~]# ping 192.168.100.222
PING 192.168.100.222 (192.168.100.222) 56(84) bytes of data.
64 bytes from 192.168.100.222: icmp_seq=1 ttl=64 time=0.524 ms
64 bytes from 192.168.100.222: icmp_seq=1 ttl=64 time=0.637 ms (DUP!)
64 bytes from 192.168.100.222: icmp_seq=2 ttl=64 time=0.431 ms
64 bytes from 192.168.100.222: icmp_seq=2 ttl=64 time=0.447 ms (DUP!)
64 bytes from 192.168.100.222: icmp_seq=3 ttl=64 time=0.307 ms
64 bytes from 192.168.100.222: icmp_seq=3 ttl=64 time=0.324 ms (DUP!)

```

实例：删除bond0

```css
1）卸载bond0
ifconfig bond0 down
rmmod bonding	#同modprobe -r bonding
2）删除ifcfg-bond0配置文件
3）恢复eth0和eth1等的配置文件
4）重启网络服务
centos6：service network restart
centos7以上：nmcli c reload
			nmcli c up eth0 eth1
```

## 4、使用nmcli实现bonding

### 4.1 nmcli命令

mcli命令相关术语

* 设备即网络接口
* 连接是对网络接口的配置，一个网络接口可有多个连接配置，但同时只有一个连接配置生效

格式：

```css
nmcli [ OPTIONS ] OBJECT { COMMAND | help }
	device - show and manage network interfaces
	nmcli device help
	connection - start, stop, and manage network connections
	nmcli connection help
```

修改IP地址等属性

```css
nmcli connection modify IFACE [+|-]setting.property value
	setting.property: ipv4.addresses ipv4.gateway ipv4.dns1 ipv4.method manual |auto
```

修改配置文件执行生效

```css
nmcli con reload
nmcli con up con-name
```

nmcli命令对应ifcfg-*文件

| nmcli con mod                    | fcfg**-*** 文件              |
| -------------------------------- | ---------------------------- |
| ipv4.method manual               | BOOTPROTO=none               |
| ipv4.method auto                 | BOOTPROTO=dhcp               |
| ipv4.addresses 192.168.2.1/24    | IPADDR=192.168.2.1 PREFIX=24 |
| ipv4.gateway 172.16.0.200        | GATEWAY=172.16.0.200         |
| ipv4.dns 8.8.8.8                 | DNS0=8.8.8.8                 |
| ipv4.dns-search example.com      | DOMAIN=example.com           |
| ipv4.ignore-auto-dns true        | PEERDNS=no                   |
| connection.autoconnect yes       | ONBOOT=yes                   |
| connection.id eth0               | NAME=eth0                    |
| connection.interface-name eth0   | DEVICE=eth0                  |
| 802-3-ethernet.mac-address . . . | HWADDR= . . .                |

范例：

```css
#查看帮助
nmcli con add help
#使用nmcli配置网络
nmcli con show
#显示所有活动连接
nmcli con show --active

[root@centos7 ~]# nmcli c show
NAME   UUID                                  TYPE      DEVICE
ens33  a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33
ens37  4a5516a4-dfa4-24af-b1c4-e843e312e2fd  ethernet  ens37
[root@centos7 ~]# nmcli c down ens37	#down掉ens37
Connection 'ens37' successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)
[root@centos7 ~]# nmcli c
NAME   UUID                                  TYPE      DEVICE
ens33  a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33
ens37  4a5516a4-dfa4-24af-b1c4-e843e312e2fd  ethernet  --
[root@centos7 ~]# nmcli c show --active		#只显示活动的网卡
NAME   UUID                                  TYPE      DEVICE
ens33  a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33

#显示网络连接配置的详细信息
nmcli con show eth0
#显示设备状态
nmcli dev status

[root@centos7 ~]# nmcli dev
DEVICE  TYPE      STATE         CONNECTION
ens33   ethernet  connected     ens33
ens37   ethernet  disconnected  --
lo      loopback  unmanaged     --
[root@centos7 ~]# nmcli dev status
DEVICE  TYPE      STATE         CONNECTION
ens33   ethernet  connected     ens33
ens37   ethernet  disconnected  --
lo      loopback  unmanaged     --

#显示网络接口属性
nmcli dev show eth0

[root@centos7 ~]# nmcli dev show ens33
GENERAL.DEVICE:                         ens33
GENERAL.TYPE:                           ethernet
GENERAL.HWADDR:                         00:0C:29:21:F8:76
GENERAL.MTU:                            1500
GENERAL.STATE:                          100 (connected)
GENERAL.CONNECTION:                     ens33
GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/1
WIRED-PROPERTIES.CARRIER:               on
IP4.ADDRESS[1]:                         192.168.209.11/24
IP4.GATEWAY:                            192.168.209.2
IP4.ROUTE[1]:                           dst = 192.168.209.0/24, nh = 0.0.0.0, mt = 100
IP4.ROUTE[2]:                           dst = 0.0.0.0/0, nh = 192.168.209.2, mt = 100
IP4.DNS[1]:                             192.168.209.2
IP6.ADDRESS[1]:                         fe80::9ed9:d4db:e410:64dd/64
IP6.GATEWAY:                            --
IP6.ROUTE[1]:                           dst = fe80::/64, nh = ::, mt = 100
IP6.ROUTE[2]:                           dst = ff00::/8, nh = ::, mt = 256, table=255
[root@centos7 ~]#


#创建新连接default，IP自动通过dhcp获取
nmcli con add con-name default type Ethernet ifname eth0
#删除指定的连接
nmcli con del default

[root@centos7 ~]# nmcli c del ens37
Connection 'ens37' (4a5516a4-dfa4-24af-b1c4-e843e312e2fd) successfully deleted.
[root@centos7 ~]# nmcli c
NAME   UUID                                  TYPE      DEVICE
ens33  a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33
[root@centos7 ~]# ll /etc/sysconfig/network-scripts/ifcfg-	
ifcfg-ens33  ifcfg-lo		##ens37的配置文件也没有了


#创建新连接static ，指定静态IP，不自动连接
nmcti con add con-name static ifname eth0 autoconnect no type Ethernet
ipv4.addresses 172.25.X.10/24 ipv4.gateway 172.25.X.254
#启用static连接配置
nmcli con up static
#启用default连接配置
nmcli con up default
#修改连接设置
nmcli con mod “static” connection.autoconnect no
nmcli con mod “static” ipv4.dns 172.25.X.254
nmcli con mod “static” +ipv4.dns 8.8.8.8
nmcli con mod “static” -ipv4.dns 8.8.8.8
nmcli con mod “static” ipv4.addresses “172.16.X.10/24 172.16.X.254”
nmcli con mod “static” +ipv4.addresses 10.10.10.10/16
#DNS设置存放在/etc/resolv.conf，PEERDNS=no 表示当IP通过dhcp自动获取时，dns仍是手动设置，
不自动获取等价于下面命令
nmcli con mod “system eth0” ipv4.ignore-auto-dns yes
```

### 4.2 nmcli实现bonding

常用命令：

```css
#添加bonding接口
nmcli con add type bond con-name mybond0 ifname bond0 mode active-backup
#添加从属接口
nmcli con add type bond-slave ifname ens7 master bond0
nmcli con add type bond-slave ifname ens3 master bond0
#注：如无为从属接口提供连接名，则该名称是接口名称加类型构成
#要启动绑定，则必须首先启动从属接口
nmcli con up bond-slave-eth0
nmcli con up bond-slave-eth1
#启动绑定
nmcli con up mybond0
```

实例：使用nmcli实现bonding

```css
#1）初始化两块网卡及原ip地址信息
[root@centos7 network-scripts]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:21:f8:76 brd ff:ff:ff:ff:ff:ff
    inet 192.168.209.11/24 brd 192.168.209.255 scope global noprefixroute ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::9ed9:d4db:e410:64dd/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: ens37: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:21:f8:80 brd ff:ff:ff:ff:ff:ff
[root@centos7 network-scripts]# nmcli c
NAME   UUID                                  TYPE      DEVICE
ens33  a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33

#2）添加bond0接口，bond模式为mode1（active-backup）
[root@centos7 network-scripts]# nmcli con add type bond con-name mybond0 ifname bond0 mode active-backup
Connection 'mybond0' (0240cad5-db79-4832-96f1-398cf3a9633c) successfully added.
[root@centos7 network-scripts]# ls ifcfg*
ifcfg-ens33  ifcfg-lo  ifcfg-mybond0

#3）添加ens33和ens37为bond0的从属接口
[root@centos7 network-scripts]# nmcli con add type bond-slave ifname ens37 master bond0
Connection 'bond-slave-ens37' (60e13f31-5f0d-45b5-93ac-18a1e24ec175) successfully added.
[root@centos7 network-scripts]# nmcli con add type bond-slave ifname ens33 master bond0
Connection 'bond-slave-ens33' (069c01fc-d7cb-44a9-8ea7-5ae3a5e14d69) successfully added.
[root@centos7 network-scripts]# nmcli c
NAME              UUID                                  TYPE      DEVICE
mybond0           0240cad5-db79-4832-96f1-398cf3a9633c  bond      bond0
ens33             a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33
bond-slave-ens37  60e13f31-5f0d-45b5-93ac-18a1e24ec175  ethernet  ens37
bond-slave-ens33  069c01fc-d7cb-44a9-8ea7-5ae3a5e14d69  ethernet  --

#4）启用从属接口
[root@centos7 network-scripts]# nmcli con up bond-slave-ens33
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/11)
[root@centos7 network-scripts]# nmcli con up bond-slave-ens37
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/15)
[root@centos7 network-scripts]# ip a
6: bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 00:0c:29:21:f8:80 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::6147:711:da31:1859/64 scope link noprefixroute
       valid_lft forever preferred_lft forever

#5）bond0设置ip地址等信息
[root@centos7 network-scripts]# nmcli con mod mybond0 ipv4.addresses 192.168.209.12/24 ipv4.gateway 192.168.209.2 ipv4.dns 223.6.6.6 ipv4.method manual
[root@centos7 network-scripts]# cat ifcfg-mybond0
BONDING_OPTS=mode=active-backup
TYPE=Bond
BONDING_MASTER=yes
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=none
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=mybond0
UUID=0240cad5-db79-4832-96f1-398cf3a9633c
DEVICE=bond0
ONBOOT=yes
IPADDR=192.168.209.12
PREFIX=24
GATEWAY=192.168.209.2
DNS1=223.6.6.6

[root@centos7 network-scripts]# nmcli c
NAME              UUID                                  TYPE      DEVICE
ens33             a91ee66a-f9e5-49f3-9be2-ec3d509b0e69  ethernet  ens33
mybond0           0240cad5-db79-4832-96f1-398cf3a9633c  bond      bond0
bond-slave-ens37  60e13f31-5f0d-45b5-93ac-18a1e24ec175  ethernet  ens37
bond-slave-ens33  069c01fc-d7cb-44a9-8ea7-5ae3a5e14d69  ethernet  --

#6）启用bond-slave-ens33，并删除ens33接口
[root@centos7 network-scripts]# nmcli c up bond-slave-ens33
[root@centos7 ~]# nmcli c del ens33
[root@centos7 ~]# nmcli c
NAME              UUID                                  TYPE      DEVICE
mybond0           0240cad5-db79-4832-96f1-398cf3a9633c  bond      bond0
bond-slave-ens33  069c01fc-d7cb-44a9-8ea7-5ae3a5e14d69  ethernet  ens33
bond-slave-ens37  60e13f31-5f0d-45b5-93ac-18a1e24ec175  ethernet  ens37

[root@centos7 ~]# reboot
[root@centos7 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master bond0 state UP group default qlen 1000
    link/ether 00:0c:29:21:f8:76 brd ff:ff:ff:ff:ff:ff
3: ens37: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master bond0 state UP group default qlen 1000
    link/ether 00:0c:29:21:f8:76 brd ff:ff:ff:ff:ff:ff
4: bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether 00:0c:29:21:f8:76 brd ff:ff:ff:ff:ff:ff
    inet 192.168.209.12/24 brd 192.168.209.255 scope global noprefixroute bond0
       valid_lft forever preferred_lft forever
    inet6 fe80::6147:711:da31:1859/64 scope link noprefixroute
       valid_lft forever preferred_lft forever

#7）查看bond0状态，首选是ens33网卡，ens37备用
[root@centos7 ~]# cat /proc/net/bonding/bond0
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: ens33
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0

Slave Interface: ens33
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:21:f8:76
Slave queue ID: 0

Slave Interface: ens37
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:21:f8:80
Slave queue ID: 0

#8）测试，断掉ens33网卡，就使用第二块网卡
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: ens37		#使用第二块网卡
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0
Peer Notification Delay (ms): 0

Slave Interface: ens33			#ens33网卡down
MII Status: down
Speed: Unknown
Duplex: Unknown
Link Failure Count: 1
Permanent HW addr: 00:0c:29:f9:bb:44
Slave queue ID: 0

Slave Interface: ens37
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f9:bb:4e
Slave queue ID: 0
```

## 5. 二进制与十进制计算

### 5.1 二进制按位与运算（遇0则0，全1为1）：

使用按位与运算来计算网络地址，然后根据子网掩码中的主机位数来确定子网内的地址范围。这使得我们能够轻松地识别属于同一子网的所有IP地址。

IP地址：  192.168.1.5   (11000000.10101000.00000001.00000101)

子网掩码： 255.255.255.0  (11111111.11111111.11111111.00000000)

11000000.10101000.00000001.00000101

11111111.11111111.11111111.00000000

\-----------------------------------

11000000.10101000.00000001.00000000

结果是11000000.10101000.00000001.00000000，即192.168.1.0，这就是网络地址。

按位与（AND）运算在计算网络地址时的使用是为了根据给定的IP地址和子网掩码找到属于同一子网的所有IP地址的共同前缀。按位与运算有一个很重要的特性：如果在两个二进制数中，相应的位都是1，那么结果中的该位为1；否则，结果中的该位为0。

子网掩码的作用是指示IPv4地址中哪些位属于网络部分，哪些位属于主机部分。子网掩码的二进制表示中，网络部分的所有位都是1，主机部分的所有位都是0。

当我们对一个IP地址和子网掩码进行按位与运算时，由于子网掩码的主机部分都是0，所以按位与运算的结果会保留IP地址的网络部分，而将主机部分设置为0。这样，我们就得到了IP地址所在子网的网络地址。网络地址是子网中的第一个地址，用于唯一标识一个子网。

### 5.2 二进制转换十进制：

一个8位二进制数转换成一个十进制数的方法：一个8位二进制数等于两个十六进制数相加，前4位为一组，后四位为一组。先用前4位的二进制数求出10进制数乘以16^1,后四位的二进制数求出10进制乘以16^0，然后求和。记录下面的可以快速计算

例如：11001101转成10进制：

1100	12*16^1=192

1101	13*16^0=13

192+13=205,所以这个二进制数转换成10进制数就是205

0000   0

0001   1

0010   2

0011   3

0100   4

0101   5

0110   6

0111   7

1000   8

1001   9

1010   10

1011   11

1100   12

1101   13

1110   14

1111   15

## 6.相关概念介绍

### CIDR

CIDR（无类别域间路由，Classless Inter-Domain Routing）是一种用于表示IPv4和IPv6地址和子网掩码的简洁表示法。CIDR是在20世纪90年代引入的，目的是为了提高IP地址分配的效率并减轻路由表的负担。CIDR取代了早期基于类（A、B、C类）的IP地址分配方式，提供了更灵活的子网划分。

CIDR表示法的形式为：IP地址/前缀长度。

例如，一个IPv4地址的CIDR表示法为：192.168.1.0/24。这里，192.168.1.0是IP地址，24是前缀长度，表示网络前缀占用了32位IPv4地址中的前24位。剩余的8位用于主机地址，可以在子网中容纳2^8-2 = 254台设备（减2是因为需要排除全0（网络地址）和全1（广播地址）的情况）。

CIDR的优势在于它可以更灵活地分配IP地址。在基于类的IP地址分配方法中，A类、B类和C类地址的网络和主机部分是固定的。使用CIDR，可以根据实际需求灵活地划分子网，从而更高效地利用IP地址空间。

CIDR还有助于减轻路由器的负担，因为它允许路由表中的多个相邻子网聚合为一个更大的地址范围。这称为路由聚合或路由汇总，它可以减少全球互联网上路由器所需的路由表项数量

给定的CIDR表示法是203.101.123.163/28，其中203.101.123.163是一个IPv4地址，28是前缀长度。我们将逐个计算子网掩码、最大IP和最小IP。

子网掩码：前缀长度为28位，表示子网掩码的前28位为1，剩余4位为0。因此，子网掩码为255.255.255.240。

ip地址个数：2^4-2=14,说明有14个ip地址

最小IP（网络地址）：将IP地址的前28位与子网掩码进行按位与（AND）运算，可以得到网络地址。所以，203.101.123.163和255.255.255.240的按位与运算结果是203.101.123.160。这是子网中的最小IP地址（网络地址）。

最大IP（广播地址）：将网络地址的剩余位（主机部分）全部置为1，可以得到广播地址。所以，将203.101.123.160的后4位设置为1，得到203.101.123.175。这是子网中的最大IP地址（广播地址）。

在给定的CIDR表示法203.101.123.163/28中，163是一个具体的IPv4地址。在子网范围内（从203.101.123.161到203.101.123.174），它表示子网内的一个特定设备或主机。注意，我们没有包括网络地址（203.101.123.160）和广播地址（203.101.123.175），因为它们在子网中具有特殊用途，不能分配给主机。

### ARP

ARP（地址解析协议）是一种网络协议，用于在局域网（LAN）中发现和映射IP地址到物理地址（例如MAC地址）。这是因为在以太网和其他类似的网络上，数据包是根据物理地址进行传输的，而不是根据IP地址。ARP协议允许设备根据已知的IP地址找到对应的物理地址，从而确保数据能够正确传输到目标设备。

ARP的工作过程分为以下几个步骤：

1. 主机A需要与主机B通信，但只知道主机B的IP地址，不知道其物理地址（MAC地址）。
2. 主机A发送一个ARP请求数据包，广播到局域网中的所有设备。该数据包包含发送者的IP和MAC地址（即主机A的地址），以及目标IP地址（即主机B的IP地址）。
3. 局域网内的所有设备接收到ARP请求后，检查数据包中的目标IP地址。如果设备的IP地址与目标IP地址匹配，那么这个设备就是主机B。
4. 主机B回复一个ARP响应数据包，包含其IP地址和MAC地址。这个数据包直接发送给主机A。
5. 主机A接收到ARP响应后，将主机B的IP地址和MAC地址的映射关系存储在ARP缓存表中。这样，在一段时间内，主机A与主机B再次通信时无需重复进行ARP请求和响应的过程。

在ARP协议的基础上，还有一种名为反向地址解析协议（RARP）的协议，其主要用途是帮助无盘工作站在启动时获取IP地址。然而，随着DHCP（动态主机配置协议）的普及，RARP已逐渐被淘汰。

ARP（Address Resolution Protocol，地址解析协议）是一个在局域网（如以太网）内用于将网络层（IP）地址映射到数据链路层（如 MAC）地址的协议。简单来说，ARP协议是用于在同一个局域网内找到目标设备物理地址的协议。这个过程对于设备之间的通信是非常重要的。

当一个设备（如计算机）试图与同一个局域网内的另一个设备（如路由器）通信时，发送设备需要知道目标设备的物理地址（MAC地址）。然而，通常情况下，发送设备只知道目标设备的 IP 地址。这时，发送设备会使用 ARP 协议来获取目标设备的 MAC 地址。

ARP 协议的工作过程分为以下几个步骤：

1.发送设备首先检查其 ARP 缓存，看看它是否已经知道目标 IP 地址对应的 MAC 地址。ARP 缓存是一种临时存储已知 IP 地址和 MAC 地址映射的表。

2.如果发送设备在 ARP 缓存中找不到目标设备的 MAC 地址，它将生成一个 ARP 请求数据包。这个数据包包含发送设备的 IP 和 MAC 地址，以及目标设备的 IP 地址。请注意，ARP 请求数据包中的目标 MAC 地址字段将被设置为全零，表示未知。

3.发送设备将 ARP 请求数据包广播到局域网上的所有设备。广播意味着这个数据包将被局域网内的所有设备接收。

4.当目标设备收到这个 ARP 请求时，它会检查数据包中的目标 IP 地址，看看是否与自己的 IP 地址匹配。如果匹配，目标设备就知道这个 ARP 请求是为了寻找自己的 MAC 地址。

5.目标设备会生成一个 ARP 响应数据包，其中包含自己的 IP 和 MAC 地址。然后，它将这个响应数据包发送回发送设备。

6.发送设备收到 ARP 响应后，会更新其 ARP 缓存，添加目标设备的 IP 地址和 MAC 地址映射。接下来，发送设备可以使用这个映射来与目标设备进行通信。

总的来说，ARP 协议是一种在局域网内解析 IP 地址到 MAC 地址的过程。通过 ARP 请求和响应数据包的交换，设备之间可以找到彼此的物理地址，从而实现网络通信。

### 	RARP

RARP（Reverse Address Resolution Protocol，反向地址解析协议）是一种网络协议，用于帮助无盘工作站（即没有硬盘存储的设备）在启动时获取IP地址。RARP的工作原理与ARP相反，它是根据设备的物理地址（如MAC地址）查找对应的IP地址。

RARP的工作过程如下：

1. 无盘工作站启动时，因为没有存储设备，所以需要通过网络从其他设备（如服务器）获取启动信息。但是，无盘工作站需要一个IP地址才能与其他设备通信。
2. 无盘工作站发送一个RARP请求数据包，包含自己的物理地址（如MAC地址）。这个请求会广播到局域网内的所有设备。
3. 局域网内设有一个专门的RARP服务器，用于存储IP地址和物理地址的映射关系。当RARP服务器接收到无盘工作站的请求时，根据请求中的物理地址在映射表中查找对应的IP地址。
4. 如果RARP服务器找到了匹配的IP地址，它会将这个IP地址包含在一个RARP响应数据包中，并发送给无盘工作站。
5. 无盘工作站接收到RARP响应后，获得了分配给自己的IP地址。接下来，无盘工作站可以使用这个IP地址与网络中的其他设备通信，从而获取所需的启动信息。

尽管RARP协议在某些场景下可以帮助无盘工作站获取IP地址，但它存在一些局限性，例如需要手动维护IP地址和物理地址的映射表。因此，随着更先进的协议（如DHCP，动态主机配置协议）的出现，RARP已经逐渐被淘汰。DHCP协议可以动态地分配IP地址，并为设备提供其他网络配置信息，因此在现代网络环境中更为实用。

RARP（Reverse Address Resolution Protocol，逆地址解析协议）是一种网络协议，它用于将数据链路层（如 MAC）地址映射到网络层（如 IP）地址。RARP 的工作原理与 ARP（Address Resolution Protocol，地址解析协议）正好相反。正如我们之前讨论的，ARP 用于将 IP 地址映射到 MAC 地址，而 RARP 则是将 MAC 地址映射到 IP 地址。

RARP 主要用于无盘工作站，即那些没有本地存储设备（如硬盘）来存储其 IP 地址的设备。这些设备在启动时需要从网络中获取其 IP 地址。RARP 的工作过程如下：

无盘工作站在启动时发送一个 RARP 请求数据包，其中包含其 MAC 地址。请注意，由于无盘工作站不知道其 IP 地址，因此 RARP 请求中的源 IP 地址字段通常为 0.0.0.0。

RARP 服务器（通常是局域网内的一台计算机，负责为无盘工作站分配 IP 地址）收到 RARP 请求后，会查找一个表，该表包含 MAC 地址与 IP 地址之间的映射关系。

如果 RARP 服务器找到了与请求中 MAC 地址对应的 IP 地址，它会将 IP 地址放入 RARP 响应数据包中，并将其发送回无盘工作站。

无盘工作站收到 RARP 响应后，会提取其中的 IP 地址并将其分配给自己，从而实现网络通信。

尽管 RARP 在某些场景下是有用的，但它的功能有限，因为它只能在局域网内工作，而且需要专门的 RARP 服务器。现代网络环境中，RARP 已经被更灵活、功能更强大的协议所取代，如 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）。DHCP 不仅能够为设备分配 IP 地址，还可以提供其他网络配置信息，如子网掩码、默认网关和 DNS 服务器等。

### TTL

TTL（Time to Live，生存时间）是网络通信中的一个重要概念，主要应用于数据包在网络中的传输。TTL是一个数值，表示数据包在网络中允许经过的最大路由器跳数（hops）。每经过一个路由器，数据包的TTL值会减1。当TTL值减至0时，数据包将被丢弃，不再继续传输。

TTL的主要目的是防止数据包在网络中无限循环，造成网络拥塞。设定一个合适的TTL值，可以确保数据包在一定时间或跳数内到达目的地或被丢弃，避免因网络问题导致的无限传输。

TTL在不同协议中可能有不同的表现形式。例如，在IPv4中，TTL是一个8位字段；而在IPv6中，与TTL功能相同的字段被称为“跳限制”（Hop Limit）

TTL值（Time to Live）可以根据不同的操作系统、设备或应用场景进行设置。TTL值128和64是两个常见的TTL初始值。

TTL值128：通常用于微软Windows操作系统中的数据包。当数据包从Windows设备发送时，TTL初始值为128。

TTL值64：通常用于Linux和Unix系统、macOS以及一些网络设备中的数据包。当数据包从这些设备或系统发送时，TTL初始值为64。

### ICMP

ICMP（Internet Control Message Protocol，互联网控制报文协议）是一种网络层协议，主要用于网络设备（如路由器、主机等）之间传递控制信息和网络通信状况信息。ICMP常用于诊断网络问题和传递错误报告。

常见的ICMP消息类型包括：

回显请求与回显应答（Echo Request & Echo Reply）：用于测试网络连通性，例如“ping”命令。发送方发送回显请求，接收方返回回显应答。

目的不可达（Destination Unreachable）：当数据包无法到达目标主机时，路由器或主机会发送目的不可达消息给发送方。

超时（Time Exceeded）：当数据包在网络中传输的时间超过了其生存时间（TTL），路由器会丢弃数据包并发送超时消息给发送方。

重定向（Redirect）：当路由器发现有更好的路由路径可用时，会发送重定向消息通知发送方更新路由信息。

ICMP协议是一个辅助性协议，用于提供网络通信中的控制和反馈信息，帮助网络管理员诊断和解决网络问题。

### OSI

OSI七层模型是指开放式系统互连参考模型

物理层-数据链路层-网络层-传输层-会话层-表示层-应用层

OSI（开放式系统互联）七层模型是一个网络通信的理论框架，用于描述计算机网络中不同层次的功能。这里是各层的简要解释：

物理层（Physical Layer）：负责在网络设备之间传输比特流（0和1）。这一层涉及物理硬件，如电缆、集线器和信号的传输。

数据链路层（Data Link Layer）：处理从一个设备到另一个设备的可靠传输。它将比特流分成数据帧，并处理错误检测和流量控制。这一层的主要功能包括MAC地址（用于设备识别）和网络设备之间的通信。

网络层（Network Layer）：负责在发送端和接收端之间建立数据包的路由和寻址。它确定数据包在网络中的传输路径。这一层的主要功能包括IP地址分配和路由协议（如OSPF、BGP等）。

传输层（Transport Layer）：负责在两个设备之间建立可靠的端到端通信。它处理错误恢复、数据重组和流量控制。这一层的主要协议有TCP（传输控制协议）和UDP（用户数据报协议），它们分别提供可靠和不可靠的通信服务。

会话层（Session Layer）：负责在设备间建立、维护和断开会话。它提供双向通信的管理，如同步和超时等。

表示层（Presentation Layer）：处理数据的格式和编码，确保发送方和接收方都能理解数据。它负责将应用层数据转换为网络可传输的格式，如数据压缩、加密和字符集转换等。

应用层（Application Layer）：为用户提供最终的应用服务，如Web浏览器、电子邮件客户端和文件传输等。这一层的主要协议有HTTP、SMTP、FTP等

简而言之，OSI七层模型从物理硬件到最终的应用程序服务，逐层描述了网络通信的各个方面。这个模型有助于理解网络的工作原理以及各层之间的关系。

### Gratuitous ARP

Gratuitous ARP（无请求 ARP）是一种特殊的 ARP 消息，用于实现网络中的某些功能，而不是寻找目标设备的 MAC 地址。Gratuitous ARP 的主要用途如下：

1.IP 地址冲突检测：设备可以发送 Gratuitous ARP 请求来检查网络中是否有其他设备使用相同的 IP 地址。这种情况下，Gratuitous ARP 请求的源 IP 和目标 IP 地址相同（都是发送设备的 IP 地址），源 MAC 地址是发送设备的 MAC 地址。如果存在 IP 地址冲突，收到这个请求的设备可能会发出警告。

2.更新 ARP 缓存：设备可以发送 Gratuitous ARP 请求或响应来通知网络中的其他设备更新其 ARP 缓存。这对于设备重新启动或网络接口发生变化的情况很有用。在这种情况下，收到 Gratuitous ARP 消息的设备会使用消息中的 IP 和 MAC 地址映射来更新其 ARP 缓存。

3.负载均衡和故障转移：在使用虚拟 IP 地址的负载均衡器或配置了故障转移的设备中，Gratuitous ARP 可以帮助实现快速切换。当主设备出现故障时，备用设备可以发送 Gratuitous ARP 消息，通知网络中的其他设备更新其 ARP 缓存，从而实现平滑的故障转移

简单来说，Gratuitous ARP 是一种特殊类型的 ARP，主要用于 IP 地址冲突检测、更新 ARP 缓存和实现负载均衡及故障转移等功能。与普通 ARP 的工作原理不同，Gratuitous ARP 的目的并不是寻找目标设备的 MAC 地址。

### UDP

UDP（User Datagram Protocol）是一种无连接的协议，用于在计算机网络上发送数据报。它是一种轻量级的传输协议，不会像TCP一样提供可靠的数据传输和错误恢复功能。

UDP和TCP之间的主要区别在于以下几个方面：

连接方式：UDP是无连接的，而TCP是面向连接的。TCP需要在发送数据之前先建立连接，而UDP不需要。

可靠性：TCP提供了可靠的数据传输和错误恢复功能，因为它在传输数据之前会建立连接，并使用确认和重传机制来确保数据的可靠性。而UDP不提供这些功能，因此数据传输过程中可能会丢失或出错，但是UDP传输数据的速度比TCP快。

流控制：TCP提供了流量控制功能，可以根据接收方的处理能力来调整数据发送的速度，以避免数据包的丢失和拥塞。而UDP没有流量控制功能，数据发送速度由发送方自行控制。

数据包大小：TCP对数据包大小有限制，最大为64KB，而UDP没有这个限制。

使用场景：UDP通常用于实时性要求较高的应用程序，例如音频和视频传输、在线游戏等。而TCP则用于要求可靠性较高的应用程序，例如文件传输、电子邮件等。

总之，UDP比TCP更简单、更快速，但是牺牲了可靠性和流量控制等方面的功能。因此，在选择使用UDP还是TCP时，需要根据应用程序的需求来决定

### SSDP

SSDP（Simple Service Discovery Protocol，简单服务发现协议）是一种网络协议，它允许设备在本地网络中发现其他设备和服务。SSDP 是 UPnP（Universal Plug and Play，通用即插即用）架构的一部分，UPnP 旨在实现设备间的无缝连接与互操作。

SSDP 主要用于在局域网内发现和公告设备和服务。它使用 HTTPU（HTTP over UDP，基于 UDP 的 HTTP）协议进行通信，基于多播地址和端口进行设备发现。通常情况下，SSDP 使用 IPv4 多播地址 239.255.255.250 和端口号 1900，或者 IPv6 多播地址 ff02::c 和端口号 1900。

SSDP 的工作过程如下：

设备加入网络时，它会发送一个 SSDP M-SEARCH 消息，该消息是一个多播请求，用于寻找其他设备和服务。M-SEARCH 请求包含搜索范围和搜索目标等信息。

收到 M-SEARCH 请求的设备会根据请求中的搜索目标判断是否需要响应。如果满足搜索目标，设备会回复一个 SSDP 响应，其中包含设备描述、服务列表等信息。设备描述通常包含在设备描述 XML 文档中，可以通过设备提供的 URL 获取。

客户端设备收到 SSDP 响应后，可以解析设备描述文档，发现设备的详细信息、功能和服务。这些信息可以用于设备之间的互操作，如媒体共享、远程控制等。

设备在离开网络或停止提供服务时，可以发送一个 SSDP 通知，告知其他设备它已不再可用。

总之，SSDP 是一种服务发现协议，用于在局域网内发现和公告设备和服务。它是 UPnP 架构的一部分，旨在实现设备间的自动发现和互操作。

### IPV4、IPV6

IPv4（Internet Protocol version 4）和 IPv6（Internet Protocol version 6）都是互联网协议（IP）的版本，用于在计算机网络中为设备分配地址并实现数据传输。尽管它们具有相似的目的，但在设计和功能上有一些重要区别：

地址空间：IPv4 使用 32 位地址，意味着它最多支持约 43 亿个唯一 IP 地址。而 IPv6 使用 128 位地址，可以提供大约 3.4 x 10^38 个唯一地址。随着互联网设备的数量不断增长，IPv4 地址已经逐渐耗尽。IPv6 提供了几乎无限的地址空间，解决了地址耗尽的问题。

地址表示：IPv4 地址通常表示为四个十进制数字，用点分隔，如 “192.168.1.1”。IPv6 地址表示为八组四位十六进制数字，用冒号分隔，如 “2001:0db8:85a3:0000:0000:8a2e:0370:7334”。

地址分配：IPv6 支持更灵活的地址分配策略。IPv6 引入了地址分层和聚类，有助于简化路由和提高路由效率。此外，IPv6 支持自动配置，设备可以在没有 DHCP 服务器的情况下自动分配 IP 地址。

安全性：IPv6 在设计时考虑了安全性，它支持 IPsec（IP Security），这是一个用于在 IP 层加密和认证通信的协议。虽然 IPv4 也可以使用 IPsec，但在 IPv6 中，IPsec 是强制实施的标准组成部分。

性能和简化：IPv6 包含了一些改进，以提高性能和简化网络配置。例如，IPv6 支持更大的报文，减少了分片的需求；IPv6 的报头结构更简单，有助于提高路由器的处理速度。

多播和任播：IPv6 改进了多播功能，并引入了新的任播地址。多播允许将数据包发送到多个目标，而任播则是将数据包发送到任何一个目标。IPv6 放弃了 IPv4 中的广播功能，转而使用多播地址实现类似功能。

总之，IPv4 和 IPv6 的主要区别在于地址空间、地址表示、地址分配、安全性、性能和多播功能等方面。IPv6 为解决 IPv4 地址耗尽问题和提高互联网性能提供了基础。然而，尽管 IPv6 已经存在了很长时间，IPv4 仍然广泛使用，原因包括：

转换成本：升级到 IPv6 需要投入时间和资金。网络设备、操作系统、应用程序和安全策略可能需要相应的更新以支持 IPv6。这可能会导致短期内的高昂成本，尤其是对于大型组织和服务提供商。

兼容性问题：IPv4 和 IPv6 之间存在兼容性问题，它们不能直接互通。为了实现这两种协议之间的通信，需要使用转换技术，如隧道、转换代理或双栈实现。这增加了网络的复杂性和管理成本。

缺乏驱动因素：尽管 IPv6 解决了地址耗尽问题并提供了一些改进，但许多组织并未感受到迫切的需求来升级。例如，网络地址转换（NAT）技术允许多个设备共享一个 IPv4 地址，缓解了地址耗尽的问题。此外，一些组织可能认为 IPv4 仍然能满足他们的需求，没有必要升级到 IPv6。

缺乏经验和培训：许多网络管理员和技术人员对 IPv4 更熟悉，可能缺乏 IPv6 的经验和培训。这可能导致组织在部署和维护 IPv6 网络时面临挑战。

惯性和延迟：尽管 IPv6 的推广和采用在逐渐增加，但许多组织仍在使用 IPv4，部分原因是惯性和延迟。人们可能会继续使用他们熟悉的技术，直到有明确的理由或需求来进行改变。

尽管存在这些挑战，IPv6 的全球采用率仍在逐年上升。随着互联网设备数量的持续增长以及 IPv6 所带来的好处，我们可以预期未来 IPv6 将在更多网络环境中取得主导地位。

### STP

STP（Spanning Tree Protocol，生成树协议）是一种网络协议，用于在以太网交换机环境中防止环路（loop）产生，从而确保网络的稳定性和可靠性。STP 最初由 Dr. Radia Perlman 在 1985 年提出，定义在 IEEE 802.1D 标准中。

在交换机网络中，为了提高冗余和可靠性，通常会使用多条物理路径连接网络设备。然而，这可能导致环路的产生。环路会引发广播风暴、多播风暴和单播风暴等问题，影响网络性能甚至导致网络崩溃。

STP 的主要目标是在保持网络冗余的同时避免环路。它通过以下方式实现这一目标：

选举根桥（Root Bridge）：STP 通过比较交换机的桥标识符（Bridge ID）来选举一个根桥。桥标识符由优先级和 MAC 地址组成。优先级较低的交换机将被选为根桥。

选举根端口（Root Port）：每个非根桥交换机都有一个根端口，该端口是到根桥的最短路径（根据路径成本）。路径成本取决于链路带宽。

选举指定端口（Designated Port）：在网络中的每个链路上，有一个交换机的端口被选为指定端口。指定端口负责将数据帧从链路发送到该链路的其他交换机。

状态切换：STP 根据以上选举结果，将端口置于不同的状态。有四种状态：禁用（Disabled）、阻塞（Blocking）、监听（Listening）和转发（Forwarding）。只有转发状态的端口才能转发数据帧。

通过这些步骤，STP 在网络中创建了一个无环的生成树结构，实现了环路的防止。需要注意的是，原始的 STP 有一定的局限性，例如收敛速度较慢。后续的改进协议，如 RSTP（Rapid Spanning Tree Protocol，快速生成树协议，IEEE 802.1w）和 MSTP（Multiple Spanning Tree Protocol，多生成树协议，IEEE 802.1s），在保持基本功能的同时，提高了收敛速度和灵活性。

### SYN

SYN（Synchronize）是 TCP（Transmission Control Protocol，传输控制协议）连接建立过程中使用的一个标志位。TCP 是一种面向连接的、可靠的数据传输协议。在 TCP 传输中，建立连接前需要进行一个称为 "三次握手"（Three-way Handshake）的过程。SYN 是这个过程的关键部分。

三次握手的步骤如下：

客户端向服务器发送一个 TCP 数据包，其中 SYN 标志位设置为 1。这表示客户端请求建立连接。同时，客户端会设置一个初始序列号（ISN）。

服务器收到 SYN 数据包后，如果同意建立连接，会回复一个 TCP 数据包，其中 SYN 标志位和 ACK（Acknowledge，确认）标志位都设置为 1。服务器也会设置自己的初始序列号。

客户端收到服务器的回复后，会发送一个 TCP 数据包，其中 ACK 标志位设置为 1，以确认收到服务器的 SYN-ACK 数据包。此时，TCP 连接建立完成，可以开始数据传输。

在 nmap 中，SYN 扫描（-sS）是一种较快且不易被检测到的端口扫描方法。SYN 扫描的原理是发送一个 SYN 数据包到目标主机的指定端口，然后根据主机的响应判断该端口的状态。如果收到一个 SYN-ACK 数据包，说明端口处于开放状态；如果收到一个 RST（Reset，重置）数据包，说明端口处于关闭状态。SYN 扫描不会完成完整的 TCP 三次握手过程，因此它被称为 "半开放"（Half-open）扫描

### RST

RST（Reset）是 TCP（Transmission Control Protocol，传输控制协议）中的一个标志位。RST 用于表示连接出现错误或异常，需要立即终止（重置）当前连接。在 TCP 数据包中，如果 RST 标志位被设置为 1，说明接收方拒绝了该连接或指示发送方终止连接。

RST 在以下场景中可能会被使用：

当一个 TCP 连接的一端接收到一个不符合期望的数据包时，如序列号不匹配的数据包，它可能会回复一个 RST 数据包，以通知对端关闭连接。

如果服务器接收到一个 SYN 数据包，但目标端口处于关闭状态，服务器可能会回复一个 RST 数据包，以告知客户端端口不可用。

在 nmap 端口扫描中，RST 数据包的响应通常表示目标端口处于关闭状态。例如，在 SYN 扫描（-sS）中，nmap 会发送一个 SYN 数据包到目标主机的指定端口。如果收到一个 RST 数据包，说明端口处于关闭状态。这种情况下，nmap 不会完成 TCP 三次握手过程，而是根据收到的 RST 数据包判断端口状态

### OSPF

OSPF（Open Shortest Path First，开放最短路径优先）是一种内部网关协议（IGP），用于在自治系统（AS）内的路由器之间实现动态路由。OSPF 是一种基于链路状态的路由协议，它利用 Dijkstra 算法计算网络中的最短路径。与距离向量路由协议相比，OSPF 提供了更快速的收敛、更低的网络开销以及更强的安全性。

OSPF 的主要特点如下：

分层结构：OSPF 网络可以划分为不同的区域（Area），以降低网络开销和路由计算复杂度。在 OSPF 中，有一个特殊的区域叫 Backbone Area（通常为 Area 0），负责连接其他区域并维护网络的稳定性。

链路状态广播：OSPF 使用链路状态广播（Link State Advertisement，LSA）来描述路由器及其连接的链路状态。路由器会定期发送 LSA 以通知其他路由器自身的链路状态。

快速收敛：当网络拓扑发生变化时，OSPF 能够迅速重新计算最短路径并更新路由表。这使得 OSPF 网络能够更好地适应动态环境。

无类别域间路由选择（CIDR）支持：OSPF 支持无类别域间路由选择，允许对 IP 地址进行子网划分和聚合。这有助于降低路由表规模和网络开销。

认证和安全性：OSPF 支持多种认证方法，如明文密码和 MD5，以确保路由信息的安全性。

在现代网络中，OSPF 是最常用的内部网关协议之一，与其他 IGP（如 RIP 和 EIGRP）相比，OSPF 提供了更高的性能、可扩展性和安全性。

### CIDR

CIDR（无类别域间路由选择，Classless Inter-Domain Routing）是一种用于 IP 地址分配和路由的方法。CIDR 于 1993 年引入，旨在解决 IPv4 地址耗尽和路由表规模增长的问题。CIDR 取代了早期的基于类（Classful）的 IP 地址分配方法，如 A 类、B 类和 C 类地址。

CIDR 的核心概念是将 IP 地址和子网掩码结合在一起，以表示一个 IP 地址范围。CIDR 表示法使用斜线（/）后跟一个数字（例如，192.168.0.0/24），其中数字表示网络前缀的位数。网络前缀是 IP 地址中的连续网络位，用于区分网络和主机部分。

以下是 CIDR 的一些主要特点：

可变长度子网掩码（VLSM）：CIDR 允许使用可变长度子网掩码，从而使 IP 地址分配更加灵活。这可以减少 IP 地址的浪费，提高地址利用率。

路由聚合：CIDR 支持路由聚合，也称为路由汇总。这种方法允许多个相邻的 IP 地址段通过一个单一的路由表项进行表示。路由聚合有助于降低路由表的规模，提高路由性能

更简洁的路由表：CIDR 通过允许可变长度子网掩码和支持路由聚合，降低了路由表的规模。这有助于提高路由器的性能，降低网络开销。

CIDR 的引入使得 IP 地址分配和路由变得更加高效和灵活。现代的 IP 网络（IPv4 和 IPv6）都采用 CIDR 方法进行地址分配和路由。

CIDR（无类别域间路由，Classless Inter-Domain Routing）是一种用于表示IPv4和IPv6地址和子网掩码的简洁表示法。CIDR是在20世纪90年代引入的，目的是为了提高IP地址分配的效率并减轻路由表的负担。CIDR取代了早期基于类（A、B、C类）的IP地址分配方式，提供了更灵活的子网划分。

CIDR表示法的形式为：IP地址/前缀长度。

例如，一个IPv4地址的CIDR表示法为：192.168.1.0/24。这里，192.168.1.0是IP地址，24是前缀长度，表示网络前缀占用了32位IPv4地址中的前24位。剩余的8位用于主机地址，可以在子网中容纳2^8-2 = 254台设备（减2是因为需要排除全0（网络地址）和全1（广播地址）的情况）。

CIDR的优势在于它可以更灵活地分配IP地址。在基于类的IP地址分配方法中，A类、B类和C类地址的网络和主机部分是固定的。使用CIDR，可以根据实际需求灵活地划分子网，从而更高效地利用IP地址空间。

CIDR还有助于减轻路由器的负担，因为它允许路由表中的多个相邻子网聚合为一个更大的地址范围。这称为路由聚合或路由汇总，它可以减少全球互联网上路由器所需的路由表项数量

使用按位与运算来计算网络地址，然后根据子网掩码中的主机位数来确定子网内的地址范围。这使得我们能够轻松地识别属于同一子网的所有IP地址。

IP地址：  192.168.1.5   (11000000.10101000.00000001.00000101)

子网掩码： 255.255.255.0  (11111111.11111111.11111111.00000000)

11000000.10101000.00000001.00000101

11111111.11111111.11111111.00000000

\-----------------------------------

11000000.10101000.00000001.00000000

结果是11000000.10101000.00000001.00000000，即192.168.1.0，这就是网络地址。有0一定为0，全为1才是1

按位与（AND）运算在计算网络地址时的使用是为了根据给定的IP地址和子网掩码找到属于同一子网的所有IP地址的共同前缀。按位与运算有一个很重要的特性：如果在两个二进制数中，相应的位都是1，那么结果中的该位为1；否则，结果中的该位为0。

子网掩码的作用是指示IPv4地址中哪些位属于网络部分，哪些位属于主机部分。子网掩码的二进制表示中，网络部分的所有位都是1，主机部分的所有位都是0。

当我们对一个IP地址和子网掩码进行按位与运算时，由于子网掩码的主机部分都是0，所以按位与运算的结果会保留IP地址的网络部分，而将主机部分设置为0。这样，我们就得到了IP地址所在子网的网络地址。网络地址是子网中的第一个地址，用于唯一标识一个子网。

给定的CIDR表示法是203.101.123.163/28，其中203.101.123.163是一个IPv4地址，28是前缀长度。我们将逐个计算子网掩码、最大IP和最小IP。

子网掩码：前缀长度为28位，表示子网掩码的前28位为1，剩余4位为0。因此，子网掩码为255.255.255.240。

ip地址个数：2^4-2=14,说明有14个ip地址

最小IP（网络地址）：将IP地址的前28位与子网掩码进行按位与（AND）运算，可以得到网络地址。所以，203.101.123.163和255.255.255.240的按位与运算结果是203.101.123.160。这是子网中的最小IP地址（网络地址）。

最大IP（广播地址）：将网络地址的剩余位（主机部分）全部置为1，可以得到广播地址。所以，将203.101.123.160的后4位设置为1，得到203.101.123.175。这是子网中的最大IP地址（广播地址）。

在给定的CIDR表示法203.101.123.163/28中，163是一个具体的IPv4地址。在子网范围内（从203.101.123.161到203.101.123.174），它表示子网内的一个特定设备或主机。注意，我们没有包括网络地址（203.101.123.160）和广播地址（203.101.123.175），因为它们在子网中具有特殊用途，不能分配给主机。

### RIP

RIP（Routing Information Protocol，路由信息协议）是一种动态路由协议，用于在自治系统（AS）内部的路由器之间交换路由信息。RIP 是基于距离向量算法的路由协议，其度量标准是跳数（hop count），用于确定到达目的网络的最佳路径。RIP 的最大跳数限制为 15，超过 15 跳的网络将被认为是不可达。

RIP 有两个版本：RIPv1 和 RIPv2。

RIPv1：RIPv1 是 RIP 的第一个版本，采用类地址（Classful Addressing）模式，不支持无类别域间路由选择（CIDR）和子网掩码。RIPv1 使用广播发送路由更新，可能导致网络资源浪费。

RIPv2：为了解决 RIPv1 的限制，RIPv2 在 RIPv1 的基础上增加了 CIDR 和子网掩码的支持，同时采用多播方式发送路由更新，以降低网络资源消耗。此外，RIPv2 引入了一种简单的明文认证机制，以提高安全性。

RIP 的主要特点如下：

距离向量路由协议：RIP 使用距离向量算法计算到达目的网络的最佳路径。跳数作为度量标准，路径的跳数越少，路径越优先。

定期更新：RIP 路由器会定期（通常为 30 秒）发送路由更新，以通知其他路由器自身的路由信息。这可能导致网络资源浪费，但有助于网络快速收敛。

触发更新：当网络拓扑发生变化时，RIP 路由器会立即发送触发更新，以便其他路由器及时更新路由表。

最大跳数限制：RIP 的最大跳数限制为 15，超过 15 跳的网络将被认为是不可达。这有助于避免路由环路，但限制了 RIP 网络的规模。

分裂水平（Split Horizon）和中毒逆转（Poison Reverse）：为了防止路由环路，RIP 引入了分裂水平和中毒逆转技术。分裂水平规定路由器不会将从一个接口学到的路由信息通过相同接口发送出去。中毒逆转是在分裂水平基础上的改进，将学到的路由信息的跳数设置为最大值（16）再发送出去，以加速网络收敛。

尽管 RIP 适用于小型网络，但其性能、可扩展性和安全性相对较低。在现代网络中，RIP 通常被其他更先进的动态路由协议所取代，例如 OSPF（开放最短路径优先）和 EIGRP（增强型内部网关路由协议）。

OSPF 和 EIGRP 都提供了更高的性能、可扩展性和安全性，并且更适用于大型和复杂的网络环境。

OSPF：开放最短路径优先（OSPF）是一种基于链路状态（Link-State）算法的内部网关路由协议。OSPF 使用 Dijkstra 算法计算到达目的网络的最佳路径，其度量标准是代价（cost），通常与链路带宽成反比。OSPF 支持更大的网络规模，提供更快速的网络收敛，并允许设计更加灵活的网络拓扑。OSPF 提供了许多高级功能，例如区域划分、多路径等分（ECMP）和对 IPv6 的支持（在 OSPFv3 中）。

EIGRP：增强型内部网关路由协议（EIGRP）是一种由 Cisco 开发的混合路由协议，结合了距离向量和链路状态路由协议的优点。EIGRP 使用一种称为双重（DUAL）的算法计算到达目的网络的最佳路径，其度量标准可以包括带宽、延迟、可靠性和负载等因素。EIGRP 支持更大的网络规模，提供更快速的网络收敛，并允许设计更加灵活的网络拓扑。EIGRP 提供了许多高级功能，例如多路径等分（ECMP）、路由汇总和对 IPv6 的支持。

尽管 RIP 在现代网络中的应用逐渐减少，但学习 RIP 仍然有助于理解动态路由协议的基本概念和工作原理。如果您正在配置或维护一个小型网络，或者正在学习网络技术，了解 RIP 是很有价值的。然而，在实际应用中，您可能会更多地使用 OSPF 或 EIGRP 等先进路由协议。

### 二进制、十六进制

0000 = 0

0001 = 1

0010 = 2

0011 = 3

0100 = 4

0101 = 5

0110 = 6

0111 = 7

1000 = 8

1001 = 9

1010 = 10

1011 = 11

1100 = 12

1101 = 13

1110 = 14

1111 = 15

一个8bit二进制等于两个四位16进制的数，就是四位二进制数合成10进制的那个数就是对应一个十六进制位

11111111=> 1111 1111

​      15  15=15*16+15*16^0=255

### 划分子网

划分子网（子网划分）是将一个 IP 地址范围划分为多个较小的子网络，以提高 IP 地址利用率和管理效率。子网划分通常涉及更改网络掩码（子网掩码）的长度。下面是子网划分的基本步骤：

确定目标：首先，确定子网划分的目标，例如需要划分出多少个子网，每个子网需要容纳多少台主机。

选择子网掩码：根据子网划分的目标，选择一个适当的子网掩码。子网掩码用于区分 IP 地址中的网络部分和主机部分。子网掩码中的“1”表示网络位，而“0”表示主机位。

计算子网：将原始网络掩码与所需的子网掩码进行比较，确定需要添加多少网络位以满足子网划分的要求。将原始网络掩码中的“0”变为“1”，以获得新的子网掩码。

计算子网地址和可用 IP 地址范围：根据新的子网掩码计算每个子网的子网地址和可用 IP 地址范围。子网地址是子网中的第一个 IP 地址，而可用 IP 地址范围是子网中可用于分配给主机的 IP 地址。

下面是一个具体的子网划分示例：

假设您有一个 IP 地址范围：192.168.0.0/24，需要划分为至少 4 个子网，每个子网至少需要容纳 50 台主机。

原始网络掩码为：255.255.255.0（/24）。

每个子网至少需要容纳 50 台主机，因此需要 6 个主机位（2^6 = 64），剩下的位数用于网络部分。新的子网掩码为：255.255.255.192（/26）。

按照新的子网掩码进行子网划分：

子网 1：192.168.0.0/26（子网地址：192.168.0.0，可用 IP 地址范围：192.168.0.1 - 192.168.0.62）

子网 2：192.168.0.64/26（子网地址：192.168.0.64，可用 IP 地址范围：192.168.0.65 - 192.168.0.126）

子网 3：192.168.0.128/26（子网地址：192.168.0.128，可用 IP 地址范围：192.168.0.129 - 192.168.0.190）

子网 4：192.168.0.192/26（子网地址：192.168.0.192，可用 IP 地址范围：192.168.0.193 - 192.168.0.254）

通过将原始的 /24 网络划分为四个 /26 子网，您成功地将 IP 地址范围 192.168.0.0/24 划分成了四个子网，每个子网可以容纳至少 50 台主机。

需要注意的是，每个子网的第一个 IP 地址（子网地址）和最后一个 IP 地址（广播地址）不能分配给主机。例如，在子网 1 中，192.168.0.0 是子网地址，192.168.0.63 是广播地址，它们不能分配给主机。可用 IP 地址范围为 192.168.0.1 到 192.168.0.62。

### ip route del

ip route del 命令用于从 Linux 系统的路由表中删除一条路由规则。在这个命令中，via 是一个选项，用于指定路由的网关地址。换句话说，via 后面应该跟着一个 IP 地址，该地址表示数据包在到达目的地之前必须经过的网关。

例如，如果您想要删除一条将流量从本地主机路由到子网 192.168.2.0/24 的规则，并且该规则的网关地址为 192.168.1.1，您可以使用以下命令：

ip route del 192.168.2.0/24 via 192.168.1.1

这里，192.168.2.0/24 是目标子网，via 192.168.1.1 指定了网关地址。在执行此命令之后，该路由规则将从系统的路由表中删除。
