





## dd

> 在Linux中，`dd`是一个命令行工具，通常用于复制文件、将数据从一个设备复制到另一个设备 、备份和还原磁盘映像等操作。"dd"命令可以对任何块设备金进行操作，例如硬盘、USB驱动器、CD-ROM等。

**格式**：

```css
dd [if=inputfile] [of=outputfile] [bs=blocksize] [count=numblocks]
```

其中：

- `if`： 输入文件，即要复制的源文件或设备；
- `of`：输出文件，即数据写入的目标文件或设备；
- `bs`：块大小，即每次读写的字节数，默认值为512；
- `count`：块数，即要复制的块数。

例如，要将一个名为`sourcefile`的文件复制到名为`destinationfile`的文件中，可以使用以下命令：

```bash
dd if=sourcefile of=destinationfile
```

要将一个设备复制到另一个设备中，可以使用以下命令：

```javascript
dd if=/dev/sda of=/dev/sdb
```

常用选项：

```css
if=file 			从所命名文件读取而不是从标准输入
of=file 		写到所命名的文件而不是到标准输出
ibs=size 		一次读size个byte
obs=size 		一次写size个byte
bs=size 		block size, 指定块大小（既是是ibs也是obs)
cbs=size		一次转化size个byte
skip=blocks 	从开头忽略blocks个ibs大小的块(在if文件中跳过多少bs)
seek=blocks 	从开头忽略blocks个obs大小的块(在of文件中跳过多少bs)
count=n 		复制n个bs
conv=conversion[,conversion...] 用指定的参数转换文件

conversion 	转换参数:
ascii 		转换 EBCDIC 为 ASCII
ebcdic 		转换 ASCII 为 EBCDIC
lcase 		把大写字符转换为小写字符
ucase 		把小写字符转换为大写字符
nocreat 	不创建输出文件
noerror 	出错时不停止
notrunc 	不截短输出文件
sync 		把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐
fdatasync 	写完成前，物理写入输出文件
```

案例1：备份MBR中的分区表

```bash
dd if=/dev/sda of=/data/mbr bs=1 count=64 skip=446
```

## mount、umount

> `mount`和`umount`是Linux操作系统中用于挂载和卸载文件系统的命令。

### 挂载文件系统（mount）

`mount`命令可以将一个文件系统挂载到指定的挂载点上，使得该文件系统中的文件可以被访问和操作。使用`mount`命令需要指定两个参数：文件系统设备和挂载点。

语法：

```css
mount [-t filesystem-type] [-o mount-options] device mount-point
```

- `-t`选项用于指定文件系统类型。如果不指定，Linux会自动检测文件系统类型。
- `-r`readonly,只读挂载
- `-w`read and write，读写挂载，此为默认设备，可以省略
- `-o`选项用于指定挂载选项，例如读写权限、用户权限等。多个选项可以用逗号隔开。
- `device`参数用于指定文件系统的设备路径，可以是设备文件路径，也可以是网络文件系统路径等。
- `mount-point`参数用于指定文件系统挂载的挂载点

例如，以下命令将/dev/sdb1分区以ext4文件系统类型，以读写权限挂载到/mnt目录：

```bash
mount -t ext4 -o rw /dev/sdb1 /mnt
```

### 卸载文件系统（umount）

`umount`命令用于卸载一个已经挂载的文件系统，使得该文件系统中的文件不能被访问和操作。使用`umount`命令只需要指定卸载点即可。

语法:

```css
umount mount-point
```

例如，以下命令将/mnt目录上的文件系统卸载：

```bash
umount /mnt
```

需要注意的是，如果文件系统正在被使用，例如正在运行的程序正在读写该文件系统中的文件，那么使用`umount`命令可能会失败。此时，需要停止所有正在使用该文件系统的进程，或者使用`-l`选项强制卸载文件系统。例如，以下命令强制卸载/mnt目录上的文件系统：

```bash
umount -l /mnt
```

`mount`命令可以通过使用`-o`选项来为文件系统指定一些挂载选项。下面介绍一些常见的`-o`选项：

- `rw`：以可读写模式（默认）挂载文件系统。
- `ro`：以只读模式(read-only)挂载文件系统，文件系统只能被读取，不能被修改。
- `remount`：重新挂载一个已经挂载的文件系统，并更改挂载选项。该选项需要与其他挂载选项一起使用。例如，`mount -o remount,rw /dev/sda1 /mnt`将重新将`/dev/sda1`分区以可读写模式挂载到`/mnt`目录。
- `noexec`：禁止在文件系统上执行任何二进制文件。
- `nodev`：禁止在文件系统上创建设备文件。
- `nosuid`：禁止在文件系统上启用`setuid`和`setgid`权限。
- `noatime`：不更新文件的访问时间戳，可以提高文件系统性能。
- `nodiratime`：不更新目录的访问时间戳，可以提高文件系统性能。
- `sync`：所有的数据写入都会被同步写入存储设备，可以提高数据安全性，但是会影响文件系统性能。
- `async`：数据写入可以被缓存，可以提高文件系统性能，但是会降低数据安全性。
- `defaults`：使用默认的挂载选项，包括可读写模式、访问时间戳更新等.相当于rw, suid, dev, exec, auto, nouser, async。
- `user`：允许普通用户挂载文件系统，否则只有超级用户才能进行挂载

例如，以下命令将以只读模式挂载`/dev/sda1`分区，并禁止在该分区上执行任何二进制文件：

```bash
mount -o ro,noexec /dev/sda1 /mnt
```

需要注意的是，挂载选项可以组合使用，例如`mount -o rw,noatime,nodiratime /dev/sda1 /mnt`将以可读写模式挂载`/dev/sda1`分区，并且不会更新文件和目录的访问时间戳。

- `errors=remount-ro`：当发生错误时，重新挂载文件系统为只读模式。这可以防止对文件系统的进一步损坏，并可以帮助恢复数据。
- `uid`：指定文件系统的所有者用户ID。
- `gid`：指定文件系统的所有者组ID。
- `umask`：指定文件系统的默认权限掩码。
- `offset`：指定分区的偏移量，用于挂载某些不支持LVM或RAID等高级功能的磁盘分区。
- `loop`：将文件作为块设备挂载为文件系统，这通常用于挂载ISO映像文件。

例如，以下命令将以默认的挂载选项，使用`uid`和`gid`选项来指定文件系统的所有者为1001：

```bash
mount -o uid=1001,gid=1001 /dev/sda1 /mnt
```

需要注意的是，`-o`选项可以有多个，以逗号分隔。例如，`mount -o rw,noatime,uid=1001,gid=1001 /dev/sda1 /mnt`将以可读写模式挂载`/dev/sda1`分区，不会更新访问时间戳，并将文件系统的所有者设置为1001用户和组.

### 时间戳

在Linux中，有四种时间戳与文件相关：访问时间（access time，atime）、修改时间（modification time，mtime）、状态改变时间（change time，ctime）和备份时间（backup time）。这些时间戳记录了文件的不同属性和状态，可以用于诊断问题，跟踪文件变更等等。

1. 访问时间（atime）：记录文件上一次被访问的时间戳。当文件被读取或执行时，它的atime会被更新。在一些系统中，每次对文件进行任何操作（包括仅仅打开文件）时，atime都会被更新。atime可以使用`ls -l`或`stat`命令来查看。
2. 修改时间（mtime）：记录文件上一次被修改的时间戳。当文件内容发生改变时，它的mtime会被更新。mtime可以使用`ls -l`或`stat`命令来查看。
3. 状态改变时间（ctime）：记录文件状态发生改变的时间戳。当文件的属性或权限发生变化时，或者文件被创建或删除时，它的ctime会被更新。ctime可以使用`ls -l`或`stat`命令来查看。
4. 备份时间（backup time）：记录文件上一次被备份的时间戳。通常情况下，备份时间是不受文件系统管理的，而是由备份工具记录的。

在Linux中，可以使用`touch`命令来修改文件的时间戳，例如，使用`touch -a`命令可以仅更新文件的atime，使用`touch -m`命令可以仅更新文件的mtime。

相比较于atime，relatime是一种优化选项。在relatime模式下，只有当文件的atime比文件的mtime或ctime要早时，才会更新atime。这样，可以减少系统更新atime的次数，从而减少系统的I/O负载。目前，relatime已成为Linux内核中的默认选项。

## df

在Linux系统中，df命令是一个常用的磁盘空间查看工具，用于显示系统中文件系统的磁盘使用情况统计信息,具体包括文件系统大小、已用空间、可用空间等信息。

语法：

```css
df [选项] [文件系统]
```

其中，选项和文件系统都是可选参数。如果不指定文件系统，则默认显示所有文件系统的磁盘使用情况统计信息。

常用的选项包括：

- `-h`：以易于理解的格式显示磁盘使用情况，如使用GB、MB等单位；
- `-T`：显示文件系统类型；
- `-i`：显示inode使用情况；
- `-x` 文件系统类型：排除指定类型的文件系统。

例如，下面的命令将显示所有文件系统的磁盘使用情况：

```bash
df
```

输出结果包括文件系统名称、挂载点、总大小、已用空间、可用空间、已用空间百分比和文件系统类型等信息。

如果需要以易于理解的格式显示磁盘使用情况，则可以使用-h选项，如下所示：

```bash
df -h
```

该命令会将文件系统大小、已用空间和可用空间等信息以GB、MB等单位显示，更加易于理解。

如果需要显示某个特定文件系统的磁盘使用情况，则可以在命令后指定该文件系统的挂载点，如下所示：

```bash
df /dev/sda1
```

该命令会显示/dev/sda1文件系统的磁盘使用情况。

总的来说，df命令是一个非常有用的工具，可以帮助用户及时了解系统中磁盘空间的使用情况，以便及时处理和清理无用文件，保证系统的正常运行。

## mkfs

在Linux系统中，mkfs命令用于格式化文件系统，即在指定的分区或设备上创建一个新的文件系统。使用mkfs命令可以将一个分区或设备格式化为各种不同的文件系统类型，例如ext2、ext3、ext4、xfs、NTFS等。本文将详细介绍mkfs命令的使用方法和常用选项。

基本语法：

```css
mkfs [选项] 文件系统类型 分区或设备名称
```

常用选项：

- `-t `文件系统类型：指定要创建的文件系统类型；
- `-V`显示详细的调试信息；
- `-c`在创建文件系统前进行检查，以避免坏块的产生；
- `-L` 标签名：为文件系统设置一个标签；
- `-m`保留空间比例：指定文件系统应该保留的空间比例；
- `-n`不要创建文件系统，只输出将要执行的操作。

例如，下面的命令将在/dev/sdb1设备上创建一个ext4文件系统，同时设置文件系统的标签为data：

```bash
mkfs -t ext4 -L data /dev/sdb1
#或者
mkfs.ext4 -L data /dev/sdb1
```

在执行该命令时，mkfs会首先检查设备上是否存在文件系统，如果存在则会提示用户是否覆盖原有的文件系统。

另外，对于一些特定的文件系统类型，mkfs命令还提供了一些额外的选项。例如，对于ext2文件系统，可以使用如下命令创建文件系统：

```css
mkfs.ext2 [选项] 分区或设备名称
```

其中，ext2文件系统的常用选项包括：

- `-b` 块大小：指定文件系统的块大小；
- `-I` inode大小：指定文件系统中inode节点的大小；
- `-N `inode数量：指定文件系统中inode节点的数量；
- `-m` 保留空间比例：指定文件系统应该保留的空间比例；
- `-v`显示详细的输出信息。

总之，mkfs命令是一个非常有用的工具，可以帮助用户在Linux系统中快速创建各种不同类型的文件系统，以便更好地管理和利用系统资源。在使用mkfs命令时，需要注意选择正确的文件系统类型和选项，以避免出现错误和不必要的损失。

要格式化一个分区或设备为xfs文件系统，可以使用如下命令：

```css
mkfs.xfs [选项] 分区或设备名称
```

其中，选项可以根据需要进行设置，常用的选项包括：

- `-d` 数据盘布局选项：用于指定文件系统的数据盘布局参数；
- `-f`强制格式化，不进行任何确认操作；
- `-l` 日志选项：用于指定文件系统的日志参数；
- `-n`数据盘布局名称：用于指定数据盘布局的名称；
- `-L` 文件系统标签：用于指定文件系统的标签。

例如，下面的命令将在/dev/sdc1设备上创建一个新的xfs文件系统，并设置文件系统的标签为data：

```bash
mkfs.xfs -L data /dev/sdc1
```

在执行该命令时，mkfs.xfs会首先检查设备上是否存在文件系统，如果存在则会提示用户是否覆盖原有的文件系统。

需要注意的是，使用mkfs命令格式化文件系统时，会将文件系统上所有的数据和元数据清除，因此在执行该命令前应该备份重要的数据。

## fsck

> 在Linux中，`fsck`是一种用于检查和修复文件系统错误的命令。当文件系统发生错误时，例如因为系统崩溃或硬件损坏导致的数据损坏，fsck可以扫描文件系统，并尝试恢复损坏的数据和元数据，以便恢复文件系统的正常操作。本文将介绍fsck命令的基本语法和常用选项，以及如何使用fsck命令检查和修复文件系统错误。

基本语法：

```css
fsck [选项] 分区或设备名称
```

常用选项：

- `-a`：自动修复文件系统错误；
- `-n`：只检查文件系统，不修复错误；
- `-p`：自动修复文件系统错误，不进行任何提示；
- `-r`：交互式修复文件系统错误；
- `-t` 文件系统类型：指定要检查的文件系统类型；
- `-V`：显示详细的调试信息。

例如，下面的命令将对/dev/sda1分区上的文件系统进行自动修复：

```bash
fsck -a /dev/sda1
```

在执行该命令时，fsck会扫描文件系统，并尝试自动修复发现的错误。

另外，fsck命令还可以指定文件系统类型进行检查和修复。例如，要检查一个ext4文件系统，可以使用如下命令：

```css
fsck.ext4 [选项] 分区或设备名称
```

其中，ext4文件系统的常用选项与fsck命令相同。

需要注意的是，在使用fsck命令检查和修复文件系统时，应该在单用户模式下运行，以避免其他程序对文件系统的干扰。同时，应该备份重要的数据，并确保磁盘空间充足，以便fsck命令可以进行修复操作。如果文件系统发生严重的错误，fsck可能无法修复问题，需要使用其他工具或手动处理数据。

## swap

> 在Linux操作系统中，swap（交换分区）是一种特殊的分区，用于将内存中暂时不使用的数据转移到磁盘上，以释放内存空间，从而避免系统内存不足的情况。当系统内存紧张时，操作系统会将一部分内存中的数据写入swap分区，以释放空间供其他应用程序使用。当应用程序再次需要访问该数据时，操作系统将从swap分区中读取数据并重新加载到内存中。

Linux系统中，我们可以使用以下命令查看系统中swap的使用情况：

```ruby
$ swapon -s
```

该命令会显示当前系统中所有已经启用的swap分区及其使用情况。

可以使用以下命令创建一个swap分区：

```shell
$ sudo mkswap /dev/sdb1
```

该命令将/dev/sdb1设备格式化为swap分区，并将其标记为可用的swap分区。需要注意的是，在创建swap分区之前，必须确保该分区没有被挂载或正在使用。

为了启用新创建的swap分区，我们需要将其添加到/etc/fstab文件中。具体来说，我们需要在/etc/fstab文件中添加如下一行：

```bash
/dev/sdb1   swap   swap   defaults   0   0
```

其中，第一个参数是swap分区的设备名，第二个参数是分区的类型（应该设置为"swap"），第三个参数也是"swap"，第四个参数是挂载选项，第五个参数是dump标志位（通常设置为0），第六个参数是fsck标志位（通常设置为0）。

如果我们需要暂时禁用swap分区，可以使用以下命令：

```shell
$ sudo swapoff /dev/sdb1
```

这将导致系统停止使用/dev/sdb1分区作为swap分区。如果我们需要永久禁用该分区作为swap分区，可以编辑/etc/fstab文件并将该行注释掉或删除。

## parted

> `Parted`是一个用于对硬盘进行分区的命令行工具。它可以创建、删除、调整和移动硬盘分区，并支持多种不同的分区格式。下面是一些Parted命令的示例：

1. 查看硬盘分区情况

使用 parted -l 命令可以查看系统中所有硬盘的分区情况。例如：

```ruby
$ sudo parted -l
```

该命令将列出所有硬盘的分区情况，以及硬盘的大小、文件系统类型等信息。

2. 创建分区

要创建一个新的分区，可以使用mkpart命令。例如，要创建一个大小为10 GB的新分区，可以输入：

```shell
$ sudo parted /dev/sda mkpart primary 0GB 10GB
```

这将在/dev/sda上创建一个新的主分区，其起始位置为0GB，结束位置为10GB。

3. 删除分区

要删除分区，可以使用rm命令。例如，要删除/dev/sda上的第3个分区，可以输入：

```shell
$ sudo parted /dev/sda rm 3
```

这将删除/dev/sda上的第3个分区。

4. 调整分区大小

要调整分区的大小，可以使用resizepart命令。例如，要将/dev/sda上的第1个分区调整为20 GB，可以输入：

```shell
$ sudo parted /dev/sda resizepart 1 20GB
```

这将将/dev/sda上的第1个分区大小调整为20 GB。

5. 移动分区

要移动分区，可以使用move命令。例如，要将/dev/sda上的第2个分区移动到位置50GB处，可以输入：

```bash
$ sudo parted /dev/sda move 2 50GB
```

6. 切换分区单位

默认情况下，Parted命令使用的是MiB（兆字节）作为分区大小的单位。要切换到其他单位，可以使用unit命令。例如，要切换到GB作为单位，可以输入：

```shell
$ sudo parted /dev/sda unit GB
```

7. 查看分区信息

要查看有关某个特定分区的详细信息，可以使用print命令。例如，要查看/dev/sda上的第1个分区的详细信息，可以输入：

```shell
$ sudo parted /dev/sda print 1
```

该命令将显示有关该分区的信息，例如分区的大小、起始位置、文件系统类型等。

8. 格式化分区

要格式化分区以便在其上创建文件系统，可以使用mkfs命令。例如，要在/dev/sda上的第1个分区上创建ext4文件系统，可以输入：

```shell
$ sudo mkfs.ext4 /dev/sda1
```

这将格式化/dev/sda上的第1个分区，并在其上创建一个ext4文件系统。

9. 创建磁盘分区表

在创建分区之前，需要先创建磁盘分区表。常见的磁盘分区表有两种类型：MS-DOS和GPT。可以使用以下命令创建一个GPT分区表

```css
parted /dev/sda mklabel gpt
```

## partprobe

> 在Linux系统中使用磁盘时，有时需要手动分区，或者可能已经添加了一个新的磁盘并希望操作系统知道它已经存在。这时，就可以使用`partprobe`命令通知内核分区表已经被修改。

`partprobe`命令的作用是告诉内核重新读取分区表并更新内存中的信息。可以通过一下两种方式之一来完成：

1. 使用块设备路径作为参数，重新读取设备的分区表。例如：

```
partprobe /dev/sda
```

这将告诉内核重新读取`/dev/sda`上的分区表。

1. 如果不指定参数，则`partprobe`将扫描所有已知的块设备(重新读取所有磁盘的分区表)并更新内存中的信息。例如：

```
partprobe
```

注意：使用`partprobe`命令修改分区表不会立即生效，而是需要重启系统或重新加载相关设备驱动程序以使其生效。但是，使用`partprobe`命令可以帮助避免手动操作分区表所带来的风险。

除了上面常规用途，`partprobe`命令还可以用于一下情况：

1. 更新RAID阵列配置：如果系统中有软件RAID阵列，则在修改分区表后，可以使用`partprobe`命令通知RAID阵列管理器更新配置。
2. 更新LVM逻辑卷：如果使用LVM(逻辑卷管理器)来管理硬盘分区，则修改分区表后需要使用`partprobe`命令通知LVM更新分区信息。
3. 更新iSCSI目标设备：如果使用iSCSI技术将远程存储设备映射到本地系统上，则在添加或删除目标设备后，使用`partprobe`命令来通知系统更新新设备列表。 

注意：并不是所有的Linux发行版都默认安装了`partprobe`命令。如果在你的系统中找不到该命令，可以尝试使用`partx`命令来达到相同的效果。`partx`命令是`partprobe`命令的一种替代方案，它与`partprobe`的用法类似，但其默认情况下会扫描所有已知的设备。

1. 手动指定一个分区的信息

```
sudo partprobe /dev/sda --set-partition=1 --type=0x83 --start=2048 --end=1048575
```

1. 显示分区信息

```
sudo partprobe -s
```

1. 强制重新加载

```
sudo partprobe -d /dev/sda
```

1. 检查特定设备的分区信息并打印到stdout

```
sudo partprobe -s /dev/sda
```

1. 在特定的设备上创建一个新的分区

```
sudo partprobe /dev/sda && sudo fdisk /dev/sda
```

1. 显示`partprobe`命令的版本信息

```
sudo partprobe --version
```

1. 指定一个分区的信息并创建它

```
sudo partprobe /dev/sda --set-partition=1 --typr=0x83 --start=2048 --end=1048575 --create
```

## fdisk

> `gdisk`和`fdisk`都是在Linux系统中管理磁盘分区的命令行工具。`gdisk`工具是专门用于管理`GUID`分区表`(GPT)`的工具，而`fdisk`则是用于管理传统分区表`(MBR)`的工具。

有关`fdisk`的一些理解：

- `fdisk`是Linux中的另一种基于命令行的发分区工具，用于管理`MBR`分区表。
- `fdisk`命令可以用于创建、删除、修改、移动和备份`MBR`分区表，以及添加、删除、修改、移动和备份`MBR`分区。
- `MBR`分区表相比`GPT`分区表可以支持更少的分区和更小的硬盘容量，但它是早期的计算机系统和`BIOS`系统所采用的的分区表格式。
- `fdisk`命令可以通过使用参数和交互式提示来进行操作 。例如，创建一个新的`MBR`分区表的命令是`sudo fdisk /dev/sda`,其中"/dev/sda"是要进行分区的磁盘名称。
- `fdisk`命令还提供了一些其他的功能，例如查看分区表、显示分区信息、更改分区类型、更改分区大小等。

```bash
#选项
fdisk -l：列出所有硬盘的分区信息。
fdisk /dev/sda：打开硬盘sda的分区管理器，可以执行创建、删除、修改分区等操作。
m：列出所有命令及其说明。
p：打印出分区表信息。
n：创建新分区。
d：删除一个分区。
w：保存并退出。
q：不保存并退出。
在使用fdisk时，需要以root权限或sudo权限运行。
```

1. 创建一个新的`MBR`分区表

```
sudo fdisk /dev/sda
o
w
```

1. 显示`MBR`分区表

```
#这个命令将列出您系统中所有可用的磁盘和分区，包括设备名称、起始扇区和结束扇区、类型等信息
sudo fdisk -l /dev/sda
```

1. 向`MBR`分区表中添加一个新的分区(root身份)：

```
sudo fdisk /dev/sda
n
<Enter>
<Enter>
<Enter>
+1G或者100M
w
```

1. 删除MBR分区表中的一个分区：

```
sudo fdisk /dev/sda
d
<Enter>
<分区号>
w
```

1. 改变分区类型

```
sudo fdisk /dev/sda
t
输入要修改的分区编号
L #查看有哪些类型
83 #例如：swap是82
w
```

1. 将磁盘分区的单位改为扇区数

默认情况下，fdisk命令使用磁盘分区的大小作为单位，但是可以使用以下命令将单位改为扇区数：

```
sudo fdisk -u /dev/sda
```

1. 修改分区的起始扇区数

```
sudo fdisk /dev/sda
x #进入专家模式
b
输入要修改的分区的编号，再输入新的起始扇区号(注意必须是2048的倍数)
w
```

1. 备份和恢复分区表

```
sudo sfdisk -d /dev/sda > sda-partition-table.backup
```

其中，“sda”是您要备份分区表的设备名称，将分区表备份到名为“sda-partition-table.backup”的文件中。要将备份文件恢复到设备，请使用以下命令：

```
sudo sfdisk /dev/sda < sda-partition-table.backup
```

1. 查看分区的UUID

```
sudo blkid /dev/sda
```

1. 在新建分区时指定文件系统类型

默认情况下，fdisk命令在新建分区时不会为其指定文件系统类型。要在新建分区时指定文件系统类型，请使用以下命令：

```
sudo fdisk /dev/sda
n
t
7 #这里输入分区里面文件系统对应的代码，可以用L查看，例如：swap对应是82
w
```

## gdisk

> `gdisk`也是Linux系统中一个命令行工具，用于管理硬盘分区。与`fdisk`不同的是，`gdisk`是专门用于管理GPT分区表的工具。

- `gdisk`是一种基于命令行的分区工具，用于在Linux系统中对`GPT`分区表进行操作。

- `gdisk`命令可以用于创建、删除、修改、移动和备份`GPT`分区表，以及添加、删除、修改、移动和备份`GPT`分区。

- `GPT`分区表相比`MBR`分区表可以支持更大的硬盘和更多的分区，它也支持更好的磁盘容错和安全性。

- `gdisk`命令可以通过使用参数和交互式提示来进行操作。例如，创建一个新的`GPT`分区表的命令是`sudo gdisk /dev/sda`，其中`/dev/sda`是要进行分区的磁盘名称。

- `gdisk`命令还提供了一些其他的功能，例如在`GPT`分区表中添加、删除、移动、备份分区等。

  

```css
#选项
gdisk -l：列出所有硬盘的分区信息。
gdisk /dev/sda：打开硬盘sda的分区管理器，可以执行创建、删除、修改分区等操作。
p：打印出分区表信息。
n：创建新分区。
d：删除一个分区。
w：保存并退出。
q：不保存并退出。
与fdisk类似，使用gdisk也需要以root权限或sudo权限运行
```

1. 创建一个新的GPT分区表：

```
sudo gdisk /dev/sda
```

2. 显示GPT分区表：

```
sudo gdisk -l /dev/sda
```

3. 向GPT分区表中添加一个新的分区：

```
sudo gdisk /dev/sda
n
<Enter>
<Enter>
+100M
EF00
w
```

1. 删除GPT分区表中的一个分区：

```
sudo gdisk /dev/sda
d
<Enter>
<分区号>
w
```

## tee

> `tee`命令可以把标准输入中的数据输出到标准输出和文件中，这样就可以在不破坏原有数据的前提下将数据输出到多个地方。

使用tee命令的格式如下：

```
tee [选项] [文件]
或者
command | tee [-a] file1 [file2 ...]
其中，command是一个命令或者一系列命令，用于产生数据。管道符“|”表示将command的标准输出传递给tee命令。-a选项表示在文件中追加数据，而不是覆盖原有数据。file1、file2等是文件名，表示将数据输出到这些文件中。
```

常用选项有：

- -a：追加数据到文件末尾。
- -i：忽略中断信号。

举个例子，你可以这样使用tee命令:

```
echo "hello" | tee output.txt
ls | tree output.txt
```

这条命令会将字符串"hello"输出到标准输出和文件output.txt中。

如果你想追加数据到文件末尾，可以使用-a选项：

```
echo "world" | tee -a output.txt
```

这条命令会将字符串"world"追加到文件output.txt的末尾。

1. 追加数据到文件

```
ps aux | tee -a processes.txt
这个命令将列出当前正在运行的进程并将其输出到processes.txt文件中，如果processes.txt文件已经存在，则会将新数据追加到文件的末尾。
```

1. 多个文件同时输出

```
dmesg | tee errors.txt messages.txt
这个命令将dmesg命令的输出同时输出到errors.txt和messages.txt文件中，可以将多个文件名作为tee命令的参数。
```

## dmesg

> `dmesg`是一个Linux命令，用于打印内核环缓冲区的内容，包括内核启动信息、硬件检测结果、驱动程序加载信息、系统调用和中断的相关信息等。通过执行dmesg命令，可以获取到内核运行期间发生的重要事件和错误信息，有助于诊断系统问题和进行故障排除。

下面是一些常用的dmesg命令选项：

- -h或--help：显示帮助信息。
- -n<level>或--console-level=<level>：设置内核消息的输出级别。
- -s<size>或--buffer-size=<size>：设置内核环缓冲区的大小。
- -t或--ctime：输出的时间戳使用可读性更高的日期时间格式。
- -w或--follow：实时监视内核环缓冲区的输出。

1. 显示内核环缓冲区的全部内容

```
dmesg
```

1. 显示最近的20行内核消息

```
dmesg | tail -n 20
```

1. 搜索包含指定关键字的内核消息

```
dmesg | grep -i "error"
```

1. 显示可读性更高的日期时间格式

```
dmesg -t
```

1. 实时监视内核环缓冲区的输出

```
dmesg -w
```

## tail

> `tail`用于显示文件的末尾若干行内容。通常用于查看日志文件和其他不断增长的文件的内容。tail命令默认输出文件的末尾10行，可以通过选项来指定输出的行数。
>
> 需要注意的是，`head`命令和`tail`命令都可以用来查看文件内容的一部分，它们之间的主要区别在于`head`命令默认显示文件的开头部分，而`tail`命令默认显示文件的末尾部分。

下面是一些常用的tail命令选项：

- -f或--follow：实时跟踪文件的变化，并输出新增的内容。
- -n <行数>或--lines=<行数>：指定要输出的行数。
- -c <字节数>或--bytes=<字节数>：指定要输出的字节数。
- -q或--quiet：不显示文件名头信息。

下面是一些tail命令的示例：

1. 显示文件末尾10行内容：

```
tail /etc/fstab
```

1. 显示文件末尾20行内容：

```
tail -n 20 /etc/httpd/conf/httpd.conf
```

上述命令表示输出文件的末尾20行内容。而如果加上`-n +<number>`的选项，则表示从文件的第`<number>`行开始输出直到文件末尾的所有内容，例如：

```
tail -n +11 /etc/httpd/conf/httpd.conf
```

上述命令表示从文件的第11行开始输出所有的内容。

需要注意的是，`-n +<number>`选项只能用于GNU版本的`tail`命令，不能用于一些较老版本的`tail`命令。在一些较老版本的`tail`命令中，如果要输出从某行开始的内容，可以使用`sed`命令来实现，例如：

```
sed -n '11,$p' /etc/httpd/conf/httpd.conf
```

上述命令表示输出文件的第11行到最后一行的所有内容。其中`-n`选项表示只输出指定的行数，`11,$`表示从第11行到最后一行，`p`表示输出匹配的行

1. 实时跟踪文件的变化：

```
tail -f /var/log/messages
```

1. 不显示文件名头信息：

```
tail -q /etc/fstab /etc/redhat-release
#正常情况下
==> /etc/fstab <==
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=ad19dd45-b7ee-485c-87e6-3c9bb8ec3996 /                       xfs     defaults        0 0
UUID=8fbb4a9c-1506-4c4a-889d-b78163091bb0 /boot                   ext4    defaults        1 2
UUID=933c390a-5904-4b01-aa6a-447c771b7f08 /data                   xfs     defaults        0 0
#UUID=98f53a44-1fb7-4139-85c6-a3c2d1633cd7 none                    swap    defaults        0 0
UUID=430542b8-0e56-4316-8e49-e937b8b682f5 /data/mysql             ext4    defaults        0 0
#UUID=2a9d6777-78de-4af3-9b97-0ba31db1c95c none                    swap    pri=55       0 0
/data/swapfile                                  none                   swap     defaults        0 0

==> /etc/redhat-release <==
CentOS Linux release 8.5.2111.990713

加上-q以后
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=ad19dd45-b7ee-485c-87e6-3c9bb8ec3996 /                       xfs     defaults        0 0
UUID=8fbb4a9c-1506-4c4a-889d-b78163091bb0 /boot                   ext4    defaults        1 2
UUID=933c390a-5904-4b01-aa6a-447c771b7f08 /data                   xfs     defaults        0 0
#UUID=98f53a44-1fb7-4139-85c6-a3c2d1633cd7 none                    swap    defaults        0 0
UUID=430542b8-0e56-4316-8e49-e937b8b682f5 /data/mysql             ext4    defaults        0 0
#UUID=2a9d6777-78de-4af3-9b97-0ba31db1c95c none                    swap    pri=55       0 0
/data/swapfile                                  none                   swap     defaults        0 0
CentOS Linux release 8.5.2111.990713
```

1. 显示文件末尾1000字节内容：

```
tail -c 1000 /etc/fstab
```

## head

> `head`是一个常用的Linux命令，它用于显示文本文件的开头若干行。默认情况下，`head`命令显示文件的前10行。`head`命令的基本语法为：

```
head [OPTION]... [FILE]...
```

其中`OPTION`是一些可选的命令选项，`FILE`是要查看的文件名。

`head`命令常用的选项如下：

- `-n NUM`：指定要显示的行数。例如，`head -n 5 file.txt`表示显示文件`file.txt`的前5行。
- `-q`：不显示文件名。当同时显示多个文件的内容时，使用该选项可以只显示文件内容，不显示文件名。
- `-v`：显示文件名。当同时显示多个文件的内容时，使用该选项可以在每个文件的内容前面显示文件名。
- `-c NUM`：指定要显示的字节数。例如，`head -c 1024 file.txt`表示显示文件`file.txt`的前1024个字节。
- `-z`：将多个文件的内容视为单个文件来处理。如果多个文件的内容是以null字符分隔的，那么使用该选项可以将它们视为一个文件来处理。
- `--help`：显示`head`命令的帮助信息。
- `--version`：显示`head`命令的版本信息。

下面是一些`head`命令的使用示例：

1. 显示文件`file.txt`的前10行：

```
head file.txt
```

1. 显示文件`file.txt`的前20行：

```
head -n 20 file.txt
```

上述命令表示输出文件的开头20行内容。而如果加上`-n -<number>`的选项，则表示从文件的第`<number>`行开始输出直到`<number>`之间的内容，

则表示从文件的开头开始，显示除了最后N行之外的所有行，需要注意的是，如果文件的行数少于指定的负数值，那么`head`命令将会显示整个文件的内容，并且不会报错

例如：

```
head -n -20 file.txt
```

输出开头到20行之前的内容，20行后不输出

1. 显示多个文件的内容，同时不显示文件名：

```
head -q file1.txt file2.txt file3.txt
```

1. 显示多个文件的内容，同时显示文件名：

```
head -v file1.txt file2.txt file3.txt
```

## head和tail的区别

> `head`命令和`tail`命令都支持在`-n`选项后面指定正负数，它们的含义略有不同。

- 对于`head`命令，`-n +N`表示显示文件的第N行及其之后的所有行，而`-n -N`是无效的选项。
- 对于`tail`命令，`-n +N`和`-n N`表示显示文件的第N行及其之后的所有行，而`-n -N`表示显示文件的末尾部分，去除文件末尾的N行。例如，`tail -n -5 file.txt`表示显示`file.txt`文件除了最后5行之外的所有行。

在`head`命令和`tail`命令中，如果不指定`+`或`-`符号，则默认使用`+`符号，表示显示指定行号或字节数后面的内容

## tr

> `tr`是一个用于字符转换和删除的命令。它可以用来对输入的文本进行一些简单的字符操作，如替换、删除、压缩等

以下是`tr`命令的基本语法：

```css
tr [OPTION]... SET1 [SET2]
```

其中，`OPTION`是可选的，用于指定一些选项；`SET1`和`SET2`是必须的，分别表示要进行转换的字符集和转换后的字符集。

以下是`tr`命令的一些常用选项：

- `-c`：用`SET1`中未包含的字符来替换文本中的字符。
- `-d`：删除文本中包含的`SET1`中的字符。
- `-s`：压缩文本中相邻的重复字符，只保留一个。
- `-t`：用`SET2`中的字符来替换`SET1`中的字符。

以下是一些`tr`命令的示例：

1. 将文本中的小写字母转换成大写字母

```css
$ echo "hello, world" | tr '[:lower:]' '[:upper:]'
HELLO, WORLD
```

2. 删除文本中的空格：

```css
$ echo "hello,    world" | tr -d ' '
hello,world
```

3. 压缩文本中的重复字符：(相当于去重)

```css
$ echo "hello, world" | tr -s 'l'
helo, world
```

4. 将文本中的数字替换为`#`：

```css
$ echo "123456" | tr '[:digit:]' '#'
######
```

5. 保留文本中的指定字符：

```css
$ echo "hello, world" | tr -c '[:alpha:]' '\n'
hello
world
```

这个命令使用 `-c` 选项来保留 `SET1` 中的字符，删除其他字符，然后用换行符替换删除的字符。

6. 在文本中插入换行符：

```css
$ echo "hello, world" | tr -s ' ' '\n'
hello,
world
```

这个命令使用 `-s` 选项来压缩相邻的空格，然后用换行符替换每个空格。

7. 将文本中的字符替换为其 ASCII 编码值：

```css
$ echo "hello, world" | tr '[:print:]' '[\000-\177]'
\150\145\154\154\157\054\040\167\157\162\154\144
```

这个命令使用 `[:print:]` 来表示所有可打印字符，然后将这些字符替换为其 ASCII 编码值。

在 `tr` 命令中，`[:lower:]` 是一种字符集合，用于匹配所有小写字母。类似的字符集合还有很多，以下是一些常用的字符集合：

- `[:upper:]`：匹配所有大写字母。
- `[:alpha:]`：匹配所有字母，包括大小写。
- `[:digit:]`：匹配所有数字。
- `[:alnum:]`：匹配所有字母和数字，包括大小写。
- `[:punct:]`：匹配所有标点符号。
- `[:space:]`：匹配所有空白字符，包括空格、制表符和换行符。
- `[:print:]`：匹配所有可打印字符。

在 `tr` 命令中，字符集合用方括号括起来，例如 `[:lower:]` 表示小写字母集合。可以使用这些字符集合来定义 `SET1` 或 `SET2`，从而对文本进行转换。

以下是一些 `tr` 命令示例，演示如何使用字符集合：

1. 将所有小写字母转换为大写字母：

```css
$ echo "hello, world" | tr '[:lower:]' '[:upper:]'
HELLO, WORLD
```

2. 从文本中删除所有标点符号：

```css
$ echo "Hello, World!" | tr -d '[:punct:]'
Hello World
```

这个命令使用 `-d` 选项删除所有匹配到的标点符号。

3. 将文本中的空格转换为换行符：

```css
$ echo "Hello, World" | tr ' ' '\n'
Hello,
World
```

这个命令使用空格作为 SET1，使用换行符作为 SET2。

## stress

> `stress` 是一个用于模拟系统负载的工具。它可以帮助你测试系统在高负载下的稳定性和性能，以及评估系统资源的使用情况。

以下是 `stress` 命令的基本语法：

```css
stress [OPTION]...
```

其中，`OPTION` 是可选的，用于指定一些选项。

以下是一些常用的 `stress` 命令选项：

- `-c N`：指定要创建的 CPU 负载数量。
- `-d N`：指定要创建的磁盘 I/O 负载数量。
- `-m N`：指定要创建的内存负载数量。
- `-i N`：指定要创建的 I/O 负载数量。
- `-t TIME`：指定要运行 `stress` 的时间。
- `-v`：输出详细的运行日志。
- `-q`：不输出运行日志。
- `--cpu N`：指定 CPU 负载占用率，例如 `--cpu 8` 表示将所有 CPU 核心使用率提升至 80%。
- `--io N`：指定 I/O 负载占用率。
- `--vm N`：指定内存负载占用率。

以下是一些 `stress` 命令的示例：

1. 创建 8 个 CPU 负载：

```R
$ stress -c 8
```

这个命令会创建 8 个 CPU 负载，使用所有可用的 CPU 核心。

2. 创建 4 个磁盘 I/O 负载：

```ruby
$ stress -d 4
```

这个命令会创建 4 个磁盘 I/O 负载，使用默认的块大小和文件名。

3. 创建 2 个内存负载：

```css
$ stress -m 2
```

这个命令会创建 2 个内存负载，每个负载使用 50% 的系统内存。

4. 创建 2 个内存负载：

```css
$ stress -i 1
```

这个命令会创建 1 个 I/O 负载，使用默认的块大小和文件名。

5. 创建 4 个 CPU 负载，并限制每个负载使用 50% 的 CPU 核心：

```css
$ stress --cpu 4 --cpu-load 50
```

这个命令会创建 4 个 CPU 负载，并限制每个负载使用 50% 的 CPU 核心。

6. 通过 `--vm` 选项使用虚拟内存模式`stress` 命令可以模拟虚拟内存的使用情况。通过 `--vm` 选项，可以指定要使用的虚拟内存大小和数量。例如，以下命令将在系统上创建一个 1GB 大小的虚拟内存：

```css
$ stress --vm 1 --vm-bytes 1G
```

7. 通过 `--io` 选项使用磁盘 I/O 模式`stress` 命令可以模拟磁盘 I/O 操作，通过 `--io` 选项指定要使用的 I/O 操作数量和类型。例如，以下命令将在系统上创建一个 4KB 大小的随机文件，并进行 10 次读取和写入操作：

```css
$ stress --io 10 --hdd 1 --hdd-bytes 4K
```

8. 通过 `--cpu` 选项使用 CPU 模式`stress` 命令可以模拟 CPU 负载。通过 `--cpu` 选项，可以指定要使用的 CPU 数量和工作线程数量。例如，以下命令将在系统上创建 8 个线程，每个线程使用 50% 的 CPU 资源：

```css
$ stress --cpu 8 --cpu-load 50
```

9. 通过 `--timeout` 选项设置持续时间默认情况下，`stress` 命令会一直运行，直到用户手动停止。但是可以通过 `--timeout` 选项指定运行时间。例如，以下命令将在系统上模拟 1 分钟的 CPU 负载：

```css
$ stress --cpu 8 --cpu-load 50 --timeout 60s

```

10. 当初做swap测试的时候用到一条命令

```css
sudo stress --vm 1 --vm-bytes 8G --timeout 30s
```

其中，`--vm` 参数表示要生成占用内存的进程，`--vm-bytes `参数表示每个进程所占用的内存大小，-`-timeout`参数表示测试的时长。这个命令会在30秒内让系统生成一个占用2GB内存的进程，观察期间内存和交换分区的使用情况即可。

## wc

> `wc` 命令是一个用于计算文件或标准输入中字符数、单词数和行数的 Linux 命令行工具。它通常用于对文本文件进行分析，以便进行文本处理、分析和编辑。下面是 `wc` 命令的常用选项和使用示例：

常用选项

- `-c` 或 `--bytes`：仅计算文件中的字节数。
- `-w` 或 `--words`：仅计算文件中的单词数。
- `-l` 或 `--lines`：仅计算文件中的行数。
- `-m` 或 `--chars`：仅计算文件中的字符数，其中一个多字节字符被计为一个字符。
- `-L` 或 `--max-line-length`：计算文件中最长行的字符数。
- `-help`：显示帮助信息。
- `-version`：显示 `wc` 命令的版本信息

使用示例

1. 计算文件的行数、单词数和字符数：

```css
$ wc filename
```

示例输出：

```css
 14  79 473 filename
```

输出中，第一列是行数、第二列是单词数、第三列是字符数，最后一列是文件名。

2. 统计多个文件的行数、单词数和字符数：

```css
$ wc file1 file2 file3
```

示例输出：

```css
 14  79 473 file1
  9  52 308 file2
 28 177 781 file3
 51 308 1562 total
```

输出中，最后一行是所有文件的总计数。

3. 统计目录下所有文件的行数、单词数和字符数：

```
$ wc -l -w -c *
```

示例输出：

```css
      4       48     1033 file1.txt
      6       44      237 file2.txt
      3       18      135 file3.txt
     13      110     1405 total
```

输出中，第一列是行数、第二列是单词数、第三列是字符数，最后一列是文件名或目录名。

## cut

> `cut` 命令是 Linux 操作系统中的一个文本处理工具，可以用来从文本文件或标准输入中剪切出指定列。常用于处理大型日志文件和数据文件等。下面是 `cut` 命令的常用选项和使用示例：

基本用法

```css
cut [options] filename
```

* `filename`：指定要处理的文件名。

常用选项

- `-d`：指定分隔符，默认为制表符。
- `-f`：指定要提取的列数，可以同时指定多列，列数之间使用逗号分隔。
- `-c`：指定要提取的字符范围，如 `1-4,7` 表示提取第 1 到 4 个字符和第 7 个字符。
- `-n`：取消分割多字节字符。
- `--complement`：输出选定列之外的列。
- `--output-delimiter`：指定输出的分隔符。
- `--help`：显示帮助信息。
- `--version`：显示 `cut` 命令的版本信息。

1. 从文件中提取指定的字符：

```css
$ cut -c 1-5 filename.txt
```

示例输出：

```css
hello
world
```

输出中，`-c 1-5` 表示提取第 1 到第 5 个字符。

2. 从文件中提取指定的字段：

```css
$ cut -f 1,3 -d "," filename.txt
```

示例输出：

```css
apple,red
pear,green
```

输出中，`-f 1,3` 表示提取第 1 到第 3 个字段，`-d ","` 表示字段的分隔符为逗号。

3. 从文件中提取指定的字段：

```css
$ cut -c 1-5 --complement filename.txt
``
```

4. 提取文件的第一列

```css
$ cut -f 1 filename
```

示例输出：

```css
column1
row1_data1
row2_data1
row3_data1
...
```

输出中，只包含文件的第一列。

5. 提取文件的第一列和第三列

```css
$ cut -f 1,3 filename
```

示例输出：

```css
column1   column3
row1_data1 row1_data3
row2_data1 row2_data3
row3_data1 row3_data3
...
```

输出中，只包含文件的第一列和第三列。

6. 提取文件的第二列到第四列

```css
$ cut -f 2-4 filename
```

示例输出：

```css
column2   column3   column4
row1_data2 row1_data3 row1_data4
row2_data2 row2_data3 row2_data4
row3_data2 row3_data3 row3_data4
...
```

输出中，只包含文件的第二列到第四列。

7. 提取文件的第一行

```css
$ head -n 1 filename | cut -f 2-4
```

示例输出：

```css
column2   column3   column4
```

输出中，只包含文件的第一行的第二列到第四列。

8. 以冒号为分隔符提取文件的第二列和第四列

```css
$ cut -d : -f 2,4 filename
```

示例输出：

```css
row1_data2:row1_data4
row2_data2:row2_data4
row3_data2:row3_data4
...
```

9. 以空格为分隔符提取文件的第一列

```css
$ cut -d " " -f 1 filename
```

示例输出:

```css
column1
row1_data1
row2_data1
row3_data1
...
```

10. 取消分割多字节字符，以字节数统计字符数

```css
$ cut -b -f 1 filename
```

使用 `-b` 选项取消分割多字节字符。

11. 输出选定列之外的列

```css
$ cut --complement -f 2 filename
```

使用 `--complement` 选项。

12. 指定输出的分隔符

```css
$ cut -d " " --output-delimiter="," -f 2-4 filename
```

示例输出：

```css
column2,column3,column4
row1_data2,row1_data3,row1_data4
row2_data2,row2_data3,row2_data4
row3_data2,row3_data3,row3_data4
...
```

输出中，输出的分隔符为逗号 `,`，使用 `--output-delimiter` 选项指定。

## sort

> `sort` 命令是 Linux 中常用的文本排序工具，用于对文件中的文本进行排序。`sort` 命令可以按照多种方式进行排序，包括按照字母顺序、数字顺序、空格分隔的列、指定字段等。

下面是 `sort` 命令的基本用法：

```css
sort [options] [input_file]
```

`sort` 命令常用的选项有：

- `-r`：按照逆序排列。
- `-n`：按照数字顺序排列。
- `-k`：按照指定字段进行排序。
- `-t`：指定字段分隔符。
- `-u`：去重，去除重复的行。
- `-c`：检查文件是否已经按照指定的方式排序。

下面是一些示例：

1. 按照字母顺序排序：

```css
$ sort filename
```

2. 按照数字顺序排序：

```css
$ sort -n filename
```

3. 按照指定字段排序：

```css
$ sort -t ":" -k 3 filename
```

表示以冒号为分隔符，按照第 3 个字段排序。

4. 检查文件是否已经按照指定的方式排序：

```css
$ sort -c filename
```

如果文件已经按照指定的方式排序，则不输出任何信息；否则会提示文件未排序。

5. 去除重复的行：

```css
$ sort -u filename
```

6. 按照多个字段排序:

```css
$ sort -t ":" -k 1,2 filename
```

表示以冒号为分隔符，先按照第 1 个字段排序，如果第 1 个字段相同，则按照第 2 个字段排序。

7. 忽略空格和特殊字符：

```css
$ sort -b filename
```

忽略行首的空格字符，并按照字母顺序排序。

8. 按照文件中的随机顺序排序：

```css
$ sort -R filename
```

按照随机顺序排序文件中的文本行。

9. 按照人类可读的格式进行排序：

```css
$ sort -h filename
```

按照人类可读的格式进行排序，例如按照 K、M、G 等单位大小进行排序。

10. 按照本地化规则排序：

```css
$ sort -f filename
```

按照本地化规则进行排序，忽略大小写。

## uniq

> `uniq` 命令是 Linux 中常用的文本去重工具，用于去除文本文件中的重复行。`uniq` 命令只能去除连续出现的重复行，如果文本中出现非连续的重复行，则需要先使用 `sort` 命令进行排序。

下面是 `uniq` 命令的基本用法：

```css
uniq [options] [input_file]
```

`uniq` 命令常用的选项有：

- `-c`：显示每行出现的次数。
- `-d`：只显示重复的行。
- `-u`：只显示不重复的行。

下面是一些示例：

1. 去除重复的行：

```css
$ uniq filename
```

2. 显示每行出现的次数：

```css
$ uniq -c filename
```

3. 只显示重复的行：

```css
$ uniq -d filename
```

4. 只显示不重复的行：

```css
$ uniq -u filename
```

需要注意的是，`uniq` 命令只能去除连续出现的重复行。如果需要去除非连续的重复行，则需要先使用 `sort` 命令进行排序。例如：

```css
$ sort filename | uniq
```

该命令会先将文件中的文本行按照字典序排序，然后再使用 `uniq` 命令去除重复的行。

## paste

> `paste` 命令是 Linux 中常用的文本合并工具，用于将多个文件或文本流的内容合并成一列或一行。`paste` 命令会将多个文件或文本流中的内容按照列或行合并在一起，并以 TAB 或指定的分隔符分隔各列或各行的内容。

下面是 `paste` 命令的基本用法：

```css
paste [options] file1 file2 ...
```

`paste` 命令常用的选项有：

- `-d`：指定列或行之间的分隔符。
- `-s`：将多行合并成一行。
- `-z`：使用 NULL 作为分隔符。

下面是一些示例：

1. 将两个文件的内容合并成一列：

```css
$ paste file1 file2
```

2. 将两个文件的内容合并成一行：

```css
$ paste -s file1 file2
```

3. 指定列或行之间的分隔符：

```css
$ paste -d "," file1 file2
```

该命令会使用逗号作为列或行之间的分隔符。

4. 使用 NULL 作为分隔符：

```css
$ paste -z file1 file2
```

该命令会使用 NULL 作为列或行之间的分隔符。

5. 从标准输入中读取数据

`paste` 命令也可以从标准输入中读取数据，并将其合并成一列或一行。例如，将两个命令的输出合并成一行：

```css
$ ls | paste -s -d ","
```

该命令会将 `ls` 命令的输出和逗号合并成一行输出。

6. 处理多个文件中的数据

`paste` 命令还可以同时处理多个文件中的数据，并将其合并成一列或一行。例如，将多个文件中的数据按行合并：

```css
$ paste -d "\n" file1 file2 file3 ...
```

该命令会将 `file1`、`file2`、`file3` 等多个文件中的数据按行合并

7. 指定输出的行数

`paste` 命令可以使用 `-s` 选项指定输出的行数。例如，将多个文件的前三行合并成一行：

```css
$ head -n 3 file1 file2 file3 | paste -s -d " "
```

该命令会将 `file1`、`file2` 和 `file3` 文件的前三行合并成一行，并使用空格作为分隔符输出。其中，`head -n 3 file1 file2 file3` 命令会输出三个文件的前三行内容，`paste -s -d " "` 命令会将这些内容按列合并成一个文件，并使用空格作为分隔符输出。

8. 将多列文件转换为一列

如果有一个多列文件，想将它们转换为一列，可以使用 `paste` 命令结合 `awk` 命令实现，示例如下：

```css
$ paste file1 file2 file3 | awk '{ for (i=1; i<=NF; i++) print $i }' > output.txt
```

该命令将 `file1`、`file2` 和 `file3` 按列合并在一起，然后使用 `awk` 命令将各列内容逐行输出，最终结果保存到 `output.txt` 文件中。

9. 多行合并成一行

如果有多行文本需要合并成一行，可以使用 `paste` 命令的 `-s` 选项，示例如下：

```css
$ cat input.txt | paste -s -d " "
```

该命令将 `input.txt` 文件的多行内容合并成一行，并使用空格作为分隔符输出。

## du

> `du`是一个非常有用的命令，用于计算目录或文件的磁盘使用情况。当使用`du`命令计算目录大小时，它默认会递归计算子目录的大小，并且会显示每个文件和目录的大小。这在需要查找大文件或占用大量磁盘空间的目录时非常有用。`du`的完整命令格式如下：

```css
du [OPTION]... [FILE]...
```

`du`命令的一些常用选项包括：

- `-h`：以易于阅读的格式显示文件和目录的大小，例如使用KB、MB等单位。
- `-s`：仅显示指定目录或文件的总大小，而不显示子目录或文件的详细信息。
- `-c`：在计算目录或文件大小的同时，同时显示总大小。
- `-a`：显示所有文件和目录的大小，包括隐藏文件和目录。
- `-x`：仅计算当前文件系统中指定目录的大小，而不包括其他挂载的文件系统中的文件和目录。
- `-B`：指定文件和目录大小的块大小，默认情况下为1024字节。
- `-L`：在计算目录大小时，将符号链接视为常规文件而不是链接文件。
- `-D`：仅递归计算目录的深度，而不计算所有子目录的大小。
- `-x`：仅计算与指定目录在同一文件系统上的文件和目录的大小。这对于排除挂载的文件系统非常有用。
- `--exclude=PATTERN`：排除匹配指定模式的文件和目录，例如`--exclude=.git`将排除`.git`目录。

```bash
du：列出当前目录下所有文件和目录所占用的磁盘空间大小。默认以KB为单位。

du -h：以易于理解的方式列出文件和目录所占用的磁盘空间大小。会自动将大于1KB的文件和目录的大小转换成MB或GB为单位。

du -s：仅显示指定目录或文件所占用的磁盘空间总大小。

du -a：同时列出所有文件和目录所占用的磁盘空间大小。

du -c：列出所有文件和目录所占用的磁盘空间大小总和。

du -b：以字节为单位列出所有文件和目录所占用的磁盘空间大小。

du -d n：指定目录树的深度，n为深度值。例如，du -d 2将只显示当前目录和下一级子目录所占用的磁盘空间大小。

du --exclude：排除指定的目录或文件。例如，du --exclude=*.log将排除所有后缀为.log的文件。

#使用du时需要注意以下几点：

#du命令默认不包含符号链接所指向的文件或目录。如果需要包含符号链接的文件或目录，可以使用du -L命令。

#du命令默认只显示文件和目录的大小，不包括文件名或目录名。如果需要同时显示文件名或目录名，则可以使用du --si --time命令。

#du命令的输出结果包括了子目录下的所有文件和目录，因此如果需要统计某个目录下所有子目录的大小，可以使用du -h -d 1 | sort -hr命令。
```

例如，要查看当前目录中所有文件和子目录的大小，可以使用以下命令：

```bash
du -h
```

要查看指定目录或文件的大小，可以将目录或文件的路径作为`du`命令的参数。例如，要查看`/home/user`目录的大小，可以使用以下命令：

```css
du -h /home/user
```

要仅显示指定目录的总大小而不显示子目录或文件的详细信息，可以使用以下命令：

```css
du -sh /home/user
```

要同时显示指定目录和子目录的总大小，可以使用以下命令：

```css
du -c /home/user
```

例如，要计算当前目录及其子目录中的所有文件和目录的大小，但不包括挂载的文件系统和符号链接文件的大小，可以使用以下命令：

```css
du -shxL *
```

要仅计算当前目录下的所有子目录的大小，可以使用以下命令：

```css
du -shD *
```

要计算当前目录及其子目录中所有文件和目录的大小，但排除`.git`目录，可以使用以下命令：

```css
du -sh --exclude=.git *
```

## LVM

> LVM (Logical Volume Manager) 是 Linux 下一种磁盘分区管理工具，可以动态地管理磁盘分区。使用 LVM 可以方便地进行磁盘分区的管理和扩容，同时还支持磁盘快照和在线备份等功能。在Linux中，可以使用`LVM`（Logical Volume Manager）来动态地管理磁盘分区和逻辑卷。LVM可以将多个物理卷（PV）合并成一个卷组（VG），然后从卷组中创建逻辑卷（LV）。逻辑卷可以随时调整大小，而不会影响数据的完整性。

下面是使用 LVM 创建一个逻辑卷的过程及相应的命令：

1. 创建物理卷

使用 `pvcreate` 命令可以将物理磁盘设备或者分区划分为一个物理卷。例如，下面的命令将磁盘 `/dev/sdb` 划分为一个物理卷：

```css
# pvcreate /dev/sdb
```

2. 创建卷组

使用 `vgcreate` 命令可以将一个或多个物理卷划分为一个卷组。例如，下面的命令将名为 `vg0` 的卷组划分为刚刚创建的物理卷 `/dev/sdb`：

```css
# vgcreate vg0 /dev/sdb
```

3. 创建逻辑卷

使用 `lvcreate` 命令可以在一个卷组中创建逻辑卷。例如，下面的命令将在 `vg0` 卷组中创建一个名为 `mylv`、大小为 10GB 的逻辑卷：

```css
# lvcreate -n mylv -L 10G vg0
```

这个命令中 `-n` 选项指定逻辑卷的名称，`-L` 选项指定逻辑卷的大小。

4. 格式化逻辑卷

使用 `mkfs` 命令可以格式化逻辑卷。例如，下面的命令将 `mylv` 逻辑卷格式化为 `ext4` 文件系统：

```css
# mkfs.ext4 /dev/vg0/mylv
```

5. 挂载逻辑卷

使用 `mount` 命令可以将逻辑卷挂载到指定的挂载点。例如，下面的命令将 `mylv` 逻辑卷挂载到 `/mnt` 目录

```css
# mount /dev/vg0/mylv /mnt
```

在使用 LVM 进行磁盘分区管理时，需要先划分物理卷，再将物理卷划分为卷组，最后在卷组中创建逻辑卷。这样可以实现对磁盘分区的灵活管理。

另外，LVM 还有其他常用的命令，如 `pvdisplay`、`vgdisplay`、`lvdisplay` 等，可以用来查看物理卷、卷组和逻辑卷的详细信息

## fallocate

> `fallocate` 是一个 Linux 命令行工具，用于在文件系统上为文件预分配磁盘空间，以提高文件的性能和可靠性。它的主要作用是快速分配大量磁盘空间，而无需实际写入任何数据。在某些情况下，使用 `fallocate` 可以比 `dd` 命令更快地创建文件，因为它只涉及磁盘空间分配，而不涉及数据写入。

`fallocate` 命令的语法如下：

```css
fallocate [options] <filename>
```

其中，`<filename>` 是要分配空间的文件名，可以是相对路径或绝对路径。`options` 可以用于指定要分配的空间大小、类型等参数，常用的选项包括：

- `-l <size>`：指定要分配的空间大小。可以使用后缀 B, K, M, G, T 分别表示字节、千字节、兆字节、千兆字节、太字节。例如，`-l 1G` 表示分配1GB的空间。
- `-o <offset>`：指定要从文件的哪个位置开始分配空间，单位为字节。
- `-n`：告诉 `fallocate` 不要实际写入任何数据，只是分配磁盘空间。
- `--punch-hole <offset> <length>`：用于删除文件中指定范围内的数据，从而释放对应的磁盘空间。其中，`<offset>` 表示要删除的数据的起始偏移量，`<length>` 表示要删除的数据的长度。

需要注意的是，`fallocate` 命令只能在支持该操作的文件系统上使用，例如 ext4、XFS、Btrfs 等文件系统都支持 `fallocate` 命令，而 FAT32 和 NTFS 等文件系统则不支持。

例如，如果你需要创建一个大小为 10GB 的空文件，你可以使用以下命令：

```css
fallocate -l 10G /path/to/file
```

该命令会在 `/path/to/file` 路径下创建一个大小为 10GB 的空文件，这个过程比用 `dd` 命令创建同样大小的文件要快得多。

你也可以使用 `--punch-hole` 选项来删除文件中的一段数据，例如：

```css
fallocate --punch-hole 100M:500M /path/to/file
```

该命令会从 `/path/to/file` 文件中删除 100MB 到 500MB 这段范围内的数据，并释放对应的磁盘空间。

需要注意的是，使用 `fallocate` 命令创建的空文件只是分配了磁盘空间，文件中并没有实际写入任何数据。如果你想往文件中写入数据，你需要使用其他工具，例如 `dd` 命令或者 `echo` 命令等。

如果 `fallocate` 命令不可用，你也可以使用 `dd` 命令来创建文件：

```css
sudo dd if=/dev/zero of=/path/to/swapfile bs=1M count=<size in MB>
```

