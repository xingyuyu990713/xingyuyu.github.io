






## ls

> `ls` 命令是 Linux 系统中最常用的命令之一，它用于列出指定目录下的文件和子目录。下面是一些常用的 `ls` 命令选项：

1. `ls -l`：使用长格式显示文件和目录，包括文件权限、所有者、文件大小和修改时间等信息。
2. `ls -a`：显示隐藏文件和目录。
3. `ls -h`：以人类可读的格式显示文件和目录大小。
4. `ls -t`：按修改时间排序并显示文件和目录。
5. `ls -S`：按文件大小排序并显示文件和目录。
6. `ls -R`：递归显示指定目录下的文件和子目录。
7. `ls -i`：显示文件和目录的 inode 号码。

## cd

> `cd` 命令是 Linux 系统中最基本的命令之一，用于改变当前工作目录。在 Linux 系统中，所有文件和目录都存在于文件系统中，每个文件和目录都有一个相对于根目录的路径。在 Linux 系统中，当前工作目录是用户当前正在操作的目录，例如，用户可以在当前目录中创建、编辑和删除文件

1. 进入到 home 目录：

```css
cd ~
```

2. 进入到上一级目录：

```css
cd ..
```

3. 进入到指定目录：

```css
cd /path/to/directory
```

4. 入到根目录:

```css
cd /
```

需要注意的是，如果目录名包含空格或其他特殊字符，需要用引号或反斜杠进行转义。

另外，还有一些有用的 `cd` 命令选项，例如：

1. `cd -`：返回上一次工作目录。
2. `cd --`：切换到家目录，即使当前的 shell 环境变量 $HOME 已被更改。
3. `cd -P`：切换到物理路径的工作目录，而不是符号链接所指向的路径。

## pwd

> `pwd` 命令是 Linux 系统中的一个常用命令，用于显示当前工作目录的完整路径。在 Linux 系统中，每个文件和目录都有一个相对于根目录的路径，而 `pwd` 命令可以帮助用户确定当前工作目录在整个文件系统中的位置。

显示当前工作目录的完整路径：

```css
pwd
```

显示当前工作目录的符号链接路径：

```css
pwd -P
```

需要注意的是，如果当前工作目录被更改，那么 `pwd` 命令将显示更改后的工作目录的完整路径。另外，如果当前目录是符号链接，那么默认情况下 `pwd` 命令将显示符号链接路径，而不是符号链接指向的路径。如果需要显示符号链接指向的路径，可以使用 `pwd -P` 命令选项。

## touch

> `touch` 命令是 Linux 系统中的一个基本命令，它用于创建一个新的空文件或更新现有文件的访问和修改时间戳。如果指定的文件不存在，则 `touch` 命令将创建一个空文件。

创建一个新的空文件：

```css
touch filename.txt
```

更改文件的访问和修改时间戳：

```css
touch filename.txt
```

使用绝对时间更改文件的时间戳：

```css
touch -t YYYYMMDDhhmm.ss filename.txt
```

其中，`YYYYMMDDhhmm.ss` 是一个代表时间戳的数字字符串，它的格式为年月日小时分钟秒钟。

## mkdir

> `mkdir` 命令是 Linux 系统中的一个常用命令，用于创建新的目录。在 Linux 系统中，目录是用于组织和管理文件的一种结构，用户可以使用 `mkdir` 命令创建新的目录并进行文件管理。

创建一个新目录：

```css
mkdir newdir
```

递归创建目录及其子目录：

```css
mkdir -p newdir/subdir
```

创建多个目录：

```css
mkdir dir1 dir2 dir3
```

在指定目录下创建一个新目录：

```css
mkdir /path/to/newdir
```

需要注意的是，如果要在已经存在的目录中创建新目录，需要使用该目录的绝对路径或相对路径。如果使用相对路径，则将相对于当前工作目录进行计算。

另外，如果要创建多个目录，可以在 `mkdir` 命令中指定多个目录名称，或者使用 shell 通配符来创建多个目录。例如，可以使用 `mkdir dir{1..3}` 来创建 `dir1`、`dir2` 和 `dir3` 三个目录。

## rm

> `rm` 命令是 Linux 系统中的一个常用命令，用于删除文件或目录。在 Linux 系统中，用户可以使用 `rm` 命令删除不需要的文件和目录，以释放磁盘空间和管理文件系统。

删除一个文件：

```css
rm myfile.txt
```

递归删除一个目录及其子目录和文件：

```css
rm -r mydir
```

强制删除文件或目录，不提示确认：

```css
rm -f myfile.txt
rm -rf mydir
```

需要注意的是， `rm` 命令删除的文件和目录都不会进入垃圾回收站，而是直接从文件系统中删除。因此，在使用 `rm` 命令时需要格外小心，以免误删重要文件或目录。

此外，如果要删除目录及其所有子目录和文件，需要使用 `-r` 选项进行递归删除。如果要强制删除文件或目录，可以使用 `-f` 选项。强烈建议在使用 `rm -rf` 命令之前进行双重检查，以避免误删重要数据。

## cp

> `cp` 命令是 Linux 系统中的一个常用命令，用于复制文件或目录。在 Linux 系统中，用户可以使用 `cp` 命令将文件或目录从一个位置复制到另一个位置，以备份数据或进行文件管理。

复制一个文件到另一个位置：

```css
cp myfile.txt /path/to/newlocation/
```

复制一个目录及其所有子目录和文件到另一个位置：

```css
cp -r mydir /path/to/newlocation/
```

将一个文件复制到另一个文件，并在复制时重命名：

```css
cp myfile.txt newfile.txt
```

需要注意的是， `cp` 命令默认不会复制目录及其子目录和文件，如果要复制目录及其所有子目录和文件，需要使用 `-r` 选项进行递归复制。如果要在复制文件时重命名文件，可以指定新的文件名。

另外，如果要将一个目录或文件复制到另一个目录下，需要在目标位置指定目录名称，例如 `/path/to/newlocation/`。如果目标位置是已经存在的目录，则将文件或目录复制到该目录中，如果目标位置是一个新的目录名称，则会创建该目录并将文件或目录复制到其中

## mv

> `mv` 命令是 Linux 系统中的一个常用命令，用于移动或重命名文件或目录。在 Linux 系统中，用户可以使用 `mv` 命令将文件或目录从一个位置移动到另一个位置，也可以将文件或目录重命名

移动一个文件到另一个位置：

```css
mv myfile.txt /path/to/newlocation/
```

移动一个目录及其所有子目录和文件到另一个位置：

```css
mv mydir /path/to/newlocation/
```

将一个文件重命名：

```css
mv myfile.txt newfile.txt
```

需要注意的是， `mv` 命令既可以用于移动文件或目录，也可以用于重命名文件或目录。如果要将文件或目录移动到另一个位置，需要指定目标位置，例如 `/path/to/newlocation/`。如果目标位置是一个已经存在的目录，则会将文件或目录移动到该目录中，如果目标位置是一个新的目录名称，则会创建该目录并将文件或目录移动到其中。

另外，如果要重命名一个文件或目录，只需要将原始名称替换为新名称即可，例如 `mv myfile.txt newfile.txt`。

## cat

> `cat` 命令是 Linux 系统中的一个常用命令，用于显示文件内容、合并文件以及创建文件。在 Linux 系统中，用户可以使用 `cat` 命令来显示一个或多个文件的内容，也可以将多个文件的内容合并到一个文件中。

显示一个文件的内容：

```css
cat myfile.txt
```

合并多个文件到一个文件中：

```css
cat file1.txt file2.txt > combined.txt
```

创建一个新文件并向其中写入内容：

```css
cat > newfile.txt
This is the content of the new file.
Press Ctrl + D to save and exit.

#多行
cat <<EOF >a.txt
> 1
> 1
> 13
> EOF

cat a.txt
```

需要注意的是， `cat` 命令可以用于显示文件内容，但是如果文件很大或者内容很长，可以使用 `more` 或 `less` 命令进行分页显示。如果要将多个文件的内容合并到一个文件中，需要使用重定向符 `>` 将输出重定向到一个新文件中，例如 `cat file1.txt file2.txt > combined.txt` 将 `file1.txt` 和 `file2.txt` 的内容合并到 `combined.txt` 文件中。

另外，如果要创建一个新文件并向其中写入内容，需要使用重定向符 `>` 将输出重定向到新文件中，并输入文件内容，例如 `cat > newfile.txt` 将新文件的内容输入到终端中，按下 `Ctrl + D` 键保存并退出。

## less

> `less` 命令是 Linux 系统中一个非常有用的命令，它可以用于查看大型文本文件，支持向前和向后滚动文本、查找特定文本等功能。`less` 命令相对于 `more` 命令的优点在于它可以向前和向后滚动文本，而不仅仅是向前滚动。

查看一个文件的内容：

```css
less myfile.txt
```

向前滚动文本：

```css
space(空格键)
```

向后滚动文本：

```css
b
```

搜索特定文本：

```css
/search_term
```

需要注意的是， `less` 命令可以用于查看大型文本文件，但是如果文件非常大，可能需要一些时间才能加载完整个文件。在使用 `less` 命令时，可以使用以下命令来控制滚动：

- 使用空格键向前滚动一页。
- 使用 `b` 键向后滚动一页。
- 使用向上和向下箭头键向前或向后滚动一行。
- 使用 `g` 键跳到文本的开头。
- 使用 `G` 键跳到文本的结尾。
- 使用 `/search_term` 命令搜索特定文本。
- 使用 `q` 键退出 `less` 命令。

## more

> `more` 命令是 Linux 系统中一个用于查看文件内容的基本命令，它可以将文本内容分页显示，并提供一些基本的浏览和搜索功能

查看文件的内容：

```css
more filename.txt
```

向下翻一页：

```css
space(空格键)
```

向上翻一页：

```css
b
```

向下翻一行：

```css
Enter(回车键)
```

退出 `more` 命令：

```css
q
```

需要注意的是，`more` 命令仅支持向下翻页，不能向上翻页，这使得它有一定的局限性。如果需要在文件中进行快速搜索或滚动，建议使用 `less` 命令。另外，`more` 命令通常用于较小的文件，因为在查看较大的文件时，分页加载数据可能需要一些时间。

## tree

> `tree` 命令是 Linux 系统中的一个非常有用的命令，它可以以树形结构显示指定目录及其子目录中的所有文件和文件夹。这使得 `tree` 命令非常适合用于快速查看整个目录结构，并确定目录中有哪些文件和文件夹。

显示当前目录及其子目录中的所有文件和文件夹：

```css
tree
```

显示指定目录及其子目录中的所有文件和文件夹：

```css
tree /path/to/directory
```

显示目录结构，并使用图形符号来表示文件和文件夹：

```css
tree -F
```

其中，`-F` 参数用于在目录和文件名称后面添加一个符号来表示它们的类型。

需要注意的是，`tree` 命令默认只显示目录中的文件和文件夹名称，并不会显示文件和文件夹的详细信息。如果需要显示更多的信息，可以使用其他命令（如 `ls` 或 `stat`）来获取它们的详细信息。

## whatis

> `whatis` 命令是 Linux 系统中的一个命令，用于显示指定命令的简短描述信息。它通常与 `man` 命令一起使用，可以在查看命令的详细手册页之前提供有关该命令的基本信息

如果要查看 `ls` 命令的简短描述信息，可以在终端窗口中运行以下命令：

```css
whatis ls
```

该命令将显示类似于以下内容的输出:

```css
ls (1)               - list directory contents
```

其中，`ls` 是命令的名称，`1` 表示命令的手册页的节（section），`- list directory contents` 是命令的简短描述信息。

需要注意的是，`whatis` 命令只显示简短描述信息，并不会显示有关命令的详细信息。如果需要查看有关命令的更多信息，可以使用 `man` 命令查看该命令的详细手册页。

## which

> 在 Linux 系统中，which 是一个用于查找可执行程序（例如命令、脚本等）所在路径的命令行工具。它会在系统环境变量 PATH 中指定的路径中搜索指定的程序，并返回找到的第一个可执行程序的完整路径。

下面是一些常用的 which 命令选项：

- `which 程序名` ：查找指定程序名所在路径。
- `-a` ：查找所有符合条件的程序路径，并按照 PATH 的顺序依次输出。
- `-s` ：仅返回找到的第一个符合条件的程序路径

使用 which 命令可以快速定位系统中某个可执行程序的位置，以便使用该程序。在 Linux 系统中，很多命令和工具都需要通过终端输入来执行，而使用 which 命令可以避免在系统中漫无目的地查找命令和工具的位置，提高了命令行的效率和准确性。

需要注意的是，which 命令只会查找系统环境变量 PATH 中指定的路径，如果需要查找其他路径下的程序，可以考虑使用 find 命令或者直接在终端中输入程序的完整路径。

## file

> `file` 命令是 Linux 系统中的一个命令，用于确定文件类型。它通过读取文件内容的方式来确定文件类型，而不是仅仅根据文件扩展名来确定文件类型。

如果要确定文件 `/home/user/example.txt` 的类型，可以在终端窗口中运行以下命令：

```css
file /home/user/example.txt
```

该命令将显示类似于以下内容的输出：

```css
/home/user/example.txt: ASCII text
```

其中，`/home/user/example.txt` 是文件的路径和名称，`ASCII text` 是文件类型的描述信息。

除了常见的文本文件类型，`file` 命令还可以确定许多其他类型的文件，例如二进制文件、压缩文件、图像文件等等。通过 `file` 命令可以很方便地确定文件类型，从而决定使用哪些工具和应用程序来处理该文件。

## type

> `type` 命令是 Linux 系统中的一个命令，用于确定给定命令的类型。它通常用于确定命令是内部命令、外部命令还是别名。

如果要确定 `ls` 命令的类型，可以在终端窗口中运行以下命令：

```css
type ls
```

该命令将显示类似于以下内容的输出：

```css
ls is aliased to `ls --color=auto'
```

其中，`ls` 是命令的名称，`aliased to` 表示该命令是别名，后面的内容是该别名的定义。

除了别名，`type` 命令还可以确定命令是内部命令还是外部命令。如果命令是内部命令，`type` 命令将显示该命令的类型为 `shell builtin`；如果命令是外部命令，`type` 命令将显示该命令的路径。

需要注意的是，`type` 命令只能确定命令的类型，不能执行命令。如果要执行命令，应该直接输入命令名称，而不是使用 `type` 命令。

## whoami

> `whoami` 命令是 Linux 系统中的一个命令，用于显示当前用户的用户名。
>
> 在 Linux 终端中，如果您想要确定当前登录的用户是谁，可以使用 `whoami` 命令。只需在终端窗口中输入 `whoami`，并按下回车键，系统将显示您当前登录的用户名。

```css
#whoami
root
```

## who

> `who` 命令是 Linux 系统中的一个命令，用于显示当前登录到系统中的所有用户的信息。`who am i` 命令是 `who` 命令的一种变体，用于显示当前用户的登录信息
>
> 在 Linux 终端中，如果您想要确定当前登录到系统中的所有用户，可以使用 `who` 命令。只需在终端窗口中输入 `who`，并按下回车键，系统将显示当前登录到系统中的所有用户的详细信息，包括用户名、终端类型、登录时间和登录来源等

```css
[root@centos8 etc]#who
root     pts/0        2023-03-08 16:52 (10.0.0.1)
xing     pts/1        2023-03-08 14:30 (10.0.0.1)
[root@centos8 etc]#    
```

这表明 `root` 用户当前在 `pts/0` 终端登录，`xing` 用户当前在 `pts/1` 终端登录。

## `who am i`

> 如果只想查看当前用户的登录信息，可以使用 `who am i` 命令。只需在终端窗口中输入 `who am i`，并按下回车键，系统将显示当前用户的登录信息，包括用户名、终端类型和登录时间等。

```css
[root@centos8 etc]#who am i
root     pts/1        2023-03-08 14:30 (10.0.0.1)
[root@centos8 etc]#
```

## hash

> 在 Linux 中，`hash` 是一个 shell 命令，用于查找并保存命令的位置。当你在终端输入一个命令时，Linux 需要通过搜索 `$PATH` 环境变量来找到这个命令所在的位置。然而，这个过程可能会比较耗时，特别是当你执行同样的命令多次时。为了避免重复的搜索过程，shell 会将最近执行过的命令及其所在的位置记录在一个哈希表中，这个哈希表就叫做命令缓存表。

使用 `hash` 命令可以显示或操作命令缓存表。常用的选项包括：

- `hash`：显示所有命令缓存表中的命令及其位置；
- `hash -r`：清空命令缓存表，使其重新开始记录命令；
- `hash command`：强制让 shell 忽略命令缓存表中的 `command` 命令位置，并重新搜索它的位置。
- `hash -d name`:清除name命令的缓冲
- `hash -t name`: 打印缓存中name的路径

举个例子，当你第一次执行命令 `/usr/bin/ls` 时，shell 会通过搜索 `$PATH` 环境变量来找到这个命令所在的位置，并将其保存在命令缓存表中。如果你之后再次执行 `ls` 命令，shell 就不用再次搜索 `$PATH` 环境变量来查找这个命令的位置了，而是直接从命令缓存表中获取位置信息。

当你需要切换不同版本的命令时，可能需要使用 `hash -r` 命令来清空命令缓存表。例如，你可能需要在不同版本的 Python 之间切换，可以通过以下命令清空命令缓存表：

```css
$ hash -r
```

这样可以使 shell 重新搜索 `$PATH` 环境变量中的 Python 版本，并将其保存在命令缓存表中。

## alias

> 在Linux中，alias是一个用于创建命令别名的命令。使用alias可以将一个较长或较难记的命令名称映射为一个简单的别名。

例如，如果您需要经常使用ls -alh这个命令，您可以使用alias将其映射为一个简单的别名:

```css
alias ll='ls -alh'
```

在这里，ll是您创建的别名，'ls -alh'是要映射到别名的命令。现在，每当您输入ll时，系统会自动将其解释为ls -alh。

您可以通过运行alias命令查看您当前的别名列表：

```css
alias
```

要删除一个别名，可以使用unalias命令，后跟别名名称：

```css
unalias ll
```

这将删除名为ll的别名。

请注意，这些别名只在当前shell会话中有效。如果您希望在每次启动shell时都自动加载别名，则需要将它们添加到您的shell配置文件（例如~/.bashrc或~/.zshrc）中。

```bash
[root@centos8 etc]#vim /root/.bashrc
# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias vi='vim'
# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

alias scandisk='echo '\''- - -'\'' > /sys/class/scsi_host/host0/scan;echo '\''- - -'\'' > /sys/class/scsi_host/host1/scan;echo '\''- - -'\'' > /sys/class/scsi_host/host2/scan'
alias nm='systemctl restart NetworkManager'
alias yy='yum -y install'
alias yr='yum remove'
alias lh='ls -lh --color=auto'
alias cdnet='cd /etc/sysconfig/network-scripts/'
alias cdrepo='cd /etc/yum.repos.d/'
alias viens160='vim /etc/sysconfig/network-scripts/ifcfg-ens160'
alias epel='sed -ri /enabled/s/enabled=0/enabled=1//etc/yum.repos.d/base.repo'
alias disepel='sed -ri /enabled/s/enabled=1/enabled=0//etc/yum.repos.d/base.repo'
alias rm='rm -i'
alias cdnet='cd /etc/sysconfig/network-scripts/'
alias editnet='vim /etc/sysconfig/network-scripts/ifcfg-eth0'

#仅对当前用户：~/.bashrc
#对所有用户有效：/etc/bashrc

#生效
source /root/.bashrc

```

## 与系统有关

```css
#查看cpu
lscpu
cat /proc/cpuinfo

#查看内存
cat /proc/meminfo(大页也在里面看)
free -h

#查看分区
lsblk
cat /proc/partitions

#查看系统架构
arch

#查看内核版本
uname -r

#查看系统发行版本
cat /etc/redhat-release(这条命令就是从os-release里面读取出来的)
cat /etc/os-release
lsb_release -a

#ubuntu查看发型版本命令
cat /etc/os-release
cat /etc/issue
lsb_release -a


```

## uname

`uname` 是一个 Linux 系统工具，可以获取当前系统的基本信息。使用 `uname` 命令可以查询系统内核和硬件平台的信息，如内核版本、系统架构、主机名等。以下是 `uname` 命令的详细用法、选项和格式

`uname` 命令的基本用法格式如下：

```css
uname [OPTION]...
```

其中，`OPTION` 是可选的命令选项。如果不带任何选项，`uname` 命令将显示系统内核的名称。

`uname` 命令的常用选项如下：

- `-a`：显示所有可用的系统信息，包括系统名称、节点名称、内核版本、操作系统版本等。
- `-s`：显示操作系统内核名称。
- `-n`：显示网络中本地主机的名称。
- `-r`：显示操作系统内核的版本号。
- `-m`：显示系统的硬件架构。
- `-p`：显示处理器类型。
- `-i`：显示硬件平台的名称。
- `-o`：显示操作系统的名称。

除了上述常用选项外，`uname` 命令还支持许多其他选项，如：

- `-m`：显示系统的硬件架构。
- `-a`：显示所有可用的系统信息，包括系统名称、节点名称、内核版本、操作系统版本等。
- `-o`：显示操作系统的名称。
- `-p`：显示处理器类型。
- `-i`：显示硬件平台的名称。

## ln

> `ln`命令是Linux系统中的一个常用命令，它的主要作用是用于创建硬链接或符号链接。硬链接和符号链接都可以用来连接文件，但它们的实现方式不同，所以它们的用法和特性也略有不同。

`ln`命令的基本语法如下：

```css
ln [选项] 源文件 目标文件
```

其中，`源文件`表示需要创建链接的文件，`目标文件`表示创建的链接文件的名称。

选项：

`ln`命令支持的选项有很多，下面是一些常用选项的详细说明：

- `-s`（或`--symbolic`）：用于创建符号链接（也称为软链接），即创建一个指向源文件的符号链接文件。
- `-f`（或`--force`）：如果目标文件已经存在，强制覆盖它。
- `-i`（或`--interactive`）：如果目标文件已经存在，询问用户是否覆盖它。
- `-n`（或`--no-dereference`）：用于创建指向符号链接本身而不是目标文件的符号链接。
- `-v`（或`--verbose`）：在执行命令时显示详细输出信息

硬链接和符号链接的区别：

- 硬链接：硬链接是指在文件系统中，将一个文件名与一个inode号建立一一对应的关系，这样就可以通过不同的文件名来访问同一个文件内容。如果删除一个硬链接文件，不会影响其他硬链接和原始文件。
- 符号链接：符号链接是指创建一个新文件，其中包含一个指向原始文件的路径名，也称为软链接。如果删除一个符号链接文件，不会影响原始文件和其他硬链接。

1. 创建一个硬链接文件：

```css
ln 源文件 目标文件
```

2. 创建一个符号链接文件：

```css
ln -s 源文件 目标文件
```

3. 强制覆盖已存在的文件：

```css
ln -f 源文件 目标文件
```

4. 创建一个指向符号链接本身的符号链接：

```css
ln -n 源文件 目标文件
```

5. 询问用户是否覆盖已存在的文件：

```css
ln -i 源文件 目标文件
```

6. 在执行命令时显示详细输出信息：

```css
ln -v 源文件 目标文件
```

注意事项：

* 创建符号链接时，如果源文件的绝对路径和目标文件在不同的文件系统上，需要使用绝对路径来创建符号链接
* 在创建符号链接时，如果删除了原始文件，符号链接将成为孤儿链接，无法使用，因此需要谨慎操作。
* 不能对目录创建硬链接。符号链接可以，硬链接的本质是在文件系统中创建一个新的文件名，使其与原文件共享同一个inode和数据块，因此硬链接只能创建在文件上，而不能创建在目录上。如果在目录上创建硬链接，会破坏目录的结构，导致一些文件无法被正常访问，从而影响整个文件系统的正常运行。而符号链接则可以创建在目录上，因为符号链接只是一个指向目标文件或目录的路径名。

### 硬链接和软链接的区别

> Linux中有两种类型的链接：硬链接（Hard Link）和软链接（Symbolic Link，也叫符号链接）。它们有以下区别：

```css
1.inode和数据块的不同：硬链接与原始文件共享相同的inode和数据块，而软链接则是一个新的文件，其中包含一个指向原始文件的路径名。

2.跨文件系统的限制：硬链接不能跨越文件系统，也就是说，硬链接只能在同一个文件系统内创建，而软链接可以跨越不同的文件系统。

3.文件类型的不同：硬链接只能链接到文件，不能链接到目录，而软链接可以链接到文件或目录。

4.删除文件的影响：如果原始文件被删除了，硬链接仍然可以访问原始文件的数据，因为它们共享相同的inode和数据块。而软链接则无法访问原始文件的数据，因为它只是一个指向原始文件的路径名，如果原始文件被删除了，软链接就成为了一个孤儿链接，无法访问原始文件的数据。

5.创建数量的限制：文件系统对硬链接的数量没有限制，而对软链接的数量有一定的限制。

总的来说，硬链接与原始文件共享相同的inode和数据块，是文件系统内部的链接方式；而软链接则是一个指向原始文件或目录的路径名，可以跨越不同的文件系统。在使用时需要注意它们的不同特点和适用范围。
```

```
本质：
硬链接：本质是同一个文件
软链接：本质不是同一个文件
2. 跨设备
硬链接：不支持
软链接：支持
3. inode
硬链接：相同
软链接：不同
4. 链接数
硬链接：创建新的硬链接,链接数会增加,删除硬链接,链接数减少
软链接：创建或删除,链接数不会变化
5. 文件夹
硬链接：不支持
软链接：支持
6. 相对路径
硬链接：原始文件相对路径是相对于当前工作目录
软链接：原始文件的相对路径是相对于链接文件的相对路径
7. 删除源文件
硬链接：只是链接数减一,但链接文件的访问不受影响
软链接：链接文件将无法访问
8. 文件类型
硬链接：和源文件相同
软链接：链接文件,和源文件无关
9. 文件大小
硬链接: 和源文件相同
软链接: 源文件的路径的长度
```

## dd

> 在Linux中，`dd`是一个命令行工具，通常用于复制文件、将数据从一个设备复制到另一个设备 、备份和还原磁盘映像等操作。"dd"命令可以对任何块设备金进行操作，例如硬盘、USB驱动器、CD-ROM等。

**格式**：

```css
dd [if=inputfile] [of=outputfile] [bs=blocksize] [count=numblocks]
```

其中：

- `if`： 输入文件，即要复制的源文件或设备；
- `of`：输出文件，即数据写入的目标文件或设备；
- `bs`：块大小，即每次读写的字节数，默认值为512；
- `count`：块数，即要复制的块数。

例如，要将一个名为`sourcefile`的文件复制到名为`destinationfile`的文件中，可以使用以下命令：

```bash
dd if=sourcefile of=destinationfile
```

要将一个设备复制到另一个设备中，可以使用以下命令：

```javascript
dd if=/dev/sda of=/dev/sdb
```

常用选项：

```css
if=file 			从所命名文件读取而不是从标准输入
of=file 		写到所命名的文件而不是到标准输出
ibs=size 		一次读size个byte
obs=size 		一次写size个byte
bs=size 		block size, 指定块大小（既是是ibs也是obs)
cbs=size		一次转化size个byte
skip=blocks 	从开头忽略blocks个ibs大小的块(在if文件中跳过多少bs)
seek=blocks 	从开头忽略blocks个obs大小的块(在of文件中跳过多少bs)
count=n 		复制n个bs
conv=conversion[,conversion...] 用指定的参数转换文件

conversion 	转换参数:
ascii 		转换 EBCDIC 为 ASCII
ebcdic 		转换 ASCII 为 EBCDIC
lcase 		把大写字符转换为小写字符
ucase 		把小写字符转换为大写字符
nocreat 	不创建输出文件
noerror 	出错时不停止
notrunc 	不截短输出文件
sync 		把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐
fdatasync 	写完成前，物理写入输出文件
```

案例1：备份MBR中的分区表

```bash
dd if=/dev/sda of=/data/mbr bs=1 count=64 skip=446
```

## mount、umount

> `mount`和`umount`是Linux操作系统中用于挂载和卸载文件系统的命令。

### 挂载文件系统（mount）

`mount`命令可以将一个文件系统挂载到指定的挂载点上，使得该文件系统中的文件可以被访问和操作。使用`mount`命令需要指定两个参数：文件系统设备和挂载点。

语法：

```css
mount [-t filesystem-type] [-o mount-options] device mount-point
```

- `-t`选项用于指定文件系统类型。如果不指定，Linux会自动检测文件系统类型。
- `-r`readonly,只读挂载
- `-w`read and write，读写挂载，此为默认设备，可以省略
- `-o`选项用于指定挂载选项，例如读写权限、用户权限等。多个选项可以用逗号隔开。
- `device`参数用于指定文件系统的设备路径，可以是设备文件路径，也可以是网络文件系统路径等。
- `mount-point`参数用于指定文件系统挂载的挂载点

例如，以下命令将/dev/sdb1分区以ext4文件系统类型，以读写权限挂载到/mnt目录：

```bash
mount -t ext4 -o rw /dev/sdb1 /mnt
```

### 卸载文件系统（umount）

`umount`命令用于卸载一个已经挂载的文件系统，使得该文件系统中的文件不能被访问和操作。使用`umount`命令只需要指定卸载点即可。

语法:

```css
umount mount-point
```

例如，以下命令将/mnt目录上的文件系统卸载：

```bash
umount /mnt
```

需要注意的是，如果文件系统正在被使用，例如正在运行的程序正在读写该文件系统中的文件，那么使用`umount`命令可能会失败。此时，需要停止所有正在使用该文件系统的进程，或者使用`-l`选项强制卸载文件系统。例如，以下命令强制卸载/mnt目录上的文件系统：

```bash
umount -l /mnt
```

`mount`命令可以通过使用`-o`选项来为文件系统指定一些挂载选项。下面介绍一些常见的`-o`选项：

- `rw`：以可读写模式（默认）挂载文件系统。
- `ro`：以只读模式(read-only)挂载文件系统，文件系统只能被读取，不能被修改。
- `remount`：重新挂载一个已经挂载的文件系统，并更改挂载选项。该选项需要与其他挂载选项一起使用。例如，`mount -o remount,rw /dev/sda1 /mnt`将重新将`/dev/sda1`分区以可读写模式挂载到`/mnt`目录。
- `noexec`：禁止在文件系统上执行任何二进制文件。
- `nodev`：禁止在文件系统上创建设备文件。
- `nosuid`：禁止在文件系统上启用`setuid`和`setgid`权限。
- `noatime`：不更新文件的访问时间戳，可以提高文件系统性能。
- `nodiratime`：不更新目录的访问时间戳，可以提高文件系统性能。
- `sync`：所有的数据写入都会被同步写入存储设备，可以提高数据安全性，但是会影响文件系统性能。
- `async`：数据写入可以被缓存，可以提高文件系统性能，但是会降低数据安全性。
- `defaults`：使用默认的挂载选项，包括可读写模式、访问时间戳更新等.相当于rw, suid, dev, exec, auto, nouser, async。
- `user`：允许普通用户挂载文件系统，否则只有超级用户才能进行挂载

例如，以下命令将以只读模式挂载`/dev/sda1`分区，并禁止在该分区上执行任何二进制文件：

```bash
mount -o ro,noexec /dev/sda1 /mnt
```

需要注意的是，挂载选项可以组合使用，例如`mount -o rw,noatime,nodiratime /dev/sda1 /mnt`将以可读写模式挂载`/dev/sda1`分区，并且不会更新文件和目录的访问时间戳。

- `errors=remount-ro`：当发生错误时，重新挂载文件系统为只读模式。这可以防止对文件系统的进一步损坏，并可以帮助恢复数据。
- `uid`：指定文件系统的所有者用户ID。
- `gid`：指定文件系统的所有者组ID。
- `umask`：指定文件系统的默认权限掩码。
- `offset`：指定分区的偏移量，用于挂载某些不支持LVM或RAID等高级功能的磁盘分区。
- `loop`：将文件作为块设备挂载为文件系统，这通常用于挂载ISO映像文件。

例如，以下命令将以默认的挂载选项，使用`uid`和`gid`选项来指定文件系统的所有者为1001：

```bash
mount -o uid=1001,gid=1001 /dev/sda1 /mnt
```

需要注意的是，`-o`选项可以有多个，以逗号分隔。例如，`mount -o rw,noatime,uid=1001,gid=1001 /dev/sda1 /mnt`将以可读写模式挂载`/dev/sda1`分区，不会更新访问时间戳，并将文件系统的所有者设置为1001用户和组.

## 时间戳

在Linux中，有四种时间戳与文件相关：访问时间（access time，atime）、修改时间（modification time，mtime）、状态改变时间（change time，ctime）和备份时间（backup time）。这些时间戳记录了文件的不同属性和状态，可以用于诊断问题，跟踪文件变更等等。

1. 访问时间（atime）：记录文件上一次被访问的时间戳。当文件被读取或执行时，它的atime会被更新。在一些系统中，每次对文件进行任何操作（包括仅仅打开文件）时，atime都会被更新。atime可以使用`ls -l`或`stat`命令来查看。
2. 修改时间（mtime）：记录文件上一次被修改的时间戳。当文件内容发生改变时，它的mtime会被更新。mtime可以使用`ls -l`或`stat`命令来查看。
3. 状态改变时间（ctime）：记录文件状态发生改变的时间戳。当文件的属性或权限发生变化时，或者文件被创建或删除时，它的ctime会被更新。ctime可以使用`ls -l`或`stat`命令来查看。
4. 备份时间（backup time）：记录文件上一次被备份的时间戳。通常情况下，备份时间是不受文件系统管理的，而是由备份工具记录的。

在Linux中，可以使用`touch`命令来修改文件的时间戳，例如，使用`touch -a`命令可以仅更新文件的atime，使用`touch -m`命令可以仅更新文件的mtime。

相比较于atime，relatime是一种优化选项。在relatime模式下，只有当文件的atime比文件的mtime或ctime要早时，才会更新atime。这样，可以减少系统更新atime的次数，从而减少系统的I/O负载。目前，relatime已成为Linux内核中的默认选项。

## stat

> `stat` 命令是 Linux 系统中的一个基本命令，它用于显示指定文件或目录的详细信息，包括文件的访问权限、所有者、修改时间、创建时间等。

显示文件或目录的详细信息：

```css
stat filename.txt
```

以格式化输出方式显示文件或目录的详细信息：

```css
stat -c "File: %n\nSize: %s bytes\nAccess: %A\nModify: %y\nChange: %z\n" filename.txt
```

其中，`-c` 参数用于指定输出格式，`%n` 表示文件名，`%s` 表示文件大小，`%A` 表示访问权限，`%y` 表示修改时间，`%z` 表示创建时间。

需要注意的是，`stat` 命令在显示文件或目录的详细信息时，提供了非常丰富的信息，因此可以用于快速查看文件或目录的元数据。此外，`stat` 命令还可以用于以特定格式输出文件或目录的详细信息，这使得它非常适合用于自动化脚本和程序中。

## df

在Linux系统中，df命令是一个常用的磁盘空间查看工具，用于显示系统中文件系统的磁盘使用情况统计信息,具体包括文件系统大小、已用空间、可用空间等信息。

语法：

```css
df [选项] [文件系统]
```

其中，选项和文件系统都是可选参数。如果不指定文件系统，则默认显示所有文件系统的磁盘使用情况统计信息。

常用的选项包括：

- `-h`：以易于理解的格式显示磁盘使用情况，如使用GB、MB等单位；
- `-T`：显示文件系统类型；
- `-i`：显示inode使用情况；
- `-x` 文件系统类型：排除指定类型的文件系统。

例如，下面的命令将显示所有文件系统的磁盘使用情况：

```bash
df
```

输出结果包括文件系统名称、挂载点、总大小、已用空间、可用空间、已用空间百分比和文件系统类型等信息。

如果需要以易于理解的格式显示磁盘使用情况，则可以使用-h选项，如下所示：

```bash
df -h
```

该命令会将文件系统大小、已用空间和可用空间等信息以GB、MB等单位显示，更加易于理解。

如果需要显示某个特定文件系统的磁盘使用情况，则可以在命令后指定该文件系统的挂载点，如下所示：

```bash
df /dev/sda1
```

该命令会显示/dev/sda1文件系统的磁盘使用情况。

总的来说，df命令是一个非常有用的工具，可以帮助用户及时了解系统中磁盘空间的使用情况，以便及时处理和清理无用文件，保证系统的正常运行。

## lsblk

> 在Linux中，`lsblk`命令用于列出块设备的信息，包括磁盘分区、软件RAID、LVM逻辑卷等等。下面是该命令的一些常见用法和选项：

常见用法

1. 列出所有块设备的信息：`lsblk -f`
2. 列出指定设备的信息：`lsblk /dev/sda`

常见选项：

1. `-a`：显示所有的块设备，包括未挂载的设备和虚拟设备（例如 `/dev/sda` 和 `/dev/sda1`）。

2. `-d`：仅显示磁盘设备，不显示分区设备。

3. `-f`：显示文件系统的详细信息。

4. `-m`：使用 MiB、GiB 等更易读的单位显示设备大小。

5. `-n`：不对设备名称进行缩短，以避免截断长名称。

6. `-o <列名>`：仅显示指定的列，多个列名以逗号分隔，例如 `-o NAME,SIZE`。

7. `-p`：在输出中打印设备的括号括起来的完整路径。

8. `-r`：以相反的顺序显示设备。

9. `-s`：显示设备的大小总和。

例如，`lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT`会输出设备名称、大小、文件系统类型和挂载点等信息，`lsblk -s /dev/sda`会输出`/dev/sda`设备及其子设备的信息。

## mkfs

在Linux系统中，mkfs命令用于格式化文件系统，即在指定的分区或设备上创建一个新的文件系统。使用mkfs命令可以将一个分区或设备格式化为各种不同的文件系统类型，例如ext2、ext3、ext4、xfs、NTFS等。本文将详细介绍mkfs命令的使用方法和常用选项。

基本语法：

```css
mkfs [选项] 文件系统类型 分区或设备名称
```

常用选项：

- `-t `文件系统类型：指定要创建的文件系统类型；
- `-V`显示详细的调试信息；
- `-c`在创建文件系统前进行检查，以避免坏块的产生；
- `-L` 标签名：为文件系统设置一个标签；
- `-m`保留空间比例：指定文件系统应该保留的空间比例；
- `-n`不要创建文件系统，只输出将要执行的操作。

例如，下面的命令将在/dev/sdb1设备上创建一个ext4文件系统，同时设置文件系统的标签为data：

```bash
mkfs -t ext4 -L data /dev/sdb1
#或者
mkfs.ext4 -L data /dev/sdb1
```

在执行该命令时，mkfs会首先检查设备上是否存在文件系统，如果存在则会提示用户是否覆盖原有的文件系统。

另外，对于一些特定的文件系统类型，mkfs命令还提供了一些额外的选项。例如，对于ext2文件系统，可以使用如下命令创建文件系统：

```css
mkfs.ext2 [选项] 分区或设备名称
```

其中，ext2文件系统的常用选项包括：

- `-b` 块大小：指定文件系统的块大小；
- `-I` inode大小：指定文件系统中inode节点的大小；
- `-N `inode数量：指定文件系统中inode节点的数量；
- `-m` 保留空间比例：指定文件系统应该保留的空间比例；
- `-v`显示详细的输出信息。

总之，mkfs命令是一个非常有用的工具，可以帮助用户在Linux系统中快速创建各种不同类型的文件系统，以便更好地管理和利用系统资源。在使用mkfs命令时，需要注意选择正确的文件系统类型和选项，以避免出现错误和不必要的损失。

要格式化一个分区或设备为xfs文件系统，可以使用如下命令：

```css
mkfs.xfs [选项] 分区或设备名称
```

其中，选项可以根据需要进行设置，常用的选项包括：

- `-d` 数据盘布局选项：用于指定文件系统的数据盘布局参数；
- `-f`强制格式化，不进行任何确认操作；
- `-l` 日志选项：用于指定文件系统的日志参数；
- `-n`数据盘布局名称：用于指定数据盘布局的名称；
- `-L` 文件系统标签：用于指定文件系统的标签。

例如，下面的命令将在/dev/sdc1设备上创建一个新的xfs文件系统，并设置文件系统的标签为data：

```bash
mkfs.xfs -L data /dev/sdc1
```

在执行该命令时，mkfs.xfs会首先检查设备上是否存在文件系统，如果存在则会提示用户是否覆盖原有的文件系统。

需要注意的是，使用mkfs命令格式化文件系统时，会将文件系统上所有的数据和元数据清除，因此在执行该命令前应该备份重要的数据。

## fsck

> 在Linux中，`fsck`是一种用于检查和修复文件系统错误的命令。当文件系统发生错误时，例如因为系统崩溃或硬件损坏导致的数据损坏，fsck可以扫描文件系统，并尝试恢复损坏的数据和元数据，以便恢复文件系统的正常操作。本文将介绍fsck命令的基本语法和常用选项，以及如何使用fsck命令检查和修复文件系统错误。

基本语法：

```css
fsck [选项] 分区或设备名称
```

常用选项：

- `-a`：自动修复文件系统错误；
- `-n`：只检查文件系统，不修复错误；
- `-p`：自动修复文件系统错误，不进行任何提示；
- `-r`：交互式修复文件系统错误；
- `-t` 文件系统类型：指定要检查的文件系统类型；
- `-V`：显示详细的调试信息。

例如，下面的命令将对/dev/sda1分区上的文件系统进行自动修复：

```bash
fsck -a /dev/sda1
```

在执行该命令时，fsck会扫描文件系统，并尝试自动修复发现的错误。

另外，fsck命令还可以指定文件系统类型进行检查和修复。例如，要检查一个ext4文件系统，可以使用如下命令：

```css
fsck.ext4 [选项] 分区或设备名称
```

其中，ext4文件系统的常用选项与fsck命令相同。

需要注意的是，在使用fsck命令检查和修复文件系统时，应该在单用户模式下运行，以避免其他程序对文件系统的干扰。同时，应该备份重要的数据，并确保磁盘空间充足，以便fsck命令可以进行修复操作。如果文件系统发生严重的错误，fsck可能无法修复问题，需要使用其他工具或手动处理数据。

## e2fsck

`e2fsck` 和 `fsck` 都是用于检查和修复文件系统错误的命令，但它们的作用略有不同：

1. `e2fsck` 命令用于检查和修复 ext2、ext3 和 ext4 文件系统。它是专门针对这些文件系统类型进行设计的，因此具有更好的文件系统修复能力。例如，`e2fsck` 命令可以检查和修复损坏的 inode，删除未被链接的文件等等。
2. `fsck` 命令用于检查和修复多种文件系统，包括 ext2、ext3、ext4、xfs、btrfs 等等。它是通用的文件系统检查和修复命令，可以应用于多种不同类型的文件系统。但是，由于其通用性，可能在某些文件系统上的修复能力不如 `e2fsck` 命令。

因此，如果需要检查和修复 ext2、ext3 或 ext4 文件系统，建议使用 `e2fsck` 命令，而如果需要检查和修复多种文件系统，可以使用 `fsck` 命令。在使用这些命令之前，应该先备份数据，以免出现数据丢失的情况。

## swap

> 在Linux操作系统中，swap（交换分区）是一种特殊的分区，用于将内存中暂时不使用的数据转移到磁盘上，以释放内存空间，从而避免系统内存不足的情况。当系统内存紧张时，操作系统会将一部分内存中的数据写入swap分区，以释放空间供其他应用程序使用。当应用程序再次需要访问该数据时，操作系统将从swap分区中读取数据并重新加载到内存中。

Linux系统中，我们可以使用以下命令查看系统中swap的使用情况：

```ruby
$ swapon -s
```

该命令会显示当前系统中所有已经启用的swap分区及其使用情况。

可以使用以下命令创建一个swap分区：

```shell
$ sudo mkswap /dev/sdb1
```

该命令将/dev/sdb1设备格式化为swap分区，并将其标记为可用的swap分区。需要注意的是，在创建swap分区之前，必须确保该分区没有被挂载或正在使用。

为了启用新创建的swap分区，我们需要将其添加到/etc/fstab文件中。具体来说，我们需要在/etc/fstab文件中添加如下一行：

```bash
/dev/sdb1   swap   swap   defaults   0   0
```

其中，第一个参数是swap分区的设备名，第二个参数是分区的类型（应该设置为"swap"），第三个参数也是"swap"，第四个参数是挂载选项，第五个参数是dump标志位（通常设置为0），第六个参数是fsck标志位（通常设置为0）。

如果我们需要暂时禁用swap分区，可以使用以下命令：

```shell
$ sudo swapoff /dev/sdb1
```

这将导致系统停止使用/dev/sdb1分区作为swap分区。如果我们需要永久禁用该分区作为swap分区，可以编辑/etc/fstab文件并将该行注释掉或删除。

## parted

> `Parted`是一个用于对硬盘进行分区的命令行工具。它可以创建、删除、调整和移动硬盘分区，并支持多种不同的分区格式。下面是一些Parted命令的示例：

1. 查看硬盘分区情况

使用 parted -l 命令可以查看系统中所有硬盘的分区情况。例如：

```ruby
$ sudo parted -l
```

该命令将列出所有硬盘的分区情况，以及硬盘的大小、文件系统类型等信息。

2. 创建分区

要创建一个新的分区，可以使用mkpart命令。例如，要创建一个大小为10 GB的新分区，可以输入：

```shell
$ sudo parted /dev/sda mkpart primary 0GB 10GB
```

这将在/dev/sda上创建一个新的主分区，其起始位置为0GB，结束位置为10GB。

3. 删除分区

要删除分区，可以使用rm命令。例如，要删除/dev/sda上的第3个分区，可以输入：

```shell
$ sudo parted /dev/sda rm 3
```

这将删除/dev/sda上的第3个分区。

4. 调整分区大小

要调整分区的大小，可以使用resizepart命令。例如，要将/dev/sda上的第1个分区调整为20 GB，可以输入：

```shell
$ sudo parted /dev/sda resizepart 1 20GB
```

这将将/dev/sda上的第1个分区大小调整为20 GB。

5. 移动分区

要移动分区，可以使用move命令。例如，要将/dev/sda上的第2个分区移动到位置50GB处，可以输入：

```bash
$ sudo parted /dev/sda move 2 50GB
```

6. 切换分区单位

默认情况下，Parted命令使用的是MiB（兆字节）作为分区大小的单位。要切换到其他单位，可以使用unit命令。例如，要切换到GB作为单位，可以输入：

```shell
$ sudo parted /dev/sda unit GB
```

7. 查看分区信息

要查看有关某个特定分区的详细信息，可以使用print命令。例如，要查看/dev/sda上的第1个分区的详细信息，可以输入：

```shell
$ sudo parted /dev/sda print 1
```

该命令将显示有关该分区的信息，例如分区的大小、起始位置、文件系统类型等。

8. 格式化分区

要格式化分区以便在其上创建文件系统，可以使用mkfs命令。例如，要在/dev/sda上的第1个分区上创建ext4文件系统，可以输入：

```shell
$ sudo mkfs.ext4 /dev/sda1
```

这将格式化/dev/sda上的第1个分区，并在其上创建一个ext4文件系统。

9. 创建磁盘分区表

在创建分区之前，需要先创建磁盘分区表。常见的磁盘分区表有两种类型：MS-DOS和GPT。可以使用以下命令创建一个GPT分区表

```css
parted /dev/sda mklabel gpt
```

## mkswap

> `mkswap` 是 Linux 系统中用于创建交换分区的命令。交换分区是一种在物理内存不足时，用于扩展可用内存的技术。它利用磁盘空间作为临时存储区域，将物理内存中暂时不需要的数据转存到磁盘上，以便为即将到来的进程腾出更多的内存空间

以下是使用 `mkswap` 创建交换分区的详细步骤：

1. 首先，需要确定哪个磁盘分区将被用作交换分区。可以使用 `fdisk` 或 `parted` 等命令查看磁盘分区的信息。
2. 执行以下命令将所选分区格式化为交换分区：

```css
sudo mkswap /dev/sdxY
```

其中 `/dev/sdxY` 是所选分区的路径。执行此命令后，系统会将分区标记为 Linux swap，并创建一个用于跟踪交换分区使用情况的 UUID

3. 接下来，需要将交换分区启用。可以使用以下命令激活交换分区：

```css
sudo swapon /dev/sdxY
```

其中 `/dev/sdxY` 是交换分区的路径。执行此命令后，系统会将交换分区加入到可用的交换空间列表中。

如果想要在启动时自动启用交换分区，可以将其路径添加到 `/etc/fstab` 文件中。可以使用以下命令将其添加到 `/etc/fstab` 中：

```css
echo '/dev/sdxY swap swap defaults 0 0' | sudo tee -a /etc/fstab
```

执行此命令后，系统会将交换分区的信息添加到 `/etc/fstab` 中。

4. 如果想要禁用交换分区，可以使用以下命令：

```css
sudo swapoff /dev/sdxY
```

其中 `/dev/sdxY` 是交换分区的路径。执行此命令后，系统会将交换分区从可用的交换空间列表中删除。

总结一下，创建交换分区的步骤是：

1. 确定分区
2. 执行 `mkswap` 格式化分区
3. 使用 `swapon` 启用分区
4. 将分区添加到 `/etc/fstab` 实现启动时自动启用
5. 使用 `swapoff` 禁用分区。

## partprobe

> 在Linux系统中使用磁盘时，有时需要手动分区，或者可能已经添加了一个新的磁盘并希望操作系统知道它已经存在。这时，就可以使用`partprobe`命令通知内核分区表已经被修改。

`partprobe`命令的作用是告诉内核重新读取分区表并更新内存中的信息。可以通过一下两种方式之一来完成：

1. 使用块设备路径作为参数，重新读取设备的分区表。例如：

```
partprobe /dev/sda
```

这将告诉内核重新读取`/dev/sda`上的分区表。

1. 如果不指定参数，则`partprobe`将扫描所有已知的块设备(重新读取所有磁盘的分区表)并更新内存中的信息。例如：

```
partprobe
```

注意：使用`partprobe`命令修改分区表不会立即生效，而是需要重启系统或重新加载相关设备驱动程序以使其生效。但是，使用`partprobe`命令可以帮助避免手动操作分区表所带来的风险。

除了上面常规用途，`partprobe`命令还可以用于一下情况：

1. 更新RAID阵列配置：如果系统中有软件RAID阵列，则在修改分区表后，可以使用`partprobe`命令通知RAID阵列管理器更新配置。
2. 更新LVM逻辑卷：如果使用LVM(逻辑卷管理器)来管理硬盘分区，则修改分区表后需要使用`partprobe`命令通知LVM更新分区信息。
3. 更新iSCSI目标设备：如果使用iSCSI技术将远程存储设备映射到本地系统上，则在添加或删除目标设备后，使用`partprobe`命令来通知系统更新新设备列表。 

注意：并不是所有的Linux发行版都默认安装了`partprobe`命令。如果在你的系统中找不到该命令，可以尝试使用`partx`命令来达到相同的效果。`partx`命令是`partprobe`命令的一种替代方案，它与`partprobe`的用法类似，但其默认情况下会扫描所有已知的设备。

1. 手动指定一个分区的信息

```
sudo partprobe /dev/sda --set-partition=1 --type=0x83 --start=2048 --end=1048575
```

1. 显示分区信息

```
sudo partprobe -s
```

1. 强制重新加载

```
sudo partprobe -d /dev/sda
```

1. 检查特定设备的分区信息并打印到stdout

```
sudo partprobe -s /dev/sda
```

1. 在特定的设备上创建一个新的分区

```
sudo partprobe /dev/sda && sudo fdisk /dev/sda
```

1. 显示`partprobe`命令的版本信息

```
sudo partprobe --version
```

1. 指定一个分区的信息并创建它

```
sudo partprobe /dev/sda --set-partition=1 --typr=0x83 --start=2048 --end=1048575 --create
```

## fdisk

> `gdisk`和`fdisk`都是在Linux系统中管理磁盘分区的命令行工具。`gdisk`工具是专门用于管理`GUID`分区表`(GPT)`的工具，而`fdisk`则是用于管理传统分区表`(MBR)`的工具。

有关`fdisk`的一些理解：

- `fdisk`是Linux中的另一种基于命令行的发分区工具，用于管理`MBR`分区表。
- `fdisk`命令可以用于创建、删除、修改、移动和备份`MBR`分区表，以及添加、删除、修改、移动和备份`MBR`分区。
- `MBR`分区表相比`GPT`分区表可以支持更少的分区和更小的硬盘容量，但它是早期的计算机系统和`BIOS`系统所采用的的分区表格式。
- `fdisk`命令可以通过使用参数和交互式提示来进行操作 。例如，创建一个新的`MBR`分区表的命令是`sudo fdisk /dev/sda`,其中"/dev/sda"是要进行分区的磁盘名称。
- `fdisk`命令还提供了一些其他的功能，例如查看分区表、显示分区信息、更改分区类型、更改分区大小等。

```bash
#选项
fdisk -l：列出所有硬盘的分区信息。
fdisk /dev/sda：打开硬盘sda的分区管理器，可以执行创建、删除、修改分区等操作。
m：列出所有命令及其说明。
p：打印出分区表信息。
n：创建新分区。
d：删除一个分区。
w：保存并退出。
q：不保存并退出。
在使用fdisk时，需要以root权限或sudo权限运行。
```

1. 创建一个新的`MBR`分区表

```
sudo fdisk /dev/sda
o
w
```

1. 显示`MBR`分区表

```
#这个命令将列出您系统中所有可用的磁盘和分区，包括设备名称、起始扇区和结束扇区、类型等信息
sudo fdisk -l /dev/sda
```

1. 向`MBR`分区表中添加一个新的分区(root身份)：

```
sudo fdisk /dev/sda
n
<Enter>
<Enter>
<Enter>
+1G或者100M
w
```

1. 删除MBR分区表中的一个分区：

```
sudo fdisk /dev/sda
d
<Enter>
<分区号>
w
```

1. 改变分区类型

```
sudo fdisk /dev/sda
t
输入要修改的分区编号
L #查看有哪些类型
83 #例如：swap是82
w
```

1. 将磁盘分区的单位改为扇区数

默认情况下，fdisk命令使用磁盘分区的大小作为单位，但是可以使用以下命令将单位改为扇区数：

```
sudo fdisk -u /dev/sda
```

1. 修改分区的起始扇区数

```
sudo fdisk /dev/sda
x #进入专家模式
b
输入要修改的分区的编号，再输入新的起始扇区号(注意必须是2048的倍数)
w
```

1. 备份和恢复分区表

```
sudo sfdisk -d /dev/sda > sda-partition-table.backup
```

其中，“sda”是您要备份分区表的设备名称，将分区表备份到名为“sda-partition-table.backup”的文件中。要将备份文件恢复到设备，请使用以下命令：

```
sudo sfdisk /dev/sda < sda-partition-table.backup
```

1. 查看分区的UUID

```
sudo blkid /dev/sda
```

1. 在新建分区时指定文件系统类型

默认情况下，fdisk命令在新建分区时不会为其指定文件系统类型。要在新建分区时指定文件系统类型，请使用以下命令：

```
sudo fdisk /dev/sda
n
t
7 #这里输入分区里面文件系统对应的代码，可以用L查看，例如：swap对应是82
w
```

## gdisk

> `gdisk`也是Linux系统中一个命令行工具，用于管理硬盘分区。与`fdisk`不同的是，`gdisk`是专门用于管理GPT分区表的工具。

- `gdisk`是一种基于命令行的分区工具，用于在Linux系统中对`GPT`分区表进行操作。

- `gdisk`命令可以用于创建、删除、修改、移动和备份`GPT`分区表，以及添加、删除、修改、移动和备份`GPT`分区。

- `GPT`分区表相比`MBR`分区表可以支持更大的硬盘和更多的分区，它也支持更好的磁盘容错和安全性。

- `gdisk`命令可以通过使用参数和交互式提示来进行操作。例如，创建一个新的`GPT`分区表的命令是`sudo gdisk /dev/sda`，其中`/dev/sda`是要进行分区的磁盘名称。

- `gdisk`命令还提供了一些其他的功能，例如在`GPT`分区表中添加、删除、移动、备份分区等。

  

```css
#选项
gdisk -l：列出所有硬盘的分区信息。
gdisk /dev/sda：打开硬盘sda的分区管理器，可以执行创建、删除、修改分区等操作。
p：打印出分区表信息。
n：创建新分区。
d：删除一个分区。
w：保存并退出。
q：不保存并退出。
与fdisk类似，使用gdisk也需要以root权限或sudo权限运行
```

1. 创建一个新的GPT分区表：

```
sudo gdisk /dev/sda
```

2. 显示GPT分区表：

```
sudo gdisk -l /dev/sda
```

3. 向GPT分区表中添加一个新的分区：

```
sudo gdisk /dev/sda
n
<Enter>
<Enter>
+100M
EF00
w
```

1. 删除GPT分区表中的一个分区：

```
sudo gdisk /dev/sda
d
<Enter>
<分区号>
w
```

## tee

> `tee`命令可以把标准输入中的数据输出到标准输出和文件中，这样就可以在不破坏原有数据的前提下将数据输出到多个地方。

使用tee命令的格式如下：

```
tee [选项] [文件]
或者
command | tee [-a] file1 [file2 ...]
其中，command是一个命令或者一系列命令，用于产生数据。管道符“|”表示将command的标准输出传递给tee命令。-a选项表示在文件中追加数据，而不是覆盖原有数据。file1、file2等是文件名，表示将数据输出到这些文件中。
```

常用选项有：

- -a：追加数据到文件末尾。
- -i：忽略中断信号。

举个例子，你可以这样使用tee命令:

```
echo "hello" | tee output.txt
ls | tree output.txt
```

这条命令会将字符串"hello"输出到标准输出和文件output.txt中。

如果你想追加数据到文件末尾，可以使用-a选项：

```
echo "world" | tee -a output.txt
```

这条命令会将字符串"world"追加到文件output.txt的末尾。

1. 追加数据到文件

```
ps aux | tee -a processes.txt
这个命令将列出当前正在运行的进程并将其输出到processes.txt文件中，如果processes.txt文件已经存在，则会将新数据追加到文件的末尾。
```

1. 多个文件同时输出

```
dmesg | tee errors.txt messages.txt
这个命令将dmesg命令的输出同时输出到errors.txt和messages.txt文件中，可以将多个文件名作为tee命令的参数。
```

## dmesg

> `dmesg`是一个Linux命令，用于打印内核环缓冲区的内容，包括内核启动信息、硬件检测结果、驱动程序加载信息、系统调用和中断的相关信息等。通过执行dmesg命令，可以获取到内核运行期间发生的重要事件和错误信息，有助于诊断系统问题和进行故障排除。

下面是一些常用的dmesg命令选项：

- -h或--help：显示帮助信息。
- -n<level>或--console-level=<level>：设置内核消息的输出级别。
- -s<size>或--buffer-size=<size>：设置内核环缓冲区的大小。
- -t或--ctime：输出的时间戳使用可读性更高的日期时间格式。
- -w或--follow：实时监视内核环缓冲区的输出。

1. 显示内核环缓冲区的全部内容

```
dmesg
```

1. 显示最近的20行内核消息

```
dmesg | tail -n 20
```

1. 搜索包含指定关键字的内核消息

```
dmesg | grep -i "error"
```

1. 显示可读性更高的日期时间格式

```
dmesg -t
```

1. 实时监视内核环缓冲区的输出

```
dmesg -w
```

## tail

> `tail`用于显示文件的末尾若干行内容。通常用于查看日志文件和其他不断增长的文件的内容。tail命令默认输出文件的末尾10行，可以通过选项来指定输出的行数。
>
> 需要注意的是，`head`命令和`tail`命令都可以用来查看文件内容的一部分，它们之间的主要区别在于`head`命令默认显示文件的开头部分，而`tail`命令默认显示文件的末尾部分。

下面是一些常用的tail命令选项：

- -f或--follow：实时跟踪文件的变化，并输出新增的内容。
- -n <行数>或--lines=<行数>：指定要输出的行数。
- -c <字节数>或--bytes=<字节数>：指定要输出的字节数。
- -q或--quiet：不显示文件名头信息。

下面是一些tail命令的示例：

1. 显示文件末尾10行内容：

```
tail /etc/fstab
```

1. 显示文件末尾20行内容：

```
tail -n 20 /etc/httpd/conf/httpd.conf
```

上述命令表示输出文件的末尾20行内容。而如果加上`-n +<number>`的选项，则表示从文件的第`<number>`行开始输出直到文件末尾的所有内容，例如：

```
tail -n +11 /etc/httpd/conf/httpd.conf
```

上述命令表示从文件的第11行开始输出所有的内容。

需要注意的是，`-n +<number>`选项只能用于GNU版本的`tail`命令，不能用于一些较老版本的`tail`命令。在一些较老版本的`tail`命令中，如果要输出从某行开始的内容，可以使用`sed`命令来实现，例如：

```
sed -n '11,$p' /etc/httpd/conf/httpd.conf
```

上述命令表示输出文件的第11行到最后一行的所有内容。其中`-n`选项表示只输出指定的行数，`11,$`表示从第11行到最后一行，`p`表示输出匹配的行

1. 实时跟踪文件的变化：

```
tail -f /var/log/messages
```

1. 不显示文件名头信息：

```
tail -q /etc/fstab /etc/redhat-release
#正常情况下
==> /etc/fstab <==
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=ad19dd45-b7ee-485c-87e6-3c9bb8ec3996 /                       xfs     defaults        0 0
UUID=8fbb4a9c-1506-4c4a-889d-b78163091bb0 /boot                   ext4    defaults        1 2
UUID=933c390a-5904-4b01-aa6a-447c771b7f08 /data                   xfs     defaults        0 0
#UUID=98f53a44-1fb7-4139-85c6-a3c2d1633cd7 none                    swap    defaults        0 0
UUID=430542b8-0e56-4316-8e49-e937b8b682f5 /data/mysql             ext4    defaults        0 0
#UUID=2a9d6777-78de-4af3-9b97-0ba31db1c95c none                    swap    pri=55       0 0
/data/swapfile                                  none                   swap     defaults        0 0

==> /etc/redhat-release <==
CentOS Linux release 8.5.2111.990713

加上-q以后
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=ad19dd45-b7ee-485c-87e6-3c9bb8ec3996 /                       xfs     defaults        0 0
UUID=8fbb4a9c-1506-4c4a-889d-b78163091bb0 /boot                   ext4    defaults        1 2
UUID=933c390a-5904-4b01-aa6a-447c771b7f08 /data                   xfs     defaults        0 0
#UUID=98f53a44-1fb7-4139-85c6-a3c2d1633cd7 none                    swap    defaults        0 0
UUID=430542b8-0e56-4316-8e49-e937b8b682f5 /data/mysql             ext4    defaults        0 0
#UUID=2a9d6777-78de-4af3-9b97-0ba31db1c95c none                    swap    pri=55       0 0
/data/swapfile                                  none                   swap     defaults        0 0
CentOS Linux release 8.5.2111.990713
```

1. 显示文件末尾1000字节内容：

```
tail -c 1000 /etc/fstab
```

## head

> `head`是一个常用的Linux命令，它用于显示文本文件的开头若干行。默认情况下，`head`命令显示文件的前10行。`head`命令的基本语法为：

```
head [OPTION]... [FILE]...
```

其中`OPTION`是一些可选的命令选项，`FILE`是要查看的文件名。

`head`命令常用的选项如下：

- `-n NUM`：指定要显示的行数。例如，`head -n 5 file.txt`表示显示文件`file.txt`的前5行。
- `-q`：不显示文件名。当同时显示多个文件的内容时，使用该选项可以只显示文件内容，不显示文件名。
- `-v`：显示文件名。当同时显示多个文件的内容时，使用该选项可以在每个文件的内容前面显示文件名。
- `-c NUM`：指定要显示的字节数。例如，`head -c 1024 file.txt`表示显示文件`file.txt`的前1024个字节。
- `-z`：将多个文件的内容视为单个文件来处理。如果多个文件的内容是以null字符分隔的，那么使用该选项可以将它们视为一个文件来处理。
- `--help`：显示`head`命令的帮助信息。
- `--version`：显示`head`命令的版本信息。

下面是一些`head`命令的使用示例：

1. 显示文件`file.txt`的前10行：

```
head file.txt
```

1. 显示文件`file.txt`的前20行：

```
head -n 20 file.txt
```

上述命令表示输出文件的开头20行内容。而如果加上`-n -<number>`的选项，则表示从文件的第`<number>`行开始输出直到`<number>`之间的内容，

则表示从文件的开头开始，显示除了最后N行之外的所有行，需要注意的是，如果文件的行数少于指定的负数值，那么`head`命令将会显示整个文件的内容，并且不会报错

例如：

```
head -n -20 file.txt
```

输出开头到20行之前的内容，20行后不输出

1. 显示多个文件的内容，同时不显示文件名：

```
head -q file1.txt file2.txt file3.txt
```

1. 显示多个文件的内容，同时显示文件名：

```
head -v file1.txt file2.txt file3.txt
```

## head和tail的区别

> `head`命令和`tail`命令都支持在`-n`选项后面指定正负数，它们的含义略有不同。

- 对于`head`命令，`-n +N`表示显示文件的第N行及其之后的所有行，而`-n -N`是无效的选项。
- 对于`tail`命令，`-n +N`和`-n N`表示显示文件的第N行及其之后的所有行，而`-n -N`表示显示文件的末尾部分，去除文件末尾的N行。例如，`tail -n -5 file.txt`表示显示`file.txt`文件除了最后5行之外的所有行。

在`head`命令和`tail`命令中，如果不指定`+`或`-`符号，则默认使用`+`符号，表示显示指定行号或字节数后面的内容

## tr

> `tr`是一个用于字符转换和删除的命令。它可以用来对输入的文本进行一些简单的字符操作，如替换、删除、压缩等

以下是`tr`命令的基本语法：

```css
tr [OPTION]... SET1 [SET2]
```

其中，`OPTION`是可选的，用于指定一些选项；`SET1`和`SET2`是必须的，分别表示要进行转换的字符集和转换后的字符集。

以下是`tr`命令的一些常用选项：

- `-c`：用`SET1`中未包含的字符来替换文本中的字符。
- `-d`：删除文本中包含的`SET1`中的字符。
- `-s`：压缩文本中相邻的重复字符，只保留一个。
- `-t`：用`SET2`中的字符来替换`SET1`中的字符。

以下是一些`tr`命令的示例：

1. 将文本中的小写字母转换成大写字母

```css
$ echo "hello, world" | tr '[:lower:]' '[:upper:]'
HELLO, WORLD
```

2. 删除文本中的空格：

```css
$ echo "hello,    world" | tr -d ' '
hello,world
```

3. 压缩文本中的重复字符：(相当于去重)

```css
$ echo "hello, world" | tr -s 'l'
helo, world
```

4. 将文本中的数字替换为`#`：

```css
$ echo "123456" | tr '[:digit:]' '#'
######
```

5. 保留文本中的指定字符：

```css
$ echo "hello, world" | tr -c '[:alpha:]' '\n'
hello
world
```

这个命令使用 `-c` 选项来保留 `SET1` 中的字符，删除其他字符，然后用换行符替换删除的字符。

6. 在文本中插入换行符：

```css
$ echo "hello, world" | tr -s ' ' '\n'
hello,
world
```

这个命令使用 `-s` 选项来压缩相邻的空格，然后用换行符替换每个空格。

7. 将文本中的字符替换为其 ASCII 编码值：

```css
$ echo "hello, world" | tr '[:print:]' '[\000-\177]'
\150\145\154\154\157\054\040\167\157\162\154\144
```

这个命令使用 `[:print:]` 来表示所有可打印字符，然后将这些字符替换为其 ASCII 编码值。

在 `tr` 命令中，`[:lower:]` 是一种字符集合，用于匹配所有小写字母。类似的字符集合还有很多，以下是一些常用的字符集合：

- `[:upper:]`：匹配所有大写字母。
- `[:alpha:]`：匹配所有字母，包括大小写。
- `[:digit:]`：匹配所有数字。
- `[:alnum:]`：匹配所有字母和数字，包括大小写。
- `[:punct:]`：匹配所有标点符号。
- `[:space:]`：匹配所有空白字符，包括空格、制表符和换行符。
- `[:print:]`：匹配所有可打印字符。

在 `tr` 命令中，字符集合用方括号括起来，例如 `[:lower:]` 表示小写字母集合。可以使用这些字符集合来定义 `SET1` 或 `SET2`，从而对文本进行转换。

以下是一些 `tr` 命令示例，演示如何使用字符集合：

1. 将所有小写字母转换为大写字母：

```css
$ echo "hello, world" | tr '[:lower:]' '[:upper:]'
HELLO, WORLD
```

2. 从文本中删除所有标点符号：

```css
$ echo "Hello, World!" | tr -d '[:punct:]'
Hello World
```

这个命令使用 `-d` 选项删除所有匹配到的标点符号。

3. 将文本中的空格转换为换行符：

```css
$ echo "Hello, World" | tr ' ' '\n'
Hello,
World
```

这个命令使用空格作为 SET1，使用换行符作为 SET2。

## stress

> `stress` 是一个用于模拟系统负载的工具。它可以帮助你测试系统在高负载下的稳定性和性能，以及评估系统资源的使用情况。

以下是 `stress` 命令的基本语法：

```css
stress [OPTION]...
```

其中，`OPTION` 是可选的，用于指定一些选项。

以下是一些常用的 `stress` 命令选项：

- `-c N`：指定要创建的 CPU 负载数量。
- `-d N`：指定要创建的磁盘 I/O 负载数量。
- `-m N`：指定要创建的内存负载数量。
- `-i N`：指定要创建的 I/O 负载数量。
- `-t TIME`：指定要运行 `stress` 的时间。
- `-v`：输出详细的运行日志。
- `-q`：不输出运行日志。
- `--cpu N`：指定 CPU 负载占用率，例如 `--cpu 8` 表示将所有 CPU 核心使用率提升至 80%。
- `--io N`：指定 I/O 负载占用率。
- `--vm N`：指定内存负载占用率。

以下是一些 `stress` 命令的示例：

1. 创建 8 个 CPU 负载：

```R
$ stress -c 8
```

这个命令会创建 8 个 CPU 负载，使用所有可用的 CPU 核心。

2. 创建 4 个磁盘 I/O 负载：

```ruby
$ stress -d 4
```

这个命令会创建 4 个磁盘 I/O 负载，使用默认的块大小和文件名。

3. 创建 2 个内存负载：

```css
$ stress -m 2
```

这个命令会创建 2 个内存负载，每个负载使用 50% 的系统内存。

4. 创建 2 个内存负载：

```css
$ stress -i 1
```

这个命令会创建 1 个 I/O 负载，使用默认的块大小和文件名。

5. 创建 4 个 CPU 负载，并限制每个负载使用 50% 的 CPU 核心：

```css
$ stress --cpu 4 --cpu-load 50
```

这个命令会创建 4 个 CPU 负载，并限制每个负载使用 50% 的 CPU 核心。

6. 通过 `--vm` 选项使用虚拟内存模式`stress` 命令可以模拟虚拟内存的使用情况。通过 `--vm` 选项，可以指定要使用的虚拟内存大小和数量。例如，以下命令将在系统上创建一个 1GB 大小的虚拟内存：

```css
$ stress --vm 1 --vm-bytes 1G
```

7. 通过 `--io` 选项使用磁盘 I/O 模式`stress` 命令可以模拟磁盘 I/O 操作，通过 `--io` 选项指定要使用的 I/O 操作数量和类型。例如，以下命令将在系统上创建一个 4KB 大小的随机文件，并进行 10 次读取和写入操作：

```css
$ stress --io 10 --hdd 1 --hdd-bytes 4K
```

8. 通过 `--cpu` 选项使用 CPU 模式`stress` 命令可以模拟 CPU 负载。通过 `--cpu` 选项，可以指定要使用的 CPU 数量和工作线程数量。例如，以下命令将在系统上创建 8 个线程，每个线程使用 50% 的 CPU 资源：

```css
$ stress --cpu 8 --cpu-load 50
```

9. 通过 `--timeout` 选项设置持续时间默认情况下，`stress` 命令会一直运行，直到用户手动停止。但是可以通过 `--timeout` 选项指定运行时间。例如，以下命令将在系统上模拟 1 分钟的 CPU 负载：

```css
$ stress --cpu 8 --cpu-load 50 --timeout 60s

```

10. 当初做swap测试的时候用到一条命令

```css
sudo stress --vm 1 --vm-bytes 8G --timeout 30s
```

其中，`--vm` 参数表示要生成占用内存的进程，`--vm-bytes `参数表示每个进程所占用的内存大小，-`-timeout`参数表示测试的时长。这个命令会在30秒内让系统生成一个占用2GB内存的进程，观察期间内存和交换分区的使用情况即可。

## wc

> `wc` 命令是一个用于计算文件或标准输入中字符数、单词数和行数的 Linux 命令行工具。它通常用于对文本文件进行分析，以便进行文本处理、分析和编辑。下面是 `wc` 命令的常用选项和使用示例：

常用选项

- `-c` 或 `--bytes`：仅计算文件中的字节数。
- `-w` 或 `--words`：仅计算文件中的单词数。
- `-l` 或 `--lines`：仅计算文件中的行数。
- `-m` 或 `--chars`：仅计算文件中的字符数，其中一个多字节字符被计为一个字符。
- `-L` 或 `--max-line-length`：计算文件中最长行的字符数。
- `-help`：显示帮助信息。
- `-version`：显示 `wc` 命令的版本信息

使用示例

1. 计算文件的行数、单词数和字符数：

```css
$ wc filename
```

示例输出：

```css
 14  79 473 filename
```

输出中，第一列是行数、第二列是单词数、第三列是字符数，最后一列是文件名。

2. 统计多个文件的行数、单词数和字符数：

```css
$ wc file1 file2 file3
```

示例输出：

```css
 14  79 473 file1
  9  52 308 file2
 28 177 781 file3
 51 308 1562 total
```

输出中，最后一行是所有文件的总计数。

3. 统计目录下所有文件的行数、单词数和字符数：

```
$ wc -l -w -c *
```

示例输出：

```css
      4       48     1033 file1.txt
      6       44      237 file2.txt
      3       18      135 file3.txt
     13      110     1405 total
```

输出中，第一列是行数、第二列是单词数、第三列是字符数，最后一列是文件名或目录名。

## cut

> `cut` 命令是 Linux 操作系统中的一个文本处理工具，可以用来从文本文件或标准输入中剪切出指定列。常用于处理大型日志文件和数据文件等。下面是 `cut` 命令的常用选项和使用示例：

基本用法

```css
cut [options] filename
```

* `filename`：指定要处理的文件名。

常用选项

- `-d`：指定分隔符，默认为制表符。
- `-f`：指定要提取的列数，可以同时指定多列，列数之间使用逗号分隔。
- `-c`：指定要提取的字符范围，如 `1-4,7` 表示提取第 1 到 4 个字符和第 7 个字符。
- `-n`：取消分割多字节字符。
- `--complement`：输出选定列之外的列。
- `--output-delimiter`：指定输出的分隔符。
- `--help`：显示帮助信息。
- `--version`：显示 `cut` 命令的版本信息。

1. 从文件中提取指定的字符：

```css
$ cut -c 1-5 filename.txt
```

示例输出：

```css
hello
world
```

输出中，`-c 1-5` 表示提取第 1 到第 5 个字符。

2. 从文件中提取指定的字段：

```css
$ cut -f 1,3 -d "," filename.txt
```

示例输出：

```css
apple,red
pear,green
```

输出中，`-f 1,3` 表示提取第 1 到第 3 个字段，`-d ","` 表示字段的分隔符为逗号。

3. 从文件中提取指定的字段：

```css
$ cut -c 1-5 --complement filename.txt
``
```

4. 提取文件的第一列

```css
$ cut -f 1 filename
```

示例输出：

```css
column1
row1_data1
row2_data1
row3_data1
...
```

输出中，只包含文件的第一列。

5. 提取文件的第一列和第三列

```css
$ cut -f 1,3 filename
```

示例输出：

```css
column1   column3
row1_data1 row1_data3
row2_data1 row2_data3
row3_data1 row3_data3
...
```

输出中，只包含文件的第一列和第三列。

6. 提取文件的第二列到第四列

```css
$ cut -f 2-4 filename
```

示例输出：

```css
column2   column3   column4
row1_data2 row1_data3 row1_data4
row2_data2 row2_data3 row2_data4
row3_data2 row3_data3 row3_data4
...
```

输出中，只包含文件的第二列到第四列。

7. 提取文件的第一行

```css
$ head -n 1 filename | cut -f 2-4
```

示例输出：

```css
column2   column3   column4
```

输出中，只包含文件的第一行的第二列到第四列。

8. 以冒号为分隔符提取文件的第二列和第四列

```css
$ cut -d : -f 2,4 filename
```

示例输出：

```css
row1_data2:row1_data4
row2_data2:row2_data4
row3_data2:row3_data4
...
```

9. 以空格为分隔符提取文件的第一列

```css
$ cut -d " " -f 1 filename
```

示例输出:

```css
column1
row1_data1
row2_data1
row3_data1
...
```

10. 取消分割多字节字符，以字节数统计字符数

```css
$ cut -b -f 1 filename
```

使用 `-b` 选项取消分割多字节字符。

11. 输出选定列之外的列

```css
$ cut --complement -f 2 filename
```

使用 `--complement` 选项。

12. 指定输出的分隔符

```css
$ cut -d " " --output-delimiter="," -f 2-4 filename
```

示例输出：

```css
column2,column3,column4
row1_data2,row1_data3,row1_data4
row2_data2,row2_data3,row2_data4
row3_data2,row3_data3,row3_data4
...
```

输出中，输出的分隔符为逗号 `,`，使用 `--output-delimiter` 选项指定。

## locate

> `locate` 是 Linux 系统中的一个命令行工具，用于快速搜索文件系统中的文件。相比于 `find` 命令，`locate` 命令速度更快，因为它是基于索引的，而不是对文件系统进行实时搜索。

`locate` 命令使用一个叫做数据库的文件列表来记录文件系统中的文件路径，每次执行 `locate` 命令时，它会在这个列表中进行搜索，而不是对整个文件系统进行搜索。这使得 `locate` 命令的搜索速度比 `find` 命令快很多。

下面是 `locate` 命令的一些常见用法:

1. 搜索指定文件名的文件：

```css
locate filename

eg:
locate myfile.txt
该命令会搜索文件系统中所有包含 myfile.txt 的文件，并输出它们的路径
```

2. 使用通配符搜索：

```css
locate pattern

eg:
locate *.txt
该命令会搜索文件系统中所有以 .txt 结尾的文件，并输出它们的路径。
```

3. 搜索特定目录：

```css
locate -r '/path/to/directory/*'

eg:
locate -r '/home/user/*.txt'
该命令会搜索 /home/user 目录下所有以 .txt 结尾的文件，并输出它们的路径。
```

4. 更新数据库：

```css
sudo updatedb
```

`locate` 命令使用一个数据库来存储文件路径信息，如果文件系统中的文件被添加、删除或移动，那么数据库中的信息就会过时。为了让 `locate` 命令搜索结果更准确，我们需要定期更新数据库。使用 `updatedb` 命令可以更新数据库。

需要注意的是，由于 `locate` 命令使用的是基于索引的搜索方式，所以可能会出现搜索结果不准确的情况。如果需要进行精确的文件搜索，建议使用 `find` 命令。

## lsof

lsof（List Open Files）是一个用于列出当前系统中打开文件的工具，包括网络套接字、管道、FIFO、设备文件等等。lsof 可以帮助系统管理员和开发者定位文件相关问题，例如文件泄露、文件被占用、文件权限等等。

lsof 命令的基本语法如下：

```css
lsof [options]
```

其中，options 是可选参数，用于指定不同的输出格式和查询条件。常用的 options 包括：

- `-a`：表示“and”，表示同时满足多个查询条件；
- `-c`：指定进程名或进程 ID；
- `-i`：指定网络端口或地址；
- `-p`：指定进程 ID；
- `-u`：指定用户名；
- `-w`：表示“or”，表示满足多个查询条件中的任意一个；
- `-F`：指定输出格式，例如 `-F p` 表示只输出进程 ID。

列出所有打开的文件：

```css
lsof
```

列出指定进程打开的文件：

```css
lsof -p PID
```

列出指定用户打开的文件：

```css
lsof -u USERNAME
```

列出指定端口或地址的网络连接：

```css
lsof -i TCP:PORT
lsof -i TCP@IP:PORT
```

其中，TCP 表示协议类型，PORT 表示端口号，IP 表示 IP 地址。

lsof 命令的输出信息包含大量的字段，其中一些常见的字段包括：

- COMMAND：进程名或进程 ID；
- PID：进程 ID；
- USER：用户名；
- FD：文件描述符，指定文件的打开方式，例如 `cwd` 表示当前工作目录，`txt` 表示可执行文件，`mem` 表示内存映像文件；
- TYPE：文件类型，例如 `REG` 表示普通文件，`DIR` 表示目录，`CHR` 表示字符设备，`FIFO` 表示命名管道；
- DEVICE：设备号；
- SIZE/OFF：文件大小或偏移量；
- NODE：文件的 inode 号；
- NAME：文件名或路径；
- PID/TID：线程 ID。

下面是一些常见的输出信息和其含义：

```css
COMMAND     PID   USER  FD   TYPE  DEVICE  SIZE/OFF  NODE     NAME
nginx       123   root  12u  IPv4  1234    0t0       TCP      *:80 (LISTEN)
nginx       123   root  13u  IPv6  1234    0t0       TCP      *:80 (LISTEN)
nginx       123   root  14u  IPv4  5678    0t0       TCP      *:443 (LISTEN)
httpd       345   apache  3u  IPv4  1234    0t0       TCP      example.com:http->192.168.1.1:54123 (ESTABLISHED)
mysqld     4567   mysql  5u  REG   1234    100      5678     /var/lib/mysql/dbname/table.frm
python    12345   root   3r  FIFO  1234    0t0       pipe     '/tmp/mypipe'
```

- 对于网络连接，NAME 列包含了远程主机的 IP 地址和端口号，格式为“本地地址:本地端口号->远程地址:远程端口号 (状态)”。
- 对于普通文件，NAME 列显示文件名或完整路径。
- 对于设备文件和特殊文件，NAME 列包含了设备号和文件名，格式为“设备号:文件名”。
- 对于管道和 FIFO，NAME 列包含了文件名或完整路径，以单引号括起来。

FD 列指示了文件的打开方式，包含以下常见的值：

- `cwd`：表示当前工作目录（current working directory）。
- `txt`：表示可执行文件或共享库文件。
- `mem`：表示内存映像文件。
- `REG`：表示普通文件。
- `DIR`：表示目录。
- `CHR`：表示字符设备。
- `BLK`：表示块设备。
- `FIFO`：表示命名管道。
- `SOCK`：表示网络套接字。

lsof 还可以输出指定格式的信息，使用 `-F` 参数可以指定输出格式。例如，使用 `-F p` 只输出进程 ID，使用 `-F n` 只输出文件名。更多格式参考 `man lsof` 的 OUTPUT FOR OTHER PROGRAMS 一节。

查找被哪个进程占用了某个文件：

```css
lsof /path/to/file
```

查找哪个进程使用了最多的文件句柄：

```css
lsof | awk '{print $2}' | sort | uniq -c | sort -nr | head
```

查找哪个进程使用了最多的网络连接：

```css
lsof -i | awk '{print $1}' | sort | uniq -c | sort -nr | head
```

查找哪个进程占用了某个端口：

```css
lsof -i :PORT
```

查找哪些进程正在使用某个目录：

```css
lsof +D /path/to/directory
```

查找哪些进程使用了某个共享库：

```css
lsof /path/to/shared/library
```

查看哪些文件被多个进程共享：

```css
lsof | awk '{if($2 != "") print $2}' | sort | uniq -d | xargs ps -p
```

查看哪些进程没有打开任何文件：

```css
ps -eo pid | grep -v PID | xargs -I{} sh -c 'lsof -p {} >/dev/null || echo {}'
```

查看哪些进程没有正常退出：

```css
ps axo pid,command,stat | awk '$3 != "Z" && $2 != "ps" && $2 != "awk" && $2 != "lsof" {print}'
```

查看哪些进程使用了大量的虚拟内存：

```css
ps axo pid,command,rss,vsz | awk '{if($3/$4 > 0.5) print}'
```

## find

> `find` 命令是 Linux 系统中常用的一个用于搜索文件和目录的工具，可以根据各种条件搜索指定目录下的文件和子目录，非常强大。

`find` 命令的基本语法如下:

```css
find [path] [expression]

#参数
-type：按文件类型进行查找。例如，-type f 表示查找普通文件，-type d 表示查找目录，-type l 表示查找符号链接。
-name 和 -iname：按照文件名进行查找，其中 -name 区分大小写，-iname 不区分大小写。
-size：按照文件大小进行查找，可以使用 + 和 - 来指定大小的范围。例如，-size +10M 表示查找大小大于 10MB 的文件，-size -1G 表示查找大小小于 1GB 的文件。
-mtime 和 -ctime：按照文件修改时间和创建时间进行查找。例如，-mtime -7 表示查找最近 7 天内修改过的文件，-ctime +30 表示查找创建时间超过 30 天的文件。
-exec：对查找到的文件执行指定的命令。例如，-exec rm {} \; 表示对每个查找到的文件执行 rm 命令。
-regex：按照正则表达式进行查找。
-prune：排除某些目录或文件不进行查找。
-maxdepth 和 -mindepth：限制查找的深度。例如，-maxdepth 2 表示查找到目录的深度不超过 2。
-user 和 -group：按照文件所属用户和组进行查找。
-print：将查找到的文件名输出到标准输出。
```

其中，`path` 表示要搜索的路径，可以是相对路径或绝对路径；`expression` 是搜索的条件表达式，可以使用一些逻辑运算符连接多个条件。

下面介绍一些常用的 `find` 命令选项和表达式：

1. 按文件名搜索

使用 `-name` 选项可以按文件名搜索，可以使用通配符 `*` 和 `?`，例:

```css
find /path/to/dir -name "file.txt"
find /path/to/dir -name "*.txt"
find /path/to/dir -name "file?.txt"
```

2. 按文件类型搜索

使用 `-type` 选项可以按文件类型搜索，常用的文件类型有：

- `f`：普通文件
- `d`：目录
- `l`：符号链接
- `s`：套接字文件
- `b`：块设备文件
- `c`：字符设备文件

例如：

```css
find /path/to/dir -type f    # 搜索普通文件
find /path/to/dir -type d    # 搜索目录
find /path/to/dir -type l    # 搜索符号链接
```

3. 按文件大小搜索

使用 `-size` 选项可以按文件大小搜索，可以指定大小的单位，常用的单位有：

- `c`：字节
- `k`：千字节
- `M`：兆字节
- `G`：吉字节

可以使用 `+` 表示大于等于指定大小，使用 `-` 表示小于等于指定大小，例如：

```css
find /path/to/dir -size +10M    # 搜索大小大于 10M 的文件
find /path/to/dir -size -100k   # 搜索大小小于等于 100k 的文件
```

4. 按时间戳搜索

使用 `-mtime`、`-ctime` 或 `-atime` 选项可以按文件的修改时间、创建时间或访问时间搜索，可以指定时间的单位，常用的单位有：

- `d`：天
- `m`：月（30 天）
- `w`：周（7 天）

可以使用 `+` 表示时间在指定时间之前，使用 `-` 表示时间在指定时间之后，例如：

```css
find /path/to/dir -mtime +7    # 搜索修改时间在 7 天之前的文件
find /path/to/dir -ctime -1   # 搜索创建时间在 1 天之内的文件
find /path/to/dir -atime 0    # 搜索访问时间在当天内的文件
```



## sort

> `sort` 命令是 Linux 中常用的文本排序工具，用于对文件中的文本进行排序。`sort` 命令可以按照多种方式进行排序，包括按照字母顺序、数字顺序、空格分隔的列、指定字段等。

下面是 `sort` 命令的基本用法：

```css
sort [options] [input_file]
```

`sort` 命令常用的选项有：

- `-r`：按照逆序排列。
- `-n`：按照数字顺序排列。
- `-k`：按照指定字段进行排序。
- `-t`：指定字段分隔符。
- `-u`：去重，去除重复的行。
- `-c`：检查文件是否已经按照指定的方式排序。

下面是一些示例：

1. 按照字母顺序排序：

```css
$ sort filename
```

2. 按照数字顺序排序：

```css
$ sort -n filename
```

3. 按照指定字段排序：

```css
$ sort -t ":" -k 3 filename
```

表示以冒号为分隔符，按照第 3 个字段排序。

4. 检查文件是否已经按照指定的方式排序：

```css
$ sort -c filename
```

如果文件已经按照指定的方式排序，则不输出任何信息；否则会提示文件未排序。

5. 去除重复的行：

```css
$ sort -u filename
```

6. 按照多个字段排序:

```css
$ sort -t ":" -k 1,2 filename
```

表示以冒号为分隔符，先按照第 1 个字段排序，如果第 1 个字段相同，则按照第 2 个字段排序。

7. 忽略空格和特殊字符：

```css
$ sort -b filename
```

忽略行首的空格字符，并按照字母顺序排序。

8. 按照文件中的随机顺序排序：

```css
$ sort -R filename
```

按照随机顺序排序文件中的文本行。

9. 按照人类可读的格式进行排序：

```css
$ sort -h filename
```

按照人类可读的格式进行排序，例如按照 K、M、G 等单位大小进行排序。

10. 按照本地化规则排序：

```css
$ sort -f filename
```

按照本地化规则进行排序，忽略大小写。

## tac

> 在Linux中，tac命令是一种文本处理工具，它用于反转（倒序）文本文件的行顺序。tac命令的功能与cat命令类似，但是它是按照从后往前的顺序输出文件内容。以下是一些关于tac命令的详细信息：

tac命令的基本语法如下：

```css
tac [选项] 文件名
```

其中，选项包括：

- -b, --before：在每行输出之前添加定界符。
- -s, --separator=字符串：使用指定的字符串作为定界符，而不是默认的换行符。
- --help：显示命令帮助信息。
- --version：显示命令版本信息

1. 反转文件内容

```css
tac 文件名
```

2. 在每行输出之前添加定界符

使用tac命令在每行输出之前添加定界符的语法格式为:

```css
tac -b 文件名
```

3. 使用指定的字符串作为定界符

使用tac命令使用指定的字符串作为定界符的语法格式为:

```css
tac -s 字符串 文件名
```

例如，反转名为test.txt的文件的内容，并使用定界符"|"代替默认的换行符，可以执行以下命令：

```css
tac -s "|" test.txt
```

4. 结合其他命令使用

tac命令可以结合其他命令使用，例如与grep、awk、sed等命令一起使用。

例如，反转名为test.txt的文件的内容，然后使用grep命令过滤包含特定字符串的行，可以执行以下命令

```css
tac test.txt | grep "特定字符串"
```

## nl

> 在Linux中，nl命令是一种文本处理工具，它用于给文本文件的每一行添加行号。nl命令可以按照行号的格式输出文件内容，并可以指定不同的行号格式、行号宽度、是否对空白行进行行号计算等。以下是一些关于nl命令的详细信息

nl命令的基本语法如下：

```css
nl [选项] 文件名
```

其中，选项包括：

- -b样式：指定行号样式，可选值为a、t、n，分别表示不对空白行计算行号、只对文本行计算行号、对所有行计算行号。
- -n：指定行号的起始值，即第一行的行号。
- -w：指定行号字段的宽度。
- -s：指定行号字段和文本之间的分隔符。
- --help：显示命令帮助信息。
- --version：显示命令版本信息。

1. 添加默认行号

使用nl命令添加默认行号的语法格式为

```css
nl 文件名
```

2. 指定行号样式

使用nl命令指定行号样式的语法格式为:

```css
nl -b 样式 文件名
```

其中，样式包括：

- a：不对空白行计算行号。
- t：只对文本行计算行号。
- n：对所有行计算行号

例如，给名为test.txt的文件添加行号，但不对空白行计算行号，可以执行以下命令:

```css
nl -b a test.txt
```

3. 指定行号起始值和字段宽度

使用nl命令指定行号起始值和字段宽度的语法格式为：

```css
nl -n 起始值 -w 宽度 文件名
```

例如，给名为test.txt的文件添加行号，起始值为10，字段宽度为4，可以执行以下命令：

```css
nl -n 10 -w 4 test.txt
```

4. 指定分隔符

使用nl命令指定分隔符的语法格式为：

```css
nl -s 分隔符 文件名
```

例如，给名为test.txt的文件添加行号，并使用"|"作为行号字段和文本之间的分隔符，可以执行以下命令：

```css
nl -s "|" test.txt
```

## rev

> 在Linux中，rev命令是一种文本处理工具，用于将文件中每一行的字符顺序颠倒，并将结果输出到标准输出流中。rev命令可以接受一个或多个文件作为输入，并逐行反转每个文件的内容。以下是一些关于rev命令的详细信息：

rev命令的基本语法如下：

```css
rev [选项] 文件名
```

其中，选项包括：

- `-V` 或 `--version`：显示版本信息
- `-h` 或 `--help`：显示帮助信息
- `-c` 或 `--characters`：将每个字符当做单独的文本行进行反转
- `-t` 或 `--tac`：反转文件中每行的顺序，类似于 tac 命令的功能

1. 反转文本文件中的每一行

使用rev命令反转文本文件中的每一行的语法格式为：

```css
rev 文件名
```

2. 反转多个文件中的每一行

使用rev命令反转多个文件中的每一行的语法格式为:

```css
rev 文件1 文件2 ...
```

3. 将反转结果输出到文件

使用rev命令将反转结果输出到文件的语法格式为:

```css
rev 文件名 > 输出文件名
```

4. 反转定界符分隔的字段

使用rev命令反转定界符分隔的字段的语法格式为：

```css
rev -d '定界符' 文件名
```

例如，反转名为test.txt的文件中每一行以"|"分隔的字段的字符顺序，可以执行以下命令：

```css
rev -d '|' test.txt
```

## uniq

> `uniq` 命令是 Linux 中常用的文本去重工具，用于去除文本文件中的重复行。`uniq` 命令只能去除连续出现的重复行，如果文本中出现非连续的重复行，则需要先使用 `sort` 命令进行排序。

下面是 `uniq` 命令的基本用法：

```css
uniq [options] [input_file]
```

`uniq` 命令常用的选项有：

- `-c`：显示每行出现的次数。
- `-d`：只显示重复的行。
- `-u`：只显示不重复的行。

下面是一些示例：

1. 去除重复的行：

```css
$ uniq filename
```

2. 显示每行出现的次数：

```css
$ uniq -c filename
```

3. 只显示重复的行：

```css
$ uniq -d filename
```

4. 只显示不重复的行：

```css
$ uniq -u filename
```

需要注意的是，`uniq` 命令只能去除连续出现的重复行。如果需要去除非连续的重复行，则需要先使用 `sort` 命令进行排序。例如：

```css
$ sort filename | uniq
```

该命令会先将文件中的文本行按照字典序排序，然后再使用 `uniq` 命令去除重复的行。

## paste

> `paste` 命令是 Linux 中常用的文本合并工具，用于将多个文件或文本流的内容合并成一列或一行。`paste` 命令会将多个文件或文本流中的内容按照列或行合并在一起，并以 TAB 或指定的分隔符分隔各列或各行的内容。

下面是 `paste` 命令的基本用法：

```css
paste [options] file1 file2 ...
```

`paste` 命令常用的选项有：

- `-d`：指定列或行之间的分隔符。
- `-s`：将多行合并成一行。
- `-z`：使用 NULL 作为分隔符。

下面是一些示例：

1. 将两个文件的内容合并成一列：

```css
$ paste file1 file2
```

2. 将两个文件的内容合并成一行：

```css
$ paste -s file1 file2
```

3. 指定列或行之间的分隔符：

```css
$ paste -d "," file1 file2
```

该命令会使用逗号作为列或行之间的分隔符。

4. 使用 NULL 作为分隔符：

```css
$ paste -z file1 file2
```

该命令会使用 NULL 作为列或行之间的分隔符。

5. 从标准输入中读取数据

`paste` 命令也可以从标准输入中读取数据，并将其合并成一列或一行。例如，将两个命令的输出合并成一行：

```css
$ ls | paste -s -d ","
```

该命令会将 `ls` 命令的输出和逗号合并成一行输出。

6. 处理多个文件中的数据

`paste` 命令还可以同时处理多个文件中的数据，并将其合并成一列或一行。例如，将多个文件中的数据按行合并：

```css
$ paste -d "\n" file1 file2 file3 ...
```

该命令会将 `file1`、`file2`、`file3` 等多个文件中的数据按行合并

7. 指定输出的行数

`paste` 命令可以使用 `-s` 选项指定输出的行数。例如，将多个文件的前三行合并成一行：

```css
$ head -n 3 file1 file2 file3 | paste -s -d " "
```

该命令会将 `file1`、`file2` 和 `file3` 文件的前三行合并成一行，并使用空格作为分隔符输出。其中，`head -n 3 file1 file2 file3` 命令会输出三个文件的前三行内容，`paste -s -d " "` 命令会将这些内容按列合并成一个文件，并使用空格作为分隔符输出。

8. 将多列文件转换为一列

如果有一个多列文件，想将它们转换为一列，可以使用 `paste` 命令结合 `awk` 命令实现，示例如下：

```css
$ paste file1 file2 file3 | awk '{ for (i=1; i<=NF; i++) print $i }' > output.txt
```

该命令将 `file1`、`file2` 和 `file3` 按列合并在一起，然后使用 `awk` 命令将各列内容逐行输出，最终结果保存到 `output.txt` 文件中。

9. 多行合并成一行

如果有多行文本需要合并成一行，可以使用 `paste` 命令的 `-s` 选项，示例如下：

```css
$ cat input.txt | paste -s -d " "
```

该命令将 `input.txt` 文件的多行内容合并成一行，并使用空格作为分隔符输出。

## du

> `du`是一个非常有用的命令，用于计算目录或文件的磁盘使用情况。当使用`du`命令计算目录大小时，它默认会递归计算子目录的大小，并且会显示每个文件和目录的大小。这在需要查找大文件或占用大量磁盘空间的目录时非常有用。`du`的完整命令格式如下：

```css
du [OPTION]... [FILE]...
```

`du`命令的一些常用选项包括：

- `-h`：以易于阅读的格式显示文件和目录的大小，例如使用KB、MB等单位。
- `-s`：仅显示指定目录或文件的总大小，而不显示子目录或文件的详细信息。
- `-c`：在计算目录或文件大小的同时，同时显示总大小。
- `-a`：显示所有文件和目录的大小，包括隐藏文件和目录。
- `-x`：仅计算当前文件系统中指定目录的大小，而不包括其他挂载的文件系统中的文件和目录。
- `-B`：指定文件和目录大小的块大小，默认情况下为1024字节。
- `-L`：在计算目录大小时，将符号链接视为常规文件而不是链接文件。
- `-D`：仅递归计算目录的深度，而不计算所有子目录的大小。
- `-x`：仅计算与指定目录在同一文件系统上的文件和目录的大小。这对于排除挂载的文件系统非常有用。
- `--exclude=PATTERN`：排除匹配指定模式的文件和目录，例如`--exclude=.git`将排除`.git`目录。

```bash
du：列出当前目录下所有文件和目录所占用的磁盘空间大小。默认以KB为单位。

du -h：以易于理解的方式列出文件和目录所占用的磁盘空间大小。会自动将大于1KB的文件和目录的大小转换成MB或GB为单位。

du -s：仅显示指定目录或文件所占用的磁盘空间总大小。

du -a：同时列出所有文件和目录所占用的磁盘空间大小。

du -c：列出所有文件和目录所占用的磁盘空间大小总和。

du -b：以字节为单位列出所有文件和目录所占用的磁盘空间大小。

du -d n：指定目录树的深度，n为深度值。例如，du -d 2将只显示当前目录和下一级子目录所占用的磁盘空间大小。

du --exclude：排除指定的目录或文件。例如，du --exclude=*.log将排除所有后缀为.log的文件。

#使用du时需要注意以下几点：

#du命令默认不包含符号链接所指向的文件或目录。如果需要包含符号链接的文件或目录，可以使用du -L命令。

#du命令默认只显示文件和目录的大小，不包括文件名或目录名。如果需要同时显示文件名或目录名，则可以使用du --si --time命令。

#du命令的输出结果包括了子目录下的所有文件和目录，因此如果需要统计某个目录下所有子目录的大小，可以使用du -h -d 1 | sort -hr命令。
```

例如，要查看当前目录中所有文件和子目录的大小，可以使用以下命令：

```bash
du -h
```

要查看指定目录或文件的大小，可以将目录或文件的路径作为`du`命令的参数。例如，要查看`/home/user`目录的大小，可以使用以下命令：

```css
du -h /home/user
```

要仅显示指定目录的总大小而不显示子目录或文件的详细信息，可以使用以下命令：

```css
du -sh /home/user
```

要同时显示指定目录和子目录的总大小，可以使用以下命令：

```css
du -c /home/user
```

例如，要计算当前目录及其子目录中的所有文件和目录的大小，但不包括挂载的文件系统和符号链接文件的大小，可以使用以下命令：

```css
du -shxL *
```

要仅计算当前目录下的所有子目录的大小，可以使用以下命令：

```css
du -shD *
```

要计算当前目录及其子目录中所有文件和目录的大小，但排除`.git`目录，可以使用以下命令：

```css
du -sh --exclude=.git *
```

## LVM

> LVM (Logical Volume Manager) 是 Linux 下一种磁盘分区管理工具，可以动态地管理磁盘分区。使用 LVM 可以方便地进行磁盘分区的管理和扩容，同时还支持磁盘快照和在线备份等功能。在Linux中，可以使用`LVM`（Logical Volume Manager）来动态地管理磁盘分区和逻辑卷。LVM可以将多个物理卷（PV）合并成一个卷组（VG），然后从卷组中创建逻辑卷（LV）。逻辑卷可以随时调整大小，而不会影响数据的完整性。

下面是使用 LVM 创建一个逻辑卷的过程及相应的命令：

1. 创建物理卷

使用 `pvcreate` 命令可以将物理磁盘设备或者分区划分为一个物理卷。例如，下面的命令将磁盘 `/dev/sdb` 划分为一个物理卷：

```css
# pvcreate /dev/sdb
```

2. 创建卷组

使用 `vgcreate` 命令可以将一个或多个物理卷划分为一个卷组。例如，下面的命令将名为 `vg0` 的卷组划分为刚刚创建的物理卷 `/dev/sdb`：

```css
# vgcreate vg0 /dev/sdb
```

3. 创建逻辑卷

使用 `lvcreate` 命令可以在一个卷组中创建逻辑卷。例如，下面的命令将在 `vg0` 卷组中创建一个名为 `mylv`、大小为 10GB 的逻辑卷：

```css
# lvcreate -n mylv -L 10G vg0
```

这个命令中 `-n` 选项指定逻辑卷的名称，`-L` 选项指定逻辑卷的大小。

4. 格式化逻辑卷

使用 `mkfs` 命令可以格式化逻辑卷。例如，下面的命令将 `mylv` 逻辑卷格式化为 `ext4` 文件系统：

```css
# mkfs.ext4 /dev/vg0/mylv
```

5. 挂载逻辑卷

使用 `mount` 命令可以将逻辑卷挂载到指定的挂载点。例如，下面的命令将 `mylv` 逻辑卷挂载到 `/mnt` 目录

```css
# mount /dev/vg0/mylv /mnt
```

在使用 LVM 进行磁盘分区管理时，需要先划分物理卷，再将物理卷划分为卷组，最后在卷组中创建逻辑卷。这样可以实现对磁盘分区的灵活管理。

另外，LVM 还有其他常用的命令，如 `pvdisplay`、`vgdisplay`、`lvdisplay` 等，可以用来查看物理卷、卷组和逻辑卷的详细信息

## fallocate

> `fallocate` 是一个 Linux 命令行工具，用于在文件系统上为文件预分配磁盘空间，以提高文件的性能和可靠性。它的主要作用是快速分配大量磁盘空间，而无需实际写入任何数据。在某些情况下，使用 `fallocate` 可以比 `dd` 命令更快地创建文件，因为它只涉及磁盘空间分配，而不涉及数据写入。

`fallocate` 命令的语法如下：

```css
fallocate [options] <filename>
```

其中，`<filename>` 是要分配空间的文件名，可以是相对路径或绝对路径。`options` 可以用于指定要分配的空间大小、类型等参数，常用的选项包括：

- `-l <size>`：指定要分配的空间大小。可以使用后缀 B, K, M, G, T 分别表示字节、千字节、兆字节、千兆字节、太字节。例如，`-l 1G` 表示分配1GB的空间。
- `-o <offset>`：指定要从文件的哪个位置开始分配空间，单位为字节。
- `-n`：告诉 `fallocate` 不要实际写入任何数据，只是分配磁盘空间。
- `--punch-hole <offset> <length>`：用于删除文件中指定范围内的数据，从而释放对应的磁盘空间。其中，`<offset>` 表示要删除的数据的起始偏移量，`<length>` 表示要删除的数据的长度。

需要注意的是，`fallocate` 命令只能在支持该操作的文件系统上使用，例如 ext4、XFS、Btrfs 等文件系统都支持 `fallocate` 命令，而 FAT32 和 NTFS 等文件系统则不支持。

例如，如果你需要创建一个大小为 10GB 的空文件，你可以使用以下命令：

```css
fallocate -l 10G /path/to/file
```

该命令会在 `/path/to/file` 路径下创建一个大小为 10GB 的空文件，这个过程比用 `dd` 命令创建同样大小的文件要快得多。

你也可以使用 `--punch-hole` 选项来删除文件中的一段数据，例如：

```css
fallocate --punch-hole 100M:500M /path/to/file
```

该命令会从 `/path/to/file` 文件中删除 100MB 到 500MB 这段范围内的数据，并释放对应的磁盘空间。

需要注意的是，使用 `fallocate` 命令创建的空文件只是分配了磁盘空间，文件中并没有实际写入任何数据。如果你想往文件中写入数据，你需要使用其他工具，例如 `dd` 命令或者 `echo` 命令等。

如果 `fallocate` 命令不可用，你也可以使用 `dd` 命令来创建文件：

```css
sudo dd if=/dev/zero of=/path/to/swapfile bs=1M count=<size in MB>
```

## tar

> 在 Linux 中，有多种打包压缩文件的工具，其中最常用的是 tar。`tar` 可以将多个文件或目录打包成一个 tar 文件，并可选用 gzip、bzip2、xz 等工具进行压缩

下面是 tar 命令的一些常用参数和选项：

1. `-c`：创建一个新的 tar 文件。
2. `-x`：从一个 tar 文件中提取文件。
3. `-f`：指定 tar 文件的文件名。
4. `-v`：显示 tar 文件中包含的文件列表。
5. `-z`：使用 gzip 进行压缩和解压缩。
6. `-j`：使用 bzip2 进行压缩和解压缩。
7. `-J`：使用 xz 进行压缩和解压缩。
8. `-C`：指定解压缩的目标目录。
9. `-t或--list` :列出备份文件的内容。

```css
#下面是一些常见的 tar 命令操作：
1.创建一个新的 tar 文件：tar -cvf archive.tar file1 file2 file3
该命令会创建一个名为 archive.tar 的 tar 文件，并将 file1、file2 和 file3 文件添加到该文件中。

2.查看 tar 文件的内容：tar -tvf archive.tar
该命令会列出 archive.tar 文件中包含的所有文件的名称和属性。

3.解压缩一个 tar 文件：tar -xvf archive.tar
该命令会将 archive.tar 文件中的所有文件解压缩到当前目录中。

4.解压缩一个 tar.gz 文件：tar -zxvf archive.tar.gz
该命令会将 archive.tar.gz 文件中的所有文件解压缩到当前目录中，并使用 gzip 进行解压缩。

5.解压缩一个 tar.bz2 文件：tar -jxvf archive.tar.bz2
该命令会将 archive.tar.bz2 文件中的所有文件解压缩到当前目录中，并使用 bzip2 进行解压缩。

6.解压缩一个 tar.xz 文件：tar -Jxvf archive.tar.xz
该命令会将 archive.tar.xz 文件中的所有文件解压缩到当前目录中，并使用 xz 进行解压缩。

7.将一个目录打包成 tar 文件：tar -cvf archive.tar dir/
该命令会将 dir/ 目录下的所有文件和子目录打包成 archive.tar 文件。

8.将一个目录打包成 tar.gz 文件：tar -czvf archive.tar.gz dir/
该命令会将 dir/ 目录下的所有文件和子目录打包成 archive.tar.gz 文件，并使用 gzip 进行压缩。

9.将一个目录打包成 tar.bz2 文件：tar -cjvf archive.tar.bz2 dir/
该命令会将 dir/ 目录下的所有文件和子目录打
```

## zip

> `zip` 是一个常用的 Linux 命令，用于将文件和目录打包成 ZIP 压缩文件格式。以下是 `zip` 命令的详细讲解：

`zip` 命令的基本格式如下：

```css
zip [options] zipfile files
```

其中，`options` 为可选参数，`zipfile` 为要创建的 ZIP 文件名，`files` 为要压缩的文件或目录列表。

 `zip` 命令的常用选项：

- `-r`: 递归地将目录下的所有子目录和文件都压缩到 ZIP 文件中。
- `-q`: 静默模式，不显示压缩进度和警告信息。
- `-j`: 压缩时不保留文件或目录的路径信息，只将文件本身压缩到 ZIP 文件中。
- `-m`: 压缩后删除原文件。
- `-u`: 只压缩更新或新增的文件。

1. 将文件夹 `example` 打包成 `example.zip`：

```css
zip -r example.zip example/
```

2. 将文件夹 `example` 打包成 `example.zip`，并使用静默模式：

```css
zip -rq example.zip example/
```

3. 将文件夹 `example` 打包成 `example.zip`，并去掉路径信息：

```css
zip -j example.zip example/*
```

4. 将文件夹 `example` 打包成 `example.zip`，压缩后删除原文件：

``` css
zip -rm example.zip example/
```

5. 将文件夹 `example` 打包成 `example.zip`，仅压缩新增或更新的文件：

```css
zip -ru example.zip example/
```

## gzip

> 在 Linux 中，`gzip` 是一种用于压缩文件的工具，它使用 Lempel-Ziv 算法（LZ77）和哈夫曼编码进行数据压缩。`gzip` 可以将单个文件压缩成 `.gz` 文件，也可以将多个文件打包成 `.tar.gz` 文件。下面是 `gzip` 命令的详细用法讲解：

`gzip` 命令可以用于压缩单个文件，例如：

```css
gzip file.txt
```

上述命令会将 `file.txt` 文件压缩成 `file.txt.gz` 文件，并删除原始文件。

如果你想保留原始文件，可以使用 `-k` 或 `--keep` 选项：

```css
gzip -k file.txt
```

`gzip` 命令也可以用于解压缩文件，例如：

```css
gzip -d file.txt.gz
```

上述命令会将 `file.txt.gz` 文件解压缩成 `file.txt` 文件，并删除压缩文件。

`gzip` 命令还可以将多个文件压缩成一个 `.tar.gz` 文件。首先，你需要使用 `tar` 命令将文件打包成 `.tar` 文件：

```css
tar -cvf files.tar file1.txt file2.txt file3.txt
```

上述命令会将 `file1.txt`、`file2.txt` 和 `file3.txt` 打包成一个名为 `files.tar` 的文件。

然后，你可以使用 `gzip` 命令将 `.tar` 文件压缩成 `.tar.gz` 文件：

```css
gzip files.tar
```

上述命令会将 `files.tar` 文件压缩成 `files.tar.gz` 文件，并删除原始文件。

如果你想解压缩一个 `.tar.gz` 文件，可以使用以下命令：

```css
tar -xvf files.tar.gz
```

上述命令会将 `files.tar.gz` 文件解压缩成 `files.tar` 文件，然后你可以使用以下命令解压缩 `.tar` 文件中的所有文件：

```css
tar -xvf files.tar
```

上述命令会将 `files.tar` 文件中的所有文件解压缩到当前目录中。

其他选项

`gzip` 命令还有其他选项，例如：

- `-v`：显示详细信息；
- `-1` 到 `-9`：指定压缩级别，数字越大压缩比越高；
- `-n` 或 `--name`：保留源文件名；
- `-t` 或 `--test`：测试压缩文件是否完好无损

## bzip2

> `bzip2` 是一种数据压缩算法，也是 Linux 系统中常用的文件压缩工具之一。它可以压缩文件到比 `gzip` 更小的体积，并提供了更高的压缩比和更快的压缩速度。下面对 `bzip2` 的使用方法进行详细讲解。

`bzip2` 命令有以下常用选项：

- `-c`: 将输出发送到标准输出而不是文件，通常与重定向符号一起使用。
- `-d`: 解压缩压缩文件。如果文件名以 `.bz2` 结尾，则此选项可以省略。
- `-f`: 强制执行操作，覆盖目标文件而不询问用户确认。
- `-k`: 保留源文件，即不覆盖原文件。
- `-t`: 测试压缩文件的完整性，而不解压缩它。
- `-v`: 显示操作的详细输出信息。
- `-z`: 压缩文件。如果文件名以 `.bz2` 结尾，则此选项可以省略。
- `-q`：压缩或解压缩时不显示任何信息,静默模式

例如，压缩一个文件并保留源文件，可以使用以下命令：

```css
bzip2 -k filename
```

解压缩一个压缩文件，可以使用以下命令

```css
bzip2 -d filename.bz2
```

该命令将会将 `filename.bz2` 文件解压缩成一个新的文件，新文件的文件名将是 `filename`。如果你想在解压时保留原始压缩文件，可以使用 `-k` 选项：

```css
bzip2 -dk filename.bz2
```

上面的命令将在解压缩时保留原始的 `filename.bz2` 文件。

要使用 `bzip2` 压缩文件，可以使用以下命令：

```css
bzip2 filename
```

该命令将会将 `filename` 文件压缩成一个 `.bz2` 的文件。如果你想在压缩时指定不同的压缩级别，可以使用 `-k` 选项：

```css
bzip2 -k -9 filename
```

上面的命令将使用最高的压缩级别 `-9` 来压缩文件，并且保留原始文件。该命令将生成一个新的 `.bz2` 文件，而原始文件则不会被删除。1-9,默认是9

要查看 `bzip2` 压缩文件的信息，可以使用以下命令：

```css
bzip2 -l filename.bz2
```

该命令将输出 `filename.bz2` 文件的信息，包括压缩比、文件大小、压缩时间等。

要将多个文件压缩成一个 `.bz2` 文件，可以使用以下命令：

```css
bzip2 -k -c file1 file2 file3 > archive.bz2
```

该命令将会将 `file1`、`file2` 和 `file3` 文件压缩成一个 `.bz2` 文件，该文件的文件名是 `archive.bz2`。使用 `-c` 选项将输出结果直接输出到标准输出，然后使用重定向符 `>` 将标准输出保存到文件中。

要解压一个压缩了多个文件的 `.bz2` 文件，可以使用以下命令：

```css
bzip2 -dk archive.bz2
```

该命令将会将 `archive.bz2` 文件解压缩，同时保留原始的文件结构，所有的文件将还原到它们原来所在的目录中。

## xz

> `xz` 是一个强大的压缩工具，可以压缩和解压缩多种格式的文件。它通常可以在 Linux 中通过命令行工具使用，以提供更快的压缩和解压缩速度，并使用更少的磁盘空间。

下面是一些使用 `xz` 命令的示例：

1. 压缩文件：使用 `xz` 命令可以压缩文件，例如：

```css
xz file.txt
```

这将在当前目录下创建一个名为 `file.txt.xz` 的压缩文件，并将原始文件 `file.txt` 删除。

2. 解压文件：使用 `xz` 命令可以解压缩文件，例如：

```css
xz -d file.txt.xz
```

这将在当前目录下解压缩名为 `file.txt.xz` 的压缩文件，并将解压后的文件保存为 `file.txt`。

3. 压缩目录：可以使用 `tar` 和 `xz` 命令一起压缩整个目录，例如:

```css
tar -cJf directory.tar.xz directory/
```

这将在当前目录下创建一个名为 `directory.tar.xz` 的压缩文件，其中包含整个目录 `directory/` 中的所有文件和子目录

4. 解压缩目录：可以使用 `tar` 和 `xz` 命令一起解压缩整个目录，例如：

```css
tar -xJf directory.tar.xz
```

这将在当前目录下解压缩名为 `directory.tar.xz` 的压缩文件，并将解压后的文件保存到一个新的目录 `directory/` 中。

## tar、gzip、bzip2、xz的区别

> 在 Linux 中， `tar` 是一个打包命令，用于将多个文件或目录打包成一个单独的文件。 `gzip`，`bzip2`，`xz` 是压缩命令，可以将文件或数据流进行压缩，以减小文件大小，提高文件传输效率.
>
> gzip、bzip2、xz一般只能打包一个文件，所以一般都是将文件或目录打成tar包，然后再使用三种进行压缩成一个文件。

区别：

1. 压缩算法不同：gzip采用的是Lempel-Ziv算法，bzip2采用的是Burrows-Wheeler算法，xz采用的是LZMA算法。
2. 压缩率不同：一般来说，bzip2的压缩率比gzip高，xz的压缩率又比bzip2高。但是，高压缩率也会带来更长的压缩时间。
3. 压缩/解压速度不同：gzip的压缩/解压速度是最快的，bzip2的速度比gzip慢，xz的速度比bzip2慢得多

通常情况下， `tar` 和压缩命令一起使用，以创建一个归档文件并进行压缩。例如：

创建一个tar和gzip压缩的归档文件：

```css
tar -czvf archive.tar.gz /path/to/directory
```

创建一个tar和bzip2压缩的归档文件:

```css
tar -cjvf archive.tar.bz2 /path/to/directory
```

创建一个tar和xz压缩的归档文件：

```css
tar -cJvf archive.tar.xz /path/to/directory
```

注意，在解压归档文件时，需要使用相应的压缩命令进行解压缩。例如，要解压 `archive.tar.gz` 文件，可以使用以下命令：

```css
gzip -d archive.tar.gz
tar -xvf archive.tar
```

或者可以使用以下命令进行一次性解压缩：

```css
tar -xzvf archive.tar.gz
```



## hexdump

> 在 Linux 中，`hexdump` 是一个十六进制转储工具，它可以将一个文件转储成十六进制格式，方便进行分析和查看。

`hexdump` 命令的基本语法如下：

```css
hexdump [options] [file]
```

其中 `options` 是命令的选项，`file` 是要进行转储的文件名。

下面是一些常用的选项：

- `-C`：以十六进制和 ASCII 字符混合格式显示转储结果。
- `-c`：以字符形式显示转储结果。
- `-n`：限制转储的字节数。
- `-s`：从指定的偏移量处开始转储。
- `-v`：显示所有字节，包括空字节。

以下是一些常见用法示例：

1. 显示文件的十六进制内容

```css
hexdump file.txt
```

这个命令将会显示文件 `file.txt` 的十六进制内容。

2. 显示文件的十六进制和 ASCII 内容

```css
hexdump -C file.txt
```

这个命令将会显示文件 `file.txt` 的十六进制和 ASCII 内容，每一行都会以十六进制和 ASCII 字符混合的形式显示。

3. 显示文件的字符内容

```css
hexdump -c file.txt
```

这个命令将会显示文件 `file.txt` 的字符内容，每一行都会以字符的形式显示

4. 限制转储的字节数

```css
hexdump -n 16 file.txt
```

这个命令将会显示文件 `file.txt` 的前 16 个字节的十六进制内容。

5. 从指定的偏移量处开始转储

```css
hexdump -s 100 file.txt
```

这个命令将会显示文件 `file.txt` 从第 100 个字节开始的十六进制内容

6. 显示所有字节，包括空字节

```css
hexdump -v file.txt
```

这个命令将会显示文件 `file.txt` 的所有字节，包括空字节。

7. 查看分区表

``` css
hexdump -C -n 512 /dev/sdb1 -v
```

## grep

> 在 Linux 中，`grep` 命令是一种强大的文本搜索工具，可以在文件或标准输入中查找指定的字符串或正则表达式，并将匹配的行输出。下面是 `grep` 命令的一些常见用法：

```css
grep [OPTIONS] PATTERN [FILE...]
```

其中 `OPTIONS` 是可选的参数，`PATTERN` 是要匹配的模式，`FILE` 是要搜索的文件名（也可以使用通配符匹配多个文件）。下面是常用的选项：

- `-i`：忽略大小写
- `-v`：反转匹配，只显示不匹配的行
- `-c`：只显示匹配行的计数
- `-n`：显示匹配行的行号
- `-l`：只显示包含匹配行的文件名
- `-L`：只显示不包含匹配行的文件名
- `-r`：递归地搜索子目录中的文件
- `-w`：只匹配整个单词
- `-e`：允许使用多个模式,指定匹配的字符串，可以使用多个 `-e` 选项进行多个匹配。
- `-o`: 只输出匹配项本身，而不是包含匹配项的整行。
- `-q`: 静默模式，不输出任何信息。
- `-h`: 不输出匹配行所在的文件名。
- `-s`: 不显示错误信息。
- `-E`:扩展正则表达式。

除了选项外，`grep` 命令还支持一些正则表达式语法，例如：

- `^`: 匹配行首。
- `$`: 匹配行尾。
- `.`: 匹配任意单个字符。
- `[]`: 匹配括号中的任意一个字符。
- `[^]`: 匹配除了括号中的字符以外的任意一个字符。
- `*`: 匹配前面的字符出现 0 次或多次。
- `+`: 匹配前面的字符出现 1 次或多次。
- `?`: 匹配前面的字符出现 0 次或 1 次。
- `|`: 匹配两个或多个表达式中的任意一个。

需要注意的是，在使用正则表达式时，需要用引号将表达式括起来，以防止特殊字符被 Shell 解析。

## sed

> Sed是一个强大的文本处理工具，其名称来自“流编辑器”（Stream Editor）的缩写。它可以在命令行中使用，也可以作为脚本运行。Sed可以读取、编辑、过滤和转换文本文件中的内容，可以对文件内容进行搜索和替换等多种操作。

以下是关于Linux中sed的一些详细讲解：

1. 基本用法

sed命令的基本语法如下：

```css
sed [options] 'command' input_file
```

其中，`options`是一些选项参数，可以用于控制sed的行为；`command`是一个或多个sed编辑命令，用于对输入文件进行编辑和转换；`input_file`是要处理的输入文件的名称。

options:

* `-n` 不输出模式空间内容到屏幕，即不自动打印;禁止sed的默认输出，只输出被命令处理过的文本。

* `-e` 多点编辑,允许在命令行中指定多个命令，用分号分隔。

* `-f` FILE 从指定文件中读取编辑脚本

* `-r, -E` 使用扩展正则表达式

* `-i`直接修改文件内容。

* `-i.bak` 备份文件并原处编辑

* `-s`将多个文件视为独立文件，而不是单个连续的长文件流

  #说明:

* `-ir` 不支持

* `-i -r` 支持

* `-ri` 支持

* `-ni` 会清空文件

command:

```css
1. 不给地址：对全文进行处理
2. 单地址：
#：指定的行，$：最后一行
/pattern/：被此处模式所能够匹配到的每一行
3. 地址范围：
#,# #从#行到第#行，3，6 从第3行到第6行
#,+# #从#行到+#行，3,+4 表示从3行到第7行
/pat1/,/pat2/
#,/pat/
/pat/,#
4. 步进：~
1~2 奇数行
2~2 偶数行
```

命令:

```css
p 打印当前模式空间内容，追加到默认输出之后
Ip 忽略大小写输出
d 删除模式空间匹配的行，并立即启用下一轮循环
a [\]text 在指定行后面追加文本，支持使用\n实现多行追加
i [\]text 在行前面插入文本
c [\]text 替换行为单行或多行文本
w file 保存模式匹配的行至指定文件
r file 读取指定文件的文本至模式空间中匹配到的行后
= 为模式空间中的行打印行号
! 模式空间中匹配行取反处理
q 结束或退出sed
```

查找替换：

```css
s/pattern/string/修饰符 查找替换,支持使用其它分隔符，可以是其它形式：s@@@，s###
替换修饰符：
g 行内全局替换
p 显示替换成功的行
w /PATH/FILE 将替换成功的行保存至文件中
I,i 忽略大小写
```



例如，下面的命令将打印出`input_file`文件中的每一行：

```css
sed 'p' input_file
```

1. 编辑命令

sed中的编辑命令通常由一个操作符和一个模式组成，它们一起用于指定要编辑和转换的文本范围和方式。下面是一些常用的sed编辑命令：

- 替换命令（s）：用于替换指定模式的文本。语法为：

```css
sed 's/模式/替换文本/标志' input_file
```

其中，`模式`是要替换的文本模式；`替换文本`是要替换成的文本；`标志`是一些可选的标志参数，用于控制替换的方式和范围。例如，下面的命令将把`input_file`文件中的所有`apple`替换为`orange`：

```css
sed 's/apple/orange/g' input_file
```

* 删除命令（d）：用于删除指定模式的文本。语法为：

```css
sed '/模式/d' input_file
```

其中，`模式`是要删除的文本模式。例如，下面的命令将删除`input_file`文件中所有以`#`开头的行：

```css
sed '/^#/d' input_file
```

```css
sed '2d' file.txt
```

这个命令会删除文件file.txt中的第二行。如果要删除多行，可以使用逗号分隔行数：

```css
sed '2,5d' file.txt
```

这个命令会删除文件file.txt中的第二行到第五行。

插入命令（i）：用于在指定模式之前插入新的文本。语法为：

```css
sed '/模式/i 新文本' input_file
```

其中，`模式`是要在其前面插入新文本的文本模式；`新文本`是要插入的文本。例如，下面的命令将在`input_file`文件中所有以`apple`开头的行之前插入一行`fruit:`：

```css
sed '/^apple/i fruit:' input_file
```

追加命令（a）：用于在指定模式之后追加新的文本。语法为：

```css
sed '/模式/a 新文本' input_file
```

## awk



## ss

ss是一种Linux系统命令，用于显示当前网络连接的详细信息，包括TCP和UDP协议的连接状态、套接字、进程ID等。

ss命令的语法格式如下：

```css
ss [options] [ FILTER ]
```

其中，options是ss命令的可选参数，用于设置命令的行为和输出格式；FILTER是ss命令的可选过滤条件，用于过滤显示的连接信息。

下面是一些常用的ss命令选项：

- `-t`：只显示TCP协议的连接信息。
- `-u`：只显示UDP协议的连接信息。
- `-a`：显示所有连接信息，包括监听状态的套接字。
- `-n`：不进行主机名解析，直接显示IP地址。
- `-p`：显示与连接关联的进程ID和进程名称。
- `-o`：显示计时器信息，包括连接持续时间和流量统计。
- `-l`：只显示监听状态的套接字信息。
- `-s`：显示TCP协议的统计信息，包括连接状态计数和错误计数。

除了这些选项，ss命令还可以通过FILTER过滤条件进行筛选，例如：

- `ss state established`：只显示状态为“已建立”的连接信息。
- `ss dst 192.168.1.1`：只显示目标地址为192.168.1.1的连接信息。

## nc

在Linux中，nc是一种非常有用的网络工具，它是netcat的缩写，是一款可以读取、写入数据的网络工具。它可以通过TCP或UDP协议在网络上建立连接，从而实现网络通信的功能。

nc命令的语法如下：

```css
nc [options] host port
```

其中，host表示要连接的主机名或IP地址，port表示要连接的端口号。options是可选的一些参数，可以用来配置nc的行为。

下面是nc命令的一些常见用法：

1. 建立TCP连接

```css
nc host port
```

使用该命令可以与指定的主机和端口建立TCP连接。连接成功后，可以在终端输入数据并发送到远程主机，也可以从远程主机读取数据并在终端上显示。

2. 建立UDP连接

```css
nc -u host port
```

使用该命令可以与指定的主机和端口建立UDP连接。与TCP连接不同，UDP连接是无状态的，发送方发送数据包后就不再关心它是否到达接收方。因此，使用nc建立UDP连接时，需要自己控制数据包的顺序和重传机制。

3. 监听端口

```css
nc -l port
```

使用该命令可以在本地主机上监听指定的端口，等待其他主机建立连接。当有连接请求时，nc会自动将连接接受并显示连接信息。

4. 文件传输

```css
nc -l port < file
```

使用该命令可以将本地文件传输到远程主机。该命令在监听端口的同时，从标准输入中读取文件内容，并将其发送到连接的远程主机。如果需要从远程主机接收文件，则可以使用相反的命令：

```css
nc host port > file
```

5. 扫描端口

```css
nc -z host start_port-end_port
```

使用该命令可以扫描指定主机上的一段端口，查看哪些端口是开放的。该命令会依次尝试连接指定主机上的每个端口，如果端口开放，则会显示连接成功的信息。
    
    
## iptables

> `iptables`是Linux系统中的一种命令行工具，用于管理Linux内核提供的IPV4包过滤功能，即用于配置、管理和维护Linux上的网络防火墙规则。它允许用户根据一定的条件（如来源IP地址、目标IP地址、传输层协议等）对网络数据包进行过滤、转发和丢弃等操作。iptables 主要工作在 OSI（开放系统互联）模型的第 3 层（网络层）和第 4 层（传输层）。

iptables主要由一下几个组成部分构成：

1. 表（Tables）：包含了一组相互关联的链，用于处理数据包。最常见的表有`filter`、`nat`、`mangle`和`raw`。
2. 链（Chains）：一个表中包含多个链，用于根据规则处理数据包。默认链`INPUT`,`OUTPUT`,`FORWARD`,`PREROUTING`和`POSTROUTING`。
3. 规则（Rules）：定义在链上的条件和操作，用于处理数据包。当数据包与规则匹配时，就会执行相应的操作（如允许、拒绝和记录）。

`iptables` 命令的基本格式如下：

```css
iptables [选项] [链] [匹配条件] [动作]
```

选项：

- `-A`：将新规则追加到链的末尾。
- `-I`：将新规则插入到链的指定位置。
- `-D`：从链中删除指定的规则。
- `-R`：替换链中的某个规则。
- `-L`：列出指定链的规则（如果未指定链，则列出所有链的规则）。
- `-F`：清空指定链的规则（如果未指定链，则清空所有链的规则）。
- `-Z`：将指定链的数据包和字节计数器重置为零（如果未指定链，则重置所有链的计数器）。
- `-N`：创建新的用户自定义链。
- `-X`：删除用户自定义链。
- `-P`：设置默认策略（如 ACCEPT、DROP 或 REJECT）。
- `-t`：选择操作的表（如 `filter`、`nat`、`mangle` 或 `raw`）。默认为 `filter` 表。

链：

- `INPUT`：处理进入本地系统的数据包。
- `OUTPUT`：处理从本地系统发送出去的数据包。
- `FORWARD`：处理在本地系统上进行转发的数据包。
- `PREROUTING`：在 `nat` 表中，用于处理路由前的数据包。
- `POSTROUTING`：在 `nat` 表中，用于处理路由后的数据包。

匹配条件：

- `-p`：指定协议（如 TCP、UDP、ICMP 等）。
- `-s`：指定源 IP 地址或子网。
- `-d`：指定目标 IP 地址或子网。
- `--sport`：指定源端口。
- `--dport`：指定目标端口。
- `-i`：指定输入网络接口。
- `-o`：指定输出网络接口。
- `-m`：加载扩展模块以提供额外的匹配条件（如 `conntrack`、`limit`、`state` 等）。

动作：

- `-j`：指定目标操作，如 ACCEPT、DROP、REJECT 或自定义链名。
- `--to-destination`：在 DNAT（目标地址转换）规则中指定新的目标 IP 地址和（或）端口。
- `--to-source`：在 SNAT（源地址转换）规则中指定新的源 IP 地址和（或）端口。
- `--to-ports`：在 REDIRECT 规则中指定新的目标端口。

例如：要阻止来自IP192.168.1.10的所有数据包，可以使用一下命令：

```css
iptables -A INPUT -s 192.168.1.10 -j DROP
```

这里的 `-A` 代表追加规则（Append），`-s` 代表源 IP 地址，`-j` 代表目标操作（在本例中是 DROP，表示丢弃数据包）。

需要注意的是，iptables 仅适用于 IPv4 网络。对于 IPv6 网络，您需要使用 ip6tables。

2. 查看当前防火墙规则：

```css
iptables -L -n -v
```

3. 清空当前所有规则：

```css
iptables -F
```

4. 阻止来自特定IP地址的数据包：

```css
iptables -A INPUT -s <IP地址> -j DROP
```

5. 允许来自特定IP地址的数据包：

```css
iptables -A INPUT -s <IP地址> -j ACCEPT
```

6. 阻止来自特定端口的数据包（例如：阻止所有SSH流量）：

```css
iptables -A INPUT -p tcp --dport 22 -j DROP
```

7. 允许来自特定端口的数据包（例如，允许所有 SSH 流量）：

```css
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```

8. 限制特定 IP 地址的并发连接数：

```css
iptables -A INPUT -p tcp -s <IP地址> -m connlimit --connlimit-above <连接数限制> -j DROP
```

9. 对特定 IP 地址实施访问速率限制：

```css
iptables -A INPUT -s <IP地址> -m limit --limit <每秒允许的数据包数量> --limit-burst <突发数据包数量> -j ACCEPT
```

10. 转发特定端口到另一个端口（端口映射）：

```css
iptables -t nat -A PREROUTING -p tcp --dport <原端口> -j REDIRECT --to-port <目标端口>
```

11. 设置默认策略（例如，拒绝所有传入的数据包）：

```css
iptables -P INPUT DROP
```

## tcpdump

> `tcpdump` 是一款用于 Linux 和 Unix 系统的强大命令行网络分析工具。它允许您捕获并实时查看正在通过网络接口传输的数据包。`tcpdump` 使用 pcap 库来捕获数据包，因此可以解析各种网络协议，包括 TCP、UDP、ICMP 等。它对网络管理员和安全专家进行故障排查、网络性能监控和安全分析等任务非常有用。

```css
-i：指定网络接口。使用这个选项可以选择要捕获数据包的网络接口，如tcpdump -i eth0。

-n：不解析主机名。默认情况下，tcpdump会将IP地址解析为主机名。使用-n选项可以禁用这个功能，如tcpdump -n。
-nn选项实际上是两个-n选项的组合：第一个-n选项表示不解析IP地址为主机名，即显示原始的IP地址。第二个-n选项表示不解析端口号为服务名，即显示原始的端口号。

-c：捕获指定数量的数据包。使用这个选项可以限制捕获的数据包数量，如tcpdump -c 10表示捕获10个数据包。

-w：将捕获的数据包写入文件。使用这个选项可以将捕获的数据包保存到一个文件中，以便后续分析，如tcpdump -w output.pcap。

-r：从文件中读取数据包。使用这个选项可以分析之前使用-w选项保存的数据包文件，如tcpdump -r output.pcap。

-v、-vv、-vvv：详细输出。这些选项会提供不同级别的详细输出，-v是基本详细信息，-vv和-vvv会提供更多详细信息。

src、dst：指定源地址和目的地址。使用这两个关键词可以过滤特定的源地址和目的地址，如tcpdump src 192.168.1.1或tcpdump dst 192.168.1.2。

port：指定端口。使用这个关键词可以过滤特定的端口，如tcpdump port 80。

host：指定主机。使用这个关键词可以过滤与特定主机相关的数据包，如tcpdump host example.com。

tcp、udp、icmp：指定协议。使用这些关键词可以过滤特定协议的数据包，如tcpdump tcp 
```
    
以下是一些常用的 `tcpdump` 命令和选项：

1. 捕获指定网络接口的数据包：

```css
tcpdump -i <接口名称>


2. 捕获指定数量的数据包：

```css
tcpdump -c <数据包数量>
```

3. 以详细模式显示数据包：

```css
tcpdump -v
```

4. 以非常详细模式显示数据包：

```css
tcpdump -vv
```

5. 以最详细模式显示数据包：

```css
tcpdump -vvv
```

6. 显示数据包的完整内容：

```css
tcpdump -X
```

7. 只显示指定主机的数据包：

```css
tcpdump host <IP地址>
```

8. 只显示指定端口的数据包：

```css
tcpdump port <端口号>
```

9. 只显示指定协议的数据包：

```css
tcpdump icmp
```

10. 使用表达式过滤数据包：

```css
tcpdump "src <源IP地址> and dst <目标IP地址>"
```

11. 将捕获的数据包保存到文件中：

```css
tcpdump -w <文件名>
```

12. 从文件中读取并分析数据包：

```css
tcpdump -r <文件名>
```

## 
    
    
    
## ps

> 在Linux操作系统中，`ps`命令是一种常用的命令行工具，用于查看系统中运行的进程信息。以下是关于`ps`命令的详细讲解：

语法：

```css
ps [选项]
```

选项：

- `-e`：显示所有进程信息。
- `-u`：显示用户进程信息。
- `-f`：以完整格式显示进程信息。
- `-l`：以长格式显示进程信息。
- `-a`：显示终端上所有进程信息，包括其他用户的进程。
- `-x`：显示无终端进程信息。
- `-C`：显示指定进程的信息

常用输出字段：

- `USER`：进程所属的用户名。
- `PID`：进程的ID。
- `%CPU`：进程使用的CPU占用率。
- `%MEM`：进程使用的内存占用率。
- `VSZ`：进程使用的虚拟内存大小。
- `RSS`：进程使用的实际内存大小。
- `TTY`：进程所属的终端。
- `STAT`：进程的状态。
- `START`：进程的启动时间。
- `TIME`：进程使用CPU的时间。

显示所有进程信息：

```css
ps -e

```

显示当前用户进程信息：

```css
ps -u username
```

以完整格式显示所有进程信息：

```css
ps -ef
```

以长格式显示所有进程信息：

```css
ps -l
```

显示当前终端上所有进程信息：

```css
ps -a
```

显示无终端进程信息：

```css
ps -x
```

显示指定进程的信息：

```css
ps -C processname
```

## kill

> 在Linux中，kill是一个用于发送信号给进程的命令。通过发送信号，我们可以控制进程的行为，比如终止进程、重新启动进程等等。

kill命令的基本语法如下：

```css
kill [signal] [pid]
```

其中，signal是要发送的信号，pid是要接收信号的进程的ID。如果不指定signal，默认会发送信号15（SIGTERM），它会请求进程正常退出。如果进程没有响应SIGTERM信号，则可以使用强制终止信号9（SIGKILL）来强制终止进程。

其中，`pid`是进程ID，可以是一个或多个进程的ID。

以下是一些常见的信号：

- `SIGTERM（15）`：请求进程正常退出。
- `SIGKILL（9）`：强制终止进程。
- `SIGSTOP（19）`：暂停进程的执行。
- `SIGCONT（18）`：恢复进程的执行。

如果你想要向进程发送其他信号，可以使用以下命令来查看系统中可用的信号：

```css
kill -l
```

例如，如果想要向进程ID为1234的进程发送SIGKILL信号，可以执行以下命令：

```css
kill -9 1234
```

如果想要向所有名称为nginx的进程发送SIGTERM信号，可以执行以下命令：

```css
pkill -TERM nginx
```

## top

> 在Linux系统中，`top`命令是一个常用的系统监控命令，它可以实时地展示系统的各种状态，包括CPU、内存、进程等。下面是关于top命令的一些基本用法和参数

1. 命令格式：

```css
top [选项]
```

2. 常用选项：

- `-d` ：指定top命令的刷新时间，单位为秒；
- `-b` ：以批处理模式运行top命令，将结果输出到标准输出，适用于将top的结果导入到其他脚本进行处理；
- `-u` ：指定top命令只显示指定用户的进程；
- `-p` ：指定top命令只显示指定进程号的进程；
- `-n` ：指定top命令执行的次数

3. top命令输出的信息分为多个部分：

- 第一行：系统的负载情况，包括运行的进程数量、CPU的占用情况和内存的占用情况；
- 第二行：进程相关的信息，包括正在运行的进程数、睡眠的进程数、停止的进程数、僵尸进程数等；
- 第三行：CPU的使用情况，包括用户空间的CPU使用率、系统空间的CPU使用率、空闲CPU的使用率等；
- 第四行：内存的使用情况，包括总内存大小、已用内存大小、空闲内存大小、缓存大小等；
- 后面的内容：各个进程的详细信息，包括进程ID、进程的所有者、进程所占用的CPU时间、进程的状态、进程的内存占用情况等。

4. 常用操作：

- `q` ：退出top命令；
- `k` ：向某个进程发送信号；
- `r` ：修改某个进程的优先级；
- `h` ：显示帮助信息；
- `1` ：切换到单CPU模式

## netstat

> 在Linux操作系统中，netstat是一个命令行工具，用于显示网络连接、路由表、网络接口和网络协议统计信息。它可以帮助系统管理员和网络工程师监控和分析网络连接和活动，以及诊断网络故障和安全问题。

下面是netstat常用的选项和参数：

1. `-a`：显示所有连接，包括TCP、UDP和UNIX域套接字连接。
2. `-t`：显示TCP连接。
3. `-u`：显示UDP连接。
4. `-n`：显示IP地址和端口号，而不是使用名称和服务。
5. `-p`：显示与连接相关的进程名称或PID。
6. `-e`：显示扩展信息，如TCP窗口大小、数据包大小等。
7. `-s`：显示网络协议统计信息，如TCP、UDP、IP等的数据包传输情况。
8. `-r`：显示路由表信息。
9. `-c`：持续显示netstat命令输出，直到手动终止。
10. `-x`:  显示UNIX域套接字连接。
11. `-i`:  显示网络接口的统计信息。
12. `-l`:  显示所有正在监听的网络连接。

下面是一些netstat命令的例子：

1. `netstat -an`：显示所有TCP和UDP连接的IP地址和端口号。
2. `netstat -tulpn`：显示所有正在监听TCP端口的进程名和PID。
3. `netstat -r`：显示路由表信息。
4. `netstat -s`：显示各种网络协议的数据包传输情况。
5. `netstat -c`：持续显示netstat命令输出，直到手动终止。

## wget

> 在Linux中，wget是一个命令行工具，用于从互联网上下载文件。wget可以使用HTTP、HTTPS和FTP协议下载文件。以下是关于wget的一些常见用法：

基本格式：

```css
wget [options] [URL]
```

options：

- `-O`: 指定下载文件的名称
- `-c`: 断点续传，如果下载过程中出现问题，可以从上次下载的地方继续下载
- `-q`: 静默模式，不输出任何信息
- `-r`: 递归下载，下载指定网站的所有链接
- `-np`: 不遵循父级链接，即不下载指向父级目录的链接
- `-nH`: 不在下载文件时生成主机名称目录，即不在本地创建以主机名称为名的目录
- `-nc`: 不覆盖已存在的文件，如果本地已存在同名文件，则不进行下载
- `-P`: 指定下载文件的保存路径
- `-t`: 最大尝试次数，如果下载失败，则会尝试指定的次数
- `-T`: 超时时间，如果在指定的时间内无法下载，则下载失败

```css
-O: 指定下载后的文件名，例如 wget -O myfile.txt http://example.com/file.txt
-q: 静默模式，不显示进度条和其它信息，例如 wget -q http://example.com/file.txt
-c: 断点续传，从上次下载的位置继续下载，例如 wget -c http://example.com/file.txt
-r: 递归下载，下载指定URL及其链接的所有文件，例如 wget -r http://example.com
-np: 不下载父级链接，例如 wget -r -np http://example.com
-N: 如果文件已经存在，则只下载比本地文件新的文件，例如 wget -N http://example.com/file.txt
-p: 下载页面所需的所有文件（例如图像、样式表等），例如 wget -p http://example.com
-U: 设置请求的User-Agent头信息，例如 wget -U "Mozilla/5.0" http://example.com
```

1. 下载单个文件

使用wget下载单个文件非常简单，只需要在终端中输入以下命令：

```css
wget [URL]
```

其中，[URL]是你要下载的文件的URL地址。

例如，要下载一个名为myfile.zip的文件，它的URL地址是https://example.com/myfile.zip，只需在终端中输入以下命令：

```css
wget https://example.com/myfile.zip
```

wget将自动下载该文件并将其保存在当前工作目录中。

2. 下载多个文件

如果你要下载多个文件，你可以将所有的URL地址保存在一个文本文件中，然后使用wget来读取该文件并下载所有的文件。假设你已经创建了一个名为urls.txt的文件，并将要下载的文件URL地址写在了这个文件中，你可以使用以下命令下载所有的文件

```css
wget -i urls.txt
```

其中，-i选项用于指定URL地址列表文件的路径

3. 断点续传

如果你的下载任务被意外中断，你可以使用wget的断点续传功能来恢复下载。使用以下命令来恢复已经中断的下载：

```css
wget -c [URL]
```

其中，-c选项用于启用断点续传功能。wget将会检查已经下载的部分，并从中断处继续下载。

4. 限速下载

如果你想限制下载速度，可以使用wget的--limit-rate选项。使用以下命令来限制下载速度为100KB/s：

```css
wget --limit-rate=100k [URL]
```

其中，--limit-rate选项用于指定下载速度限制。这个例子中，下载速度被限制为100KB/s。

5. 下载到指定目录

默认情况下，wget将下载文件保存在当前工作目录中。如果你想将文件保存到其他目录中，可以使用-O选项来指定保存路径。例如，如果你想将下载的文件保存到/home/user/Downloads/目录中，你可以使用以下命令：

```css
wget -O /home/user/Downloads/myfile.zip [URL]
```

其中，-O选项用于指定保存文件的路径和名称。

## curl

> Curl是一个在命令行下工作的开源工具，它支持多种网络协议，如HTTP、FTP、SMTP、TELNET等，并提供了丰富的功能和参数，比如上传、下载、认证等。它可以被用于发送数据，获取网页，下载文件等等。

以下是一些常见的用法：

1. 发送请求并获取响应

```css
curl http://example.com
```

这个命令会发送一个GET请求到指定的URL，然后输出响应结果

2. 下载文件

```css
curl -O http://example.com/file.zip
```

这个命令会下载指定URL的文件，并保存到当前目录下

3. 上传文件

```css
curl -F 'file=@/path/to/file' http://example.com/upload
```

这个命令会将本地的文件上传到指定的URL

4. 添加HTTP头信息

```css
curl -H 'Content-Type: application/json' http://example.com
```

这个命令会添加一个HTTP头信息到请求中，然后发送请求并获取响应

5. 使用HTTP认证

```css
curl -u username:password http://example.com
```

这个命令会使用HTTP基本认证，发送请求并获取响应。

6. 后台运行

```css
curl -s -o /dev/null http://example.com &
```

这个命令会将curl命令放在后台运行，并且将输出重定向到/dev/null，这样就不会在终端上输出任何信息

## ifconfig

> `ifconfig` 是一个在 Linux 中常用的命令行工具，用于配置和显示网络接口的状态。ifconfig 命令可以显示当前系统上已配置的所有网络接口，以及这些网络接口的详细信息，例如 IP 地址、子网掩码、广播地址、MAC 地址等等。

下面是一些常用的 ifconfig 命令选项：

- `ifconfig` ：显示当前系统上所有的网络接口信息。
- `ifconfig eth0` ：显示指定的网络接口（例如 eth0）的详细信息。
- `ifconfig eth0 up` ：激活指定的网络接口（例如 eth0）。
- `ifconfig eth0 down` ：禁用指定的网络接口（例如 eth0）。
- `ifconfig eth0 netmask 255.255.255.0` ：设置指定网络接口（例如 eth0）的子网掩码为 255.255.255.0。
- `ifconfig eth0 192.168.1.100` ：为指定网络接口（例如 eth0）设置 IP 地址为 192.168.1.100。
- `ifconfig eth0 broadcast 192.168.1.255` ：设置指定网络接口（例如 eth0）的广播地址为 192.168.1.255。
- `ifconfig eth0 hw ether 00:11:22:33:44:55` ：设置指定网络接口（例如 eth0）的 MAC 地址为 00:11:22:33:44:55。

## ping

> 在 Linux 系统中，ping 是一个用于测试网络连接性的命令行工具。它可以向指定的 IP 地址或域名发送一个 ICMP Echo 请求，并等待对方的响应。通过分析响应的时间和状态，可以判断网络的连通性和响应速度。

下面是一些常用的 ping 命令选项：

- `ping IP地址或域名` ：向指定的 IP 地址或域名发送 ICMP Echo 请求。
- `-c 次数` ：指定发送 ICMP Echo 请求的次数，默认为无限次。
- `-s 大小` ：指定 ICMP Echo 请求的数据包大小，默认为 56 字节。
- `-i 秒数` ：指定发送 ICMP Echo 请求的时间间隔，默认为 1 秒。
- `-w 秒数` ：指定等待响应的超时时间，默认为 2 秒。
- `-q` ：以安静模式运行，只显示最终结果，不显示详细信息。
- `-v` ：以详细模式运行，显示每个 ICMP Echo 请求的详细信息。
    
 -c：指定发送的数据包数量。例如，ping -c 4 example.com将向example.com发送4个数据包。

-i：指定数据包发送间隔（以秒为单位）。例如，ping -i 2 example.com将每隔2秒发送一个数据包。

-t（仅适用于Windows）：指定TTL（Time to Live）值。例如，ping -t 128 example.com将使用TTL值128发送数据包。

-a（仅适用于Windows）：指定在接收到回复时发出声音。例如，ping -a example.com。

-w（仅适用于Windows）：指定等待每个回复的超时时间（以毫秒为单位）。例如，ping -w 500 example.com将等待500毫秒的超时。

-W（仅适用于Linux）：指定等待每个回复的超时时间（以秒为单位）。例如，ping -W 1 example.com将等待1秒的超时。

-s（仅适用于Linux）：指定发送的数据包大小（以字节为单位）。例如，ping -s 56 example.com将发送大小为56字节的数据包。

-l（仅适用于Windows）：指定发送的数据包大小（以字节为单位）。例如，ping -l 56 example.com将发送大小为56字节的数据包。

-f（仅适用于Linux）：指定发送“洪水”模式数据包。在这种模式下，数据包将尽可能快地发送，而不等待接收到回复。通常需要管理员权限。例如，ping -f example.com。

-q（仅适用于Linux）：指定以“安静”模式运行，仅显示总结信息。例如，ping -q example.com。

用 ping 命令可以快速检测网络的连接性，以及网络的延迟和响应速度。如果 ping 命令返回的结果是“目标主机不可达”或“连接超时”等错误信息，则说明网络连接存在问题，需要进一步排查。如果 ping 命令返回的结果正常，则说明网络连接正常，可以进行其他网络操作。

## scp

> 在 Linux 系统中，`scp` 是一个用于在不同主机之间复制文件和目录的命令行工具。它基于 SSH 协议进行数据传输，可以保证数据传输的安全性。

下面是一些常用的 scp 命令选项：

- `scp [options] source destination` ：将 source 复制到 destination。
- `-r` ：递归复制整个目录树。
- `-P` ：指定远程 SSH 服务器端口号，默认为 22。
- `-p` ：保留文件的权限、时间戳等属性。
- `-q` ：以安静模式运行，不显示详细信息。
- `-v` ：以详细模式运行，显示每个文件的复制进度和状态信息。

使用 scp 命令可以实现在不同主机之间快速传输文件和目录。与常规的文件传输方式相比，scp 具有更高的安全性和可靠性。通过在终端中输入 scp 命令并指定源文件和目标路径，可以快速将本地文件传输到远程主机或从远程主机传输文件到本地主机。

需要注意的是，使用 scp 命令需要具有目标主机的 SSH 登录权限，并且需要知道目标主机的 IP 地址、用户名和密码等信息。另外，在使用 scp 命令进行文件传输时，建议使用绝对路径或相对路径来指定源文件和目标路径，以避免出现不必要的错误和问题。

当需要将本地主机上的文件传输到远程主机上时，可以使用以下命令：

```css
scp local_file remote_username@remote_ip:remote_folder
```

其中，`local_file` 是本地主机上要传输的文件路径，`remote_username` 是远程主机的用户名，`remote_ip` 是远程主机的 IP 地址，`remote_folder` 是远程主机上的目标文件夹路径。

例如，将本地主机上的 `test.txt` 文件传输到远程主机 `192.168.1.100` 的 `/home/user/files` 目录下：

```css
scp /home/user/test.txt user@192.168.1.100:/home/user/files/
```

当需要将远程主机上的文件传输到本地主机上时，可以使用以下命令：

```css
scp remote_username@remote_ip:remote_file local_folder
```

其中，`remote_username` 是远程主机的用户名，`remote_ip` 是远程主机的 IP 地址，`remote_file` 是远程主机上要传输的文件路径，`local_folder` 是本地主机上的目标文件夹路径。

例如，将远程主机 `192.168.1.100` 上的 `/home/user/files/test.txt` 文件传输到本地主机的 `/home/user/files` 目录下：

```css
scp user@192.168.1.100:/home/user/files/test.txt /home/user/files/
```

需要注意的是，传输文件时应当确保目标路径的正确性，避免出现不必要的错误和问题。同时，建议在传输过程中指定 `-P` 选项，以避免因为目标主机的 SSH 端口号不同而出现无法连接的问题。一般默认都是22端口。

## ssh-keygen

> 在 Linux 系统中，`ssh-keygen` 命令是用于生成 SSH 密钥对的工具。它通常与 SSH 客户端一起使用，用于认证 SSH 服务器的身份，并在服务器和客户端之间建立安全的加密通道

下面是一些常用的 `ssh-keygen` 命令选项：

- `ssh-keygen -t <type>` ：指定要生成的密钥类型，包括 RSA、DSA 和 ECDSA 等。默认为 RSA。
- `ssh-keygen -b <bits>` ：指定要生成的密钥长度，单位为比特。默认为 2048。
- `ssh-keygen -C <comment>` ：为密钥添加注释信息。
- `ssh-keygen -f <filename>` ：指定要生成的密钥文件名。默认为 `id_rsa` 或 `id_dsa`。
- `ssh-keygen -N <passphrase>` ：为密钥添加密码保护。
- `ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]` ：修改已有密钥的密码保护。
- `ssh-keygen -y [-f keyfile]` ：从已有的私钥文件中提取公钥。

使用 `ssh-keygen` 命令生成 SSH 密钥对通常包含以下步骤：

1. 在终端中输入 `ssh-keygen` 命令并按下回车键。
2. 系统提示输入密钥保存路径，默认为 `~/.ssh/id_rsa` 或 `~/.ssh/id_dsa`。
3. 系统提示输入密码保护，可选择跳过或输入密码保护。
4. 系统提示输入确认密码保护。
5. 密钥对生成成功后，系统会在密钥保存路径中生成两个文件：`id_rsa` 和 `id_rsa.pub` 或 `id_dsa` 和 `id_dsa.pub`，其中 `id_rsa` 或 `id_dsa` 是私钥文件，`id_rsa.pub` 或 `id_dsa.pub` 是公钥文件。

需要注意的是，私钥文件必须保持在本地机器上，而公钥文件则可以在本地或远程服务器上使用。在使用 SSH 时，应将公钥文件传输到需要访问的远程服务器上，并将其添加到服务器上的 `~/.ssh/authorized_keys` 文件中，以便于建立安全的加密通道。

总之，`ssh-keygen` 命令是一个非常有用的工具，可以帮助用户生成 SSH 密钥对，从而实现安全的身份验证和加密通讯。

当需要在本地机器和远程服务器之间建立 SSH 连接时，可以使用 `ssh-keygen` 命令生成 SSH 密钥对。下面是一些具体的用法例子：

1. 生成默认的 RSA 密钥对

```css
ssh-keygen
```

此命令会在用户的 home 目录下的 `.ssh` 文件夹中生成 `id_rsa` 和 `id_rsa.pub` 两个文件。

2. 生成指定类型的密钥对

```css
ssh-keygen -t ecdsa -b 521
```

此命令会生成一个 ECDSA 类型的密钥对，密钥长度为 521 比特。

3. 生成指定文件名的密钥对

````css
ssh-keygen -f my_key
````

此命令会在当前目录下生成 `my_key` 和 `my_key.pub` 两个文件，用于存储生成的密钥对。

4. 生成带有注释的密钥对

```css
ssh-keygen -t rsa -C "my comment"
```

此命令会生成一个 RSA 类型的密钥对，并在密钥对中添加注释信息。

5. 生成带有密码保护的密钥对

```css
ssh-keygen -p -f my_key -N "new passphrase" -P "old passphrase"
```

此命令会修改名为 `my_key` 的私钥文件的密码保护，将旧密码保护替换为新的密码保护。

6. 从私钥文件中提取公钥

```css
ssh-keygen -y -f my_key > my_key.pub
```

此命令会从名为 `my_key` 的私钥文件中提取公钥，并将其保存到名为 `my_key.pub` 的文件中。

## ssh

在 Linux 系统中，`ssh` 命令可以用于在本地机器和远程服务器之间建立安全的 SSH 连接。SSH（Secure Shell）是一种加密协议，可以提供安全的远程登录和数据传输功能。

用法：

在Linux终端中，可以使用ssh命令来建立到远程计算机的SSH连接。ssh命令的一般语法如下：

```css
ssh [options] [user@]hostname
```

其中，options是ssh命令的一些可选参数，user是要登录到远程计算机的用户名，hostname是远程计算机的主机名或IP地址。

选项：

SSH命令有许多可选的选项，这些选项可以用来控制SSH连接的行为。以下是SSH命令的一些常用选项：

- `-p port`：指定SSH服务器的端口号，默认为22。
- `-i identity_file`：指定用于身份验证的私钥文件的路径。
- `-l login_name`：指定登录到远程主机的用户名。
- `-X`：启用X11转发，可以在本地计算机上运行远程主机的图形化应用程序。
- `-v`：输出SSH连接的详细调试信息

格式：

SSH命令有一些常用的格式，这些格式可以满足不同的SSH连接需求。以下是SSH命令的一些常用格式：

- `ssh user@host`：使用用户名和主机名连接到SSH服务器。
- `ssh -p port user@host`：使用指定端口号、用户名和主机名连接到SSH服务器。
- `ssh -i identity_file user@host`：使用指定私钥文件、用户名和主机名连接到SSH服务器。
- `ssh -X user@host`：使用用户名和主机名连接到SSH服务器，并启用X11转发功能。

下面是一些 `ssh` 命令的使用示例：

1. 登录远程服务器

```css
ssh username@remote_host
```

此命令会使用 SSH 协议连接远程服务器，并提示输入目标服务器的密码。`username` 是目标服务器上的用户名，`remote_host` 是目标服务器的 IP 地址或域名。

2. 登录远程服务器并指定端口号

```css
ssh -p port username@remote_host
```

此命令会在 SSH 连接中指定端口号，以连接远程服务器。`port` 是远程服务器的 SSH 服务监听端口号。

3. 使用 SSH 密钥登录远程服务器

```````````css
ssh -i path_to_private_key username@remote_host
```````````

此命令会使用指定的 SSH 密钥文件登录远程服务器。`path_to_private_key` 是 SSH 密钥文件的路径，`username` 是目标服务器上的用户名，`remote_host` 是目标服务器的 IP 地址或域名。

4. 在 SSH 连接中传递命令

```css
ssh username@remote_host "command"
```

此命令会在 SSH 连接中执行指定的命令，并返回命令的输出。`command` 是要在远程服务器上执行的命令。

5. 使用远程端口转发

```css
ssh -L local_port:remote_host:remote_port username@remote_host
```

此命令会在本地机器和远程服务器之间建立一个 SSH 连接，并将远程服务器上的指定端口映射到本地机器上的指定端口。`local_port` 是本地机器上的端口号，`remote_host` 是远程服务器的 IP 地址或域名，`remote_port` 是远程服务器上的端口号。

例如，要使用私钥文件`/path/to/private_key`连接到主机example.com的SSH服务器，并指定端口号为2222，可以输入以下命令：

```css
ssh -p 2222 -i /path/to/private_key user@example.com
```

例如，要使用端口号2222连接到主机example.com的SSH服务器，并指定用户名为user和私钥文件为`/path/to/private_key`，可以输入以下命令：

```css
ssh -p 2222 -i /path/to/private_key user@example.com
```

需要注意的是，私钥文件必须具有正确的文件权限。通常情况下，私钥文件应该只能由文件所有者读取和写入，因此可以使用以下命令来设置正确的文件权限：

```css
chmod 600 /path/to/private_key
```

## history

`history` 是 Linux 中的一个命令，用于显示之前执行的命令历史记录。使用 `history` 命令可以查看之前执行过的所有命令，包括在当前会话和之前会话中执行的命令。以下是 `history` 命令的详细用法、选项和格式：

`history` 命令的基本用法格式如下：

```css
history [n]
```

其中，`n` 是可选的参数，表示要显示的最近的命令数量。如果省略 `n` 参数，则默认显示最近的 500 条命令记录。

例如，要显示最近的 10 条命令记录，可以在终端中运行以下命令：

```css
history 10
```

`history` 命令的常用选项如下：

- `-c`：清除所有历史记录。
- `-w`：将当前会话的历史记录写入历史记录文件（默认为 `~/.bash_history`）。
- `-a`：将当前会话的历史记录追加到历史记录文件。
- `-n`：读取历史记录文件中的新命令，但不将它们添加到当前会话的历史记录中。
- `-r`：从历史记录文件中读取命令，并将其添加到当前会话的历史记录中。
- `-d offset`：删除历史记录中第 `offset` 条命令。
- `-p string`：将 `string` 添加到历史记录中，但不执行该命令。

## rsync

`rsync` 是 Linux 中一个强大的文件同步工具，用于在本地或远程主机之间同步文件和目录。它可以通过网络传输文件并保持文件的完整性和权限等属性。以下是 `rsync` 命令的详细用法、选项和格式：

`rsync` 命令的基本用法格式如下：

```css
rsync [options] source destination
```

其中，`source` 表示源文件或目录，`destination` 表示目标文件或目录。当 `source` 和 `destination` 中一个是本地路径，另一个是远程路径时，`rsync` 会在它们之间建立一个远程连接，通过网络传输文件。

例如，要将本地目录 `/home/user/documents` 同步到远程主机的 `/data/backups` 目录中，可以使用以下命令：

```css
rsync -avz /home/user/documents user@example.com:/data/backups
```

这将使用 `rsync` 命令将本地目录 `/home/user/documents` 复制到远程主机 `example.com` 的 `/data/backups` 目录中

`rsync` 命令的常用选项如下：

- `-a`：表示归档模式，即保持文件的完整性、权限和时间等属性。这是 `rsync` 常用的选项之一。
- `-v`：表示详细模式，即在输出中显示正在复制的文件名。
- `-z`：表示压缩模式，即在传输过程中对数据进行压缩以节省带宽。
- `-r`：表示递归模式，即对目录及其子目录进行递归复制。
- `-u`：表示更新模式，即仅复制源文件中比目标文件新的文件。
- `-h`：表示人性化输出，即将文件大小以易读的格式（如 KB、MB）显示。
- `-P`：表示启用局部复制和续传功能，即允许在复制过程中恢复中断的复制任务。
- `--delete`：表示删除模式，即在目标目录中删除源目录不存在的文件。
- `--exclude`：表示排除模式，即排除指定文件或目录。
- `--bwlimit`：表示限制带宽，即限制传输速率。
- `--dry-run`：表示演习模式，即显示要执行的操作

例如，要将本地目录 `/home/user/documents` 同步到远程主机 `example.com` 的 `/data/backups` 目录中，并在传输过程中使用压缩功能，可以使用以下命令：

```css
rsync -avz /home/user/documents user@example.com:/data/backups
```

## su、sudo

在 Linux 操作系统中，su 和 sudo 是两个非常常用的命令，用于提高普通用户的权限，以执行需要管理员权限的操作。su 和 sudo 两个命令的主要区别在于，su 命令需要知道管理员的密码，而 sudo 命令需要用户输入自己的密码。

su 是“切换用户”的缩写，可以让普通用户临时提升为管理员或其他用户。su 命令的常用格式为:

```css
su [选项] [用户名]
```

使用 su 命令可以将当前用户切换到另一个用户身份下，如果没有指定用户名，则默认切换到 root 用户身份下。

常用选项：

- -c：使用指定的命令替代默认的 shell；
- -l 或 -：切换到指定用户的环境；
- -m 或 -p：以指定用户的身份执行命令，同时使用指定用户的环境；
- -s：指定要使用的 shell

sudo 是“以超级用户权限执行命令”的缩写，可以让普通用户临时以 root 用户或其他用户的身份执行命令。sudo 命令的常用格式为：

```css
sudo [选项] 命令
```

使用 sudo 命令需要输入当前用户的密码，如果密码正确，则可以以超级用户的权限执行命令。sudo 命令还可以通过编辑 /etc/sudoers 文件来实现不需要输入密码就可以执行某些命令的功能。

常用选项：

- -u：指定要切换到的用户身份；
- -s：以指定用户的 shell 执行命令；
- -i：以指定用户的身份重新登录；
- -k：清除之前保存的验证信息。

1. 以 root 用户身份登录：

```css
su -
```

2. 以普通用户身份执行某个命令：

```css
su -c "command"
```

3. 以其他用户身份执行命令：

```css
su -c "command" username
```

4. 以 root 用户身份执行某个命令：

```css
sudo command
```

5. 以其他用户身份执行命令：

```css
sudo -u username command
```

6. 以指定用户的身份重新登录：

```css
sudo -i
```

## useradd

`useradd` 是 Linux 中的一个命令，用于创建新的用户账户。其用法如下：

```css
useradd [选项] 用户名
```

其中，`[选项]` 是可选的，`用户名` 是要创建的新用户的用户名。下面是一些常用的选项：

- `-c` 或 `--comment`：设置用户的注释信息，用双引号括起来；
- `-d` 或 `--home`：指定用户的家目录，默认为 `/home/用户名`；
- `-g` 或 `--gid`：指定用户所属的初始组；
- `-s` 或 `--shell`：指定用户的登录 shell，默认为 `/bin/bash`；
- `-m` 或 `--create-home`：创建用户的家目录；
- `-k` 或 `--skel`：指定用户家目录的骨架目录；
- `-u` 或 `--uid`：指定用户的 UID；
- `-p` 或 `--password`：指定用户的密码，需要使用加密后的密码，可以使用 `mkpasswd` 等命令生成。
- `-f` 或 `--inactive`：指定账户过期时间，即账户被禁用的时间，单位为天。默认情况下，账户永远不会过期；
- `-e` 或 `--expiredate`：指定账户的到期时间，即账户会在指定日期后被禁用。日期格式为 YYYY-MM-DD；
- `-M` 或 `--no-create-home`：不创建用户的家目录；
- `-n` 或 `--no-user-group`：不创建同名的组；
- `-r` 或 `--system`：创建一个系统账户，这个账户不会被显示在登录界面，UID 范围也不同于普通用户 CentOS 6之前: ID<500，CentOS7 以后: ID<1000

注意，创建用户时，如果未指定密码，则需要使用 `passwd` 命令为新用户设置密码。

实际案例：

```css
useradd -r -u 48 -g apache -s /sbin/nologin -d /var/www -c "Apache" apache
```

下面是一些示例：

1. 创建一个名为 `user1` 的用户

```css
useradd user1
```

2. 创建一个名为 `user2` 的用户，并设置其注释信息：

```css
useradd -c "This is user2" user2
```

3. 创建一个名为 `user3` 的用户，并指定其所属的初始组为 `users`：

```css
useradd -g users user3
```

4. 创建一个名为 `user4` 的用户，并指定其登录 shell 为 `/bin/sh`：

```css
useradd -s /bin/sh user4
```

5. 创建一个名为 `user5` 的用户，并指定其密码为 `mypassword`：

```css
useradd -p $(mkpasswd mypassword) user5
```

6. 创建一个名为 `user6` 的用户，并指定其家目录为 `/home/myuser`：

```css
useradd -d /home/myuser user6
```

7. 创建一个名为 `user7` 的用户，并同时创建其家目录：

```css
useradd -m user7
```

需要注意的是，使用 `useradd` 命令创建用户时，会自动创建同名的组。如果需要创建不同名的组，可以使用 `groupadd` 命令创建新组，并使用 `-g` 选项指定组的 GID。

另外，使用 `useradd` 命令创建的用户账户并没有设置密码，需要使用 `passwd` 命令为其设置密码。命令格式如下：

```css
passwd 用户名
```

运行该命令后，系统会提示输入新密码，并再次要求确认密码。输入密码时，不会显示任何字符，这是出于安全考虑。密码设置成功后，可以使用新密码登录该账户

## usermod

`usermod`是一个用于修改Linux系统用户账户信息的命令行工具。它可以用于更改用户账户的各种属性，如用户名、UID、GID、家目录、默认shell等。下面是`usermod`的用法、选项和格式的详细讲解。

`usermod`命令的一般用法如下：

```css
usermod [OPTIONS] USERNAME
```

其中，`OPTIONS`是`usermod`命令支持的选项，`USERNAME`是要修改的用户账户的用户名。可以指定多个选项，选项的顺序可以随意。修改后的用户信息将在`/etc/passwd`和`/etc/shadow`文件中更新。

`usermod`命令有许多选项，这里列出其中一些常用的选项：

- `-c, --comment COMMENT`：用于添加或更改用户账户的注释。注释可以是任何有意义的文本，用于描述用户的身份、用途等。例如：`-c "This is a test account"`。
- `-d, --home HOME_DIR`：用于更改用户的家目录。例如：`-d /home/newdir`。
- `-e, --expiredate EXPIRE_DATE`：用于设置账户的过期日期。过期日期格式为YYYY-MM-DD。例如：`-e 2024-03-09`。
- `-g, --gid GROUP`：用于更改用户的默认组ID。例如：`-g newgroup`。
- `-l, --login NEW_LOGIN`：用于更改用户的登录名。例如：`-l newlogin`。
- `-p, --password PASSWORD`：用于设置用户的密码。可以使用加密后的密码或是清文密码。例如：`-p newpassword`。
- `-s, --shell SHELL`：用于更改用户的默认shell。例如：`-s /bin/bash`。
- `-u, --uid UID`：用于更改用户的UID。例如：`-u 1001`。

例如，要更改用户名为`johndoe`的账户的默认shell为`/bin/bash`，可以使用以下命令：

```css
usermod -s /bin/bash johndoe
```

如果要同时更改用户名和家目录，可以使用以下命令：

```css
usermod -l newlogin -d /home/newdir johndoe
```

## userdel

`userdel`是Linux系统中一个用于删除用户账户的命令行工具。它可以删除指定用户的账户及相关文件，包括用户主目录、邮件等。下面是关于userdel的详细讲解：

用法：userdel [选项] [用户名]

选项：

- `-f，--force`：强制删除用户账户，即使用户当前正在登录或拥有某些进程。
- `-r，--remove`：删除用户账户及相关文件，包括用户主目录、邮件等。
- `-Z，--selinux-user`：指定被删除用户的SELinux用户。
- `-h，--help`：显示帮助信息。
- `-V，--version`：显示版本信息。

格式：

```css
userdel [选项] [用户名]
```

其中，[用户名]为要删除的用户账户的用户名。

1. 删除用户账户及相关文件：

```css
sudo userdel -r testuser
```

该命令将删除testuser用户账户及相关文件，包括其主目录、邮件等

2. 强制删除正在登录的用户账户：

```css
sudo userdel -f testuser
```

该命令将强制删除testuser用户账户，即使该用户当前正在登录或拥有某些进程。

## id

在Linux中，id是一个用于查看用户和组的身份识别信息的命令。它可以显示有关用户及其所属组的信息，包括用户ID（UID）、组ID（GID）、附加组ID（SGID）和所属组（supplementary group）等信息

下面是id命令的格式和选项：

```css
id [OPTION]... [USERNAME]
```

其中`[USERNAME]`参数是可选的，如果不指定，则默认为当前登录用户。如果指定了用户名，则id命令将显示该用户的身份信息

以下是id命令支持的常用选项：

- `-a`或`--all`：显示所有身份信息，包括用户ID、组ID和所属组等信息。
- `-g`或`--group`：显示用户所属的主组ID。
- `-G`或`--groups`：显示用户所属的附加组ID，如果有多个组，则以逗号分隔。
- `-n`或`--name`：显示用户和组的名称，而不是ID。
- `-r`或`--real`：显示实际ID，而不是有效ID。这对于检查系统调用的权限很有用。
- `-u`或`--user`：显示用户ID。
- `-Z`：显示用户的SELinux上下文。
- `-c`：显示可打印的身份信息（即格式化后的输出）。
- `-s`：显示用户的组ID列表，而不包括主组ID。

## groupadd

在Linux中，groupadd是一个用于创建新用户组的命令。groupadd命令的语法如下：

```css
groupadd [options] group_name
```

其中，group_name表示要创建的新用户组的名称。而options表示可以选择的选项，常用的选项如下：

- -g GID：指定新用户组的组ID（GID），如果不指定则会自动分配。
- -r：创建系统用户组，即GID在100-999范围内。CentOS 6之前: ID<500，CentOS 7以后: ID<1000
- -K key=value：设置组配置项

## groupmod

`groupmod`命令是Linux中一个用于修改用户组的命令，可以用于更改用户组的名称、GID或其他属性。以下是groupmod命令的详细说明：

用法：

```css
groupmod [选项] 组名
```

选项：

- `-g GID`：修改组的GID。
- `-n 新组名`：修改组的名称。
- `-o`：允许使用非唯一的GID。通常GID必须是唯一的，但如果使用此选项，则可以使用重复的GID。
- `-v`：详细输出命令的操作信息。
- `-h`：显示帮助信息。

格式：

```css
groupmod [-g GID|-n 新组名] 组名
```

例如，要将名为“group1”的用户组的名称更改为“group2”，可以使用以下命令：

```css
groupmod -n group2 group1
```

要将名为“group1”的用户组的GID更改为500，可以使用以下命令：

```css
groupmod -g 500 group1
```

## groupdel

在Linux系统中，`groupdel`命令用于删除指定的用户组，其基本用法如下：

```css
groupdel [OPTIONS] GROUP
```

其中，`OPTIONS`为可选的命令选项，`GROUP`为要删除的用户组名称。

下面是`groupdel`命令常用的选项：

- `-f, --force`：强制删除用户组，即使该组还有用户存在。
- `-h, --help`：显示命令帮助信息。
- `-r, --remove`：删除用户组，并删除该组的所有相关文件和目录。该选项只有在用户组已经不存在于系统中时才有效。

需要注意的是，删除用户组时，如果该组还有用户存在，则`groupdel`命令默认会拒绝删除该用户组，并输出错误信息。如果需要强制删除该用户组，可以使用`-f`选项。

例如，要删除名为`testgroup`的用户组，可以执行以下命令：

```css
groupdel testgroup
```

如果该组还有用户存在，将会输出类似以下的错误信息：

```css
groupdel: cannot remove the primary group of user 'testuser'
```

此时可以使用`-f`选项强制删除该组，例如：

```css
groupdel -f testgroup
```

另外，如果需要删除用户组的所有相关文件和目录，可以使用`-r`选项，例如：

```css
groupdel -r testgroup
```

该命令会删除`/etc/group`文件中该组的记录，并删除该组的所有用户的附加组信息。如果该组还有用户目录或文件，也会被删除。

## chown

`chown` 是 Linux 系统中一个用于更改文件或目录的所有者的命令。更改文件或目录所有者通常需要 root 权限。

`chown` 命令的基本格式如下:

```css
chown [选项] [所有者名][:组名] 文件或目录名
```

其中，`[选项]` 为可选的参数，`[所有者名]` 为新的所有者名称，`[:组名]` 为新的组名称（如果不指定，则默认为当前组），`文件或目录名` 为需要更改所有者的文件或目录名称。

下面是一些常用的选项：

- `-R` 或 `--recursive`：递归地更改指定目录下所有子目录和文件的所有者。
- `-c` 或 `--changes`：仅在更改了文件或目录的所有者时才输出提示信息。
- `-f` 或 `--silent` 或 `--quiet`：不输出错误信息。
- `-v` 或 `--verbose`：输出详细信息。

例如，要将 `test.txt` 文件的所有者更改为 `tom`，命令如下：

```css
chown tom test.txt
```

要将 `test` 目录下所有子目录和文件的所有者更改为 `tom`，可以使用 `-R` 参数：

```css
chown -R tom test
```

如果需要同时更改文件的所有者和所属组，可以在 `所有者名` 后面加上 `:` 和 `组名`，例如：

```css
chown tom:users test.txt
```

以上命令将 `test.txt` 文件的所有者更改为 `tom`，所属组更改为 `users`。如果省略 `组名`，则默认为当前用户的主组。

## chgrp

`chgrp`是Linux中的一个命令，用于更改文件或目录的组归属。它可以帮助管理员和用户管理文件和目录的访问权限。下面是该命令的格式，选项和使用方法的详细解释。

格式：

```css
chgrp [OPTIONS] GROUP FILE(s)
```

- `-R`：递归地更改指定目录及其子目录中的文件或目录的组。
- `--reference=RFILE`：使用指定的文件或目录RFILE的组来更改FILE(s)的组，而不是使用新的组。
- `--help`：显示帮助信息并退出。
- `--version`：显示版本信息并退出。

要更改文件或目录的组，请使用以下命令：

```css
chgrp groupname filename
```

这将把文件`filename`的组更改为`groupname`。如果要更改多个文件或目录的组，请在命令中指定所有文件或目录：

```css
chgrp groupname file1 file2 dir1 dir2
```

要递归更改一个目录及其子目录中的所有文件或目录的组，请使用`-R`选项：

```css
chgrp -R groupname dirname
```

在某些情况下，您可能希望将文件或目录的组更改为另一个文件或目录的组。这可以使用`--reference`选项完成。例如，假设您希望将文件`file1`的组更改为与文件`file2`相同的组：

```css
chgrp --reference=file2 file1
```

## chmod

`chmod`是Linux/Unix系统中用于改变文件或目录权限的命令。它的名字来自于"change mode"，表示修改文件的访问模式。在Linux中，每个文件都有9个权限位，用来控制文件所有者、所属组和其他用户的访问权限。这些权限可以是读、写、执行的组合。chmod命令可以通过更改这些权限位来控制访问权限。

chmod的格式为：

```css
chmod [选项] 模式 文件名
```

其中，选项和模式是可选的，文件名是必需的。

选项：

- -c，--changes：只在更改了权限的文件才显示信息。
- -f，--silent，--quiet：不显示错误信息。
- -R，--recursive：递归地更改指定目录及其子目录中的文件权限。
- -v，--verbose：显示每个更改的文件权限。

模式：

模式用来指定需要更改的权限。模式有两种格式：

- 符号模式：使用符号表示需要更改的权限。
- 数字模式：使用数字表示需要更改的权限。

符号模式：

符号模式由以下几个部分组成：

- 操作符：表示需要进行的操作，可以是 +，- 或 =。
- 权限：需要更改的权限，可以是 r，w 或 x。
- 范围：表示需要更改的权限作用的范围，可以是 u，g，o 或 a。

范围表示：

- u：表示文件所有者。
- g：表示文件所属组。
- o：表示其他用户。
- a：表示所有用户，等价于 ugo。

例如，要将文件file.txt的所有者权限设置为可读写，可以使用以下命令：

```css
chmod u+rw file.txt
```

数字模式：

数字模式由三个数字组成，每个数字表示不同的权限位：

- 第一个数字：表示文件所有者的权限。
- 第二个数字：表示文件所属组的权限。
- 第三个数字：表示其他用户的权限。

每个数字可以是以下数值之一：

- 0：没有权限。
- 1：执行权限。
- 2：写权限。
- 3：写和执行权限。
- 4：读权限。
- 5：读和执行权限。
- 6：读和写权限。
- 7：读、写和执行权限。

例如，要将文件file.txt的所有者权限设置为可读写，所属组和其他用户的权限设置为只读，可以使用以下命令：

```css
chmod 644 file.txt
```

注意，符号模式和数字模式都可以混合使用。例如，以下命令将文件file.txt的所有者权限设置为可读写，所属组和其他用户的权限设置为只读：

```css
chmod u+rw,go+r file.txt
```

## setuid

> setuid、setgid和sticky bit是Linux文件系统中的三个特殊权限位，它们分别被称为SUID、SGID和Sticky Bit。

setuid是一种在Linux中赋予二进制文件特权的权限位。当二进制文件拥有setuid权限时，运行该文件的进程将具有该文件所有者的权限，而不是当前用户的权限。这种权限通常用于允许用户执行一些需要特殊权限才能运行的程序，例如执行需要root权限的程序。

用法：

`chmod u+s filename` 或 `chmod 4xxx filename` （其中xxx为权限掩码）

选项：

- `u+s`：设置setuid权限
- `g-s`：取消setuid权限
- `4000`：八进制权限掩码，用于设置setuid权限

示例：

设置`/usr/bin/passwd`的setuid权限，使其允许普通用户修改密码：

```css
sudo chmod u+s /usr/bin/passwd
```

取消`/usr/bin/passwd`的setuid权限：

```css
sudo chmod u-s /usr/bin/passwd
```

## setgid

setgid是一种在Linux中赋予目录或二进制文件特权的权限位。当目录或二进制文件拥有setgid权限时，运行该目录或文件的进程将具有该目录或文件所属组的权限，而不是当前用户的权限。这种权限通常用于在多个用户之间共享文件，以确保共享文件组的成员具有相同的权限。

用法：

`chmod g+s filename` 或 `chmod 2xxx filename` （其中xxx为权限掩码）

选项：

- `g+s`：设置setgid权限
- `g-s`：取消setgid权限
- `2000`：八进制权限掩码，用于设置setgid权限

设置`/home/shared`目录的setgid权限，使所有新创建的文件和目录都与该目录属于同一组：

```css
sudo chmod g+s /home/shared
```

取消`/home/shared`目录的setgid权限：

```css
sudo chmod g-s /home/shared
```

## sticky bit

Sticky bit是一种在Linux中赋予目录特权的权限位。当目录拥有sticky bit权限时，只有目录所有者和文件所有者才能删除该目录中的文件。这种权限通常用于在多个用户之间共享目录，以防止其他用户误删别人的文件。

在文件或目录的权限表示中，sticky bit用一个“t”来表示。对于目录，表示为d+rwxrwt，其中最后一个字母t就是sticky bit；对于文件，表示为-rwxrwxrwt。

用法：

`chmod +t directory` 或 `chmod 1xxx directory` （其中xxx为权限掩码）

1. 目录的权限表示：d+rwxrwxrwt
2. 文件的权限表示：-rwxrwxrwt

选项：

- `+t`：设置Sticky bit权限
- `-t`：取消Sticky bit权限
- `1000`：八进制权限掩码，用于设置Sticky bit权限

示例：

设置`/home/shared`目录的Sticky bit权限，以防止其他用户误删别人的文件：

```css
sudo chmod +t /home/shared
chmod 1755 /home/test
```

其中，1表示sticky bit，7表示用户具有读、写、执行权限，5表示组和其他用户具有读和执行权限。

需要注意的是，sticky bit只对目录有效，对于文件则没有作用。此外，sticky bit与setgid权限位有些类似，但是两者的作用不同，setgid权限位是用来控制文件或目录的用户组，而不是删除权限。

## passwd

在Linux中，`passwd`和`chpasswd`命令都用于更改用户的密码。但是，它们在实现方式和使用方法上略有不同。下面是它们的详细解释：

`passwd`命令是Linux中的标准命令之一，它用于更改用户密码。`passwd`命令的使用非常简单，只需要在终端中输入`passwd`，然后按照提示输入当前用户的密码，然后输入新密码并再次确认即可。例如：

```yaml
$ passwd
Changing password for user1.
(current) UNIX password:
New password:
Retype new password:
passwd: password updated successfully
```

`passwd`命令会将新密码保存在系统的密码文件中。密码文件的位置和格式取决于您的Linux发行版和配置。通常，密码文件位于`/etc/passwd`，而加密的密码则位于`/etc/shadow`。

需要注意的是，`passwd`命令只能用于更改当前用户的密码。如果您想更改其他用户的密码，则需要使用`su`命令切换到目标用户，并在该用户的环境下运行`passwd`命令。

## chpasswd

`chpasswd`命令是另一种更改用户密码的方法，但它的使用方法略有不同。`chpasswd`命令的作用是从标准输入读取用户名和密码，并将它们保存到系统密码文件中。因此，`chpasswd`命令通常用于批量更改用户密码，而不是交互式更改。

`chpasswd`命令的语法如下：

```css
$ chpasswd [OPTIONS]
```

`chpasswd`命令支持以下选项：

- `-e`：指定密码使用的加密算法，默认为DES加密。
- `-c`：指定密码的最大变化次数。
- `-h`：指定密码的最小历史记录数。

`chpasswd`命令的最常见用法是将用户名和密码列表保存在一个文件中，然后使用重定向将其输入到`chpasswd`命令中。例如：

```makefile
$ cat password.txt
user1:password1
user2:password2
user3:password3

$ chpasswd < password.txt
```

以上示例将从`password.txt`文件中读取用户名和密码列表，并将它们保存到系统密码文件中。

```css
echo "123456" | passwd "$username" --stdin

echo "username:123456" | chpasswd
```
    

## sysctl

`sysctl`是一个用于在运行时查询和修改Linux内核参数的命令行工具。这些内核参数可以用于调整和优化系统性能、行为以及内核子系统。`sysctl`允许您在不重新编译内核或重启系统的情况下动态修改这些参数。

`sysctl`命令的基本格式如下：

```css
sysctl [options] [variable[=value]]...
```

其中`variable`表示内核参数名称，`value`表示要设置的新值。`options`可以是以下选项之一：

1. `-n` 或 `--values`：仅显示参数值，不显示参数名称。这在脚本中处理输出时非常有用。
2. `-e` 或 `--ignore`：忽略无法设置的参数错误。默认情况下，如果`sysctl`遇到无法设置的参数，它会返回一个错误。使用此选项可以使`sysctl`在遇到错误时继续执行。
3. `-w` 或 `--write`：将内核参数设置为指定值。请注意，使用此选项修改的参数值仅在当前系统运行期间有效。系统重启后，参数值将恢复为默认值或`/etc/sysctl.conf`中的设置。
4. `-p` 或 `--load`：加载`/etc/sysctl.conf`文件中的设置。您可以指定一个文件作为参数，如`sysctl -p /path/to/custom/sysctl.conf`，以加载自定义的配置文件。如果未指定文件，`sysctl`将使用默认的`/etc/sysctl.conf`文件。
5. `-a` 或 `--all`：显示所有可用内核参数及其当前设置。
6. `-A` 或 `--all-to-readable`：以易于阅读的格式显示所有可用内核参数及其当前设置。
7. `-b` 或 `--binary`：以二进制格式显示参数值。这对于处理非文本值（如控制台键盘模式）非常有用。
8. `-q` 或 `--quiet`：在执行操作时不显示任何输出。
9. `-f` 或 `--file`：指定一个文件来读取参数设置，而不是从`/proc/sys`读取。
10. `-d` 或 `--description`：显示参数的描述，如果可用。

以下是一些使用不同选项的`sysctl`命令示例：

1. 仅显示`net.ipv4.tcp_max_syn_backlog`参数的值：

```css
sysctl -n net.ipv4.tcp_max_syn_backlog
#这个显示完整信息
sysctl net.ipv4.tcp_max_syn_backlo
```

2. 忽略无法设置的参数错误：

```css
sysctl -e -w net.ipv4.tcp_max_syn_backlog=1024
```

3. 加载自定义配置文件：

```css
sysctl -p /path/to/custom/sysctl.conf
```

4. 以易于阅读的格式显示所有参数：

```css
sysctl -A
```

5. 显示`net.ipv4.tcp_max_syn_backlog`参数的描述：

```css
sysctl -d net.ipv4.tcp_max_syn_backlog
```

6. 要将`net.ipv4.tcp_max_syn_backlog`的值设置为1024:

```css
sysctl -w net.ipv4.tcp_max_syn_backlog=1024
```

7. 使`/etc/sysctl.conf`文件中的更改生效：

```css
sysctl -p
```

如果在`/etc/sysctl.conf`文件中进行了更改，可以使用此命令使这些更改立即生效，而无需重启系统。

8. 查询所有可用内核参数：

```css
sysctl -a
```

使用此选项可以显示系统中所有可用的内核参数及其当前设置。

9. 将当前内核参数设置保存到文件：

```css
sysctl -A > /path/to/output_file
```

这将把当前系统中所有可用的内核参数及其设置保存到指定的文件中。
    
## arp

`arp` 是一个用于管理 Linux 系统中的 ARP 缓存表的命令。ARP（Address Resolution Protocol，地址解析协议）是一种网络协议，用于将 IP 地址映射到物理地址（如 MAC 地址）。在较新的 Linux 发行版中，`arp` 命令已被 `ip neigh` 命令取代。但在此，我们将侧重于讲解传统的 `arp` 命令。

1. 查看 ARP 表：

要查看 ARP 缓存表中的所有条目，可以使用 `-a`（`--display`）选项：

```css
arp -a
arp -n
```

2. 添加静态 ARP 条目：

要添加一个静态 ARP 条目，可以使用 `-s`（`--set`）选项。这在某些特殊情况下可能很有用，例如在需要手动映射 IP 地址和 MAC 地址时。

```css
arp -s <IP地址> <MAC地址>
arp -s 192.168.1.2 00:11:22:33:44:55
```

3. 删除 ARP 条目：

要从 ARP 表中删除一个条目，可以使用 `-d`（`--delete`）选项：

```css
arp -d <IP地址>
arp -d 192.168.1.2

#清空arp缓冲
arp -d
```

4. 设置 ARP 条目的超时：

可以使用 `/proc` 文件系统设置 ARP 缓存项的超时值。要设置 ARP 缓存项的生存时间（以秒为单位），可以修改 `/proc/sys/net/ipv4/neigh/default/gc_stale_time` 文件的值。

例如，要将 ARP 缓存项的超时设置为 10 分钟（600 秒），可以执行以下命令：

```css
echo 600 | sudo tee /proc/sys/net/ipv4/neigh/default/gc_stale_time
```

## ip neigh

`ip neigh` 是一个用于管理 Linux 系统中的邻居（ARP 缓存）表的命令。邻居表存储了 IP 地址与 MAC 地址之间的映射关系。`ip neigh` 命令是较新版本 Linux 发行版中取代 `arp` 命令的替代工具，它是 `iproute2` 软件包的一部分。sx

下面是关于如何使用 `ip neigh` 命令的详细讲解：

1. 查看邻居（ARP 缓存）表：

要查看邻居表中的所有条目，可以执行以下命令：

```css
ip neigh
或者
ip neigh show
```

2. 添加静态邻居（ARP）条目：

要添加一个静态邻居条目，可以使用 `add` 子命令。这在某些特殊情况下可能很有用，例如在需要手动映射 IP 地址和 MAC 地址时。

```css
ip neigh add <IP地址> lladdr <MAC地址> dev <网络设备> [nud <状态>]
ip neigh add 192.168.1.2 lladdr 00:11:22:33:44:55 dev eth0 nud permanent
在这个例子中，nud 参数表示邻居表项的状态，permanent 表示这个条目是静态的，不会过期。
```

3. 删除邻居（ARP）条目：

要从邻居表中删除一个条目，可以使用 `del` 子命令：

```css
ip neigh del <IP地址> dev <网络设备>
ip neigh del 192.168.1.2 dev eth0
```

4. 修改邻居（ARP）条目：

要修改现有的邻居条目，可以使用 `replace` 子命令：

```css
ip neigh replace <IP地址> lladdr <MAC地址> dev <网络设备> [nud <状态>]
ip neigh replace 192.168.1.2 lladdr 00:11:22:33:44:66 dev eth0 nud reachable
在这个例子中，nud 参数表示邻居表项的状态，reachable 表示这个条目是动态的，会过期。
```

## traceroute

`traceroute` 是一个用于诊断网络问题的 Linux 命令。该命令的主要目的是显示数据包从源主机（您的计算机）到目标主机（例如，另一台计算机或网站服务器）经过的路由路径。通过这个命令，您可以识别网络连接问题、网络拓扑以及性能问题。

`traceroute` 的工作原理是发送一系列带有递增 TTL（Time-to-Live）值的探测数据包。当这些数据包经过路由器时，路由器会递减 TTL 值。当 TTL 值降至 0 时，路由器将丢弃数据包，并向源主机发送一条 ICMP（Internet Control Message Protocol）消息，告知数据包已被丢弃。通过这种方式，`traceroute` 能够识别数据包经过的每个路由器。

下面是关于如何使用 `traceroute` 命令的详细讲解：

1. 运行 `traceroute`：

要使用 `traceroute` 命令，只需输入 `traceroute`，后跟目标主机的 IP 地址或域名：

```css
traceroute <目标主机>
```

2. 更改探测数据包的类型：

默认情况下，`traceroute` 使用 UDP 数据包进行探测。但是，您可以使用 `-I` 选项将其更改为使用 ICMP Echo 请求数据包，这与 `ping` 命令使用的数据包类型相同：

```css
traceroute -I <目标主机>
```

3. 设置数据包的大小：

您可以使用 `-s` 选项设置发送的探测数据包的大小（以字节为单位）：

```css
traceroute -s <大小> <目标主机>
```

4. 限制跳数：

您可以使用 `-m` 选项设置 `traceroute` 的最大跳数。如果在达到最大跳数之前没有到达目标主机，`traceroute` 将停止：

```css
traceroute -m <最大跳数> <目标主机>
```

5. `-n`：不对 IP 地址执行反向 DNS 解析。这将加快 `traceroute` 的执行速度，因为它不会尝试查找每个 IP 地址对应的主机名。

```css
traceroute -n <目标主机>
```

6. `-q`：设置每个 TTL 值发送的查询数量。默认值是 3。您可以增加或减少此值以调整 `traceroute` 的详细程度。

```css
traceroute -q <查询数量> <目标主机>
```

7. `-w`：设置等待每个响应的最长时间（以秒为单位）。默认值是 5 秒。您可以根据网络状况增加或减少此值。

```css
traceroute -w <超时秒数> <目标主机>
```

8. `-f`：设置初始 TTL 值。默认情况下，`traceroute` 从 TTL 值 1 开始。您可以使用此选项更改初始 TTL 值。

```css
traceroute -f <初始TTL> <目标主机>
```

9. `-i`：指定要使用的网络接口。这在您的计算机具有多个网络接口时可能很有用。

```css
traceroute -i <网络接口> <目标主机>
```

10. `-t`：为发送的数据包设置 IP Type of Service (TOS) 值。TOS 值是一个 8 位字段，用于指定数据包的优先级和 QoS（Quality of Service）选项。

```css
traceroute -t <TOS值> <目标主机>
```

11. `-p`：设置要使用的目标端口。默认情况下，`traceroute` 使用一个不太可能被使用的 UDP 端口。您可以通过此选项更改端口。

```css
traceroute -p <端口号> <目标主机>
```

## tracepath

`tracepath` 是一个用于诊断网络路径和 MTU（Maximum Transmission Unit，最大传输单元）问题的 Linux 命令。与 `traceroute` 命令类似，`tracepath` 的主要目的是显示数据包从源主机（您的计算机）到目标主机（例如，另一台计算机或网站服务器）经过的路由路径。`tracepath` 不需要 root 权限即可运行，这是它与 `traceroute` 的一个主要区别。

以下是关于如何使用 `tracepath` 命令的详细讲解：

1. 运行 `tracepath`：

要使用 `tracepath` 命令，只需输入 `tracepath`，后跟目标主机的 IP 地址或域名：

```css
tracepath <目标主机>
```

`tracepath` 将显示从您的计算机到目标主机的网络路径，并显示每个跳（路由器）的往返时间（RTT）。

2. 指定数据包的大小：

您可以使用 `-s` 选项指定发送的数据包的大小（以字节为单位）。这在诊断 MTU 问题时可能很有用。

```css
tracepath -s <大小> <目标主机>
```

3. 设置最大 TTL 值：

您可以使用 `-m` 选项设置 `tracepath` 的最大 TTL 值。如果在达到最大 TTL 值之前没有到达目标主机，`tracepath` 将停止。

```css
tracepath -m <最大TTL> <目标主机>
```

4. 指定网络接口：

您可以使用 `-b` 选项指定要使用的网络接口。这在您的计算机具有多个网络接口时可能很有用。

```css
tracepath -b <网络接口> <目标主机>
```

## mtr

`mtr`（My Traceroute）是一个网络诊断工具，结合了 `ping` 和 `traceroute` 的功能。它可以实时显示数据包在从源主机到目标主机的路径上的每个跳点的往返时间（RTT）和丢包率。

以下是关于如何使用 `mtr` 命令及其选项的详细讲解：

1. 运行 `mtr`：

要使用 `mtr` 命令，只需输入 `mtr`，后跟目标主机的 IP 地址或域名：

```css
mtr <目标主机>
```

`mtr` 将以实时方式显示从您的计算机到目标主机的网络路径，同时显示每个跳点的 RTT 和丢包率。

2. 使用 ICMP ECHO 请求：

默认情况下，`mtr` 使用 UDP 数据包进行探测。您可以使用 `-I` 或 `--icmp` 选项将其更改为使用 ICMP ECHO 请求数据包，这与 `ping` 命令使用的数据包类型相同：

```css
mtr -I <目标主机>
或者
mtr --icmp <目标主机>
```

3. 设置报告模式：

`mtr` 支持不同的显示模式。使用 `-r` 或 `--report` 选项，您可以生成一个报告，其中包含路径上每个跳点的统计信息。报告将在指定的查询周期数（默认为 10）之后生成。

```css
mtr -r <目标主机>
或者
mtr --report <目标主机>
```

4. 设置查询周期数：

要设置生成报告的查询周期数，可以使用 `-c` 或 `--report-cycles` 选项。例如，要生成包含 20 个查询周期的报告，可以执行以下命令：

```css
mtr -r -c 20 <目标主机>
或者
mtr --report --report-cycles 20 <目标主机>
```

5. 设置其他选项：

`mtr` 命令还有许多其他选项，可以帮助您根据需要进行网络诊断。例如：

- `-n` 或 `--no-dns`：不执行反向 DNS 解析。
- `-s` 或 `--psize`：设置发送的数据包的大小（以字节为单位）。
- `-i` 或 `--interval`：设置发出探测数据包之间的时间间隔（以秒为单位）。
 
## nmcli

`nmcli`（NetworkManager命令行接口）是一个用于管理Linux系统上的网络连接的命令行工具。它允许用户查看、创建、编辑和删除网络连接。`nmcli` 是NetworkManager的一部分，NetworkManager是一个用于管理网络的守护进程。`nmcli` 的主要优势在于其简单的命令行界面，可以方便地用于脚本和自动化任务。

`nmcli`的基本语法是：

```css
nmcli [OPTIONS] OBJECT {command | help}
```

其中，`OPTIONS` 是可选的参数，`OBJECT` 是要操作的对象（如设备、连接等），`command` 是要对对象执行的操作，`help` 是获取帮助信息。

`nmcli`支持以下选项参数：

- `-t` 或 `--terse`：输出简洁的结果，适用于脚本处理。
- `-p` 或 `--pretty`：输出更美观、易读的结果。
- `-m` 或 `--mode`：设置输出模式（例如：tabular, multiline），默认为tabular。
- `-f` 或 `--fields`：指定要显示的字段。
- `-g` 或 `--get-values`：获取指定字段的值。
- `-s` 或 `--show-secrets`：在输出中显示密码和其他敏感信息。
- `-a` 或 `--ask`：在执行命令时提示输入密码或缺失参数。
- `-w` 或 `--wait`：指定等待操作完成的超时时间（单位：秒）。
- `-v` 或 `--version`：显示`nmcli`的版本信息。
- `-h` 或 `--help`：显示帮助信息。

`nmcli`支持以下对象：

- `g` 或 `general`：显示和设置NetworkManager的通用属性和状态。
- `n` 或 `networking`：显示和设置网络使能状态。
- `r` 或 `radio`：显示和设置无线设备的射频使能状态。
- `c` 或 `connection`：显示和操作网络连接配置。
- `d` 或 `device`：显示和操作设备。
- `m` 或 `monitor`：监视NetworkManager的状态变化。

以下是一些常用的`nmcli`命令:

查看NetworkManager的状态：

```css
nmcli general status
```

查看网络使能状态：

```css
nmcli networking
```

启用或禁用网络：

```css
nmcli networking on
nmcli networking off
```

查看无线射频状态：

```css
nmcli radio
```

启用或禁用无线射频：

```css
nmcli radio wifi on
nmcli radio wifi off
```

查看网络连接列表：

```css
nmcli connection show
```

显示特定连接的详细信息：

```css
nmcli connection show "Connection_Name"
```

导出网络连接配置：

```css
nmcli connection export "Connection_Name" > exported_connection.conf
```

导入网络连接配置：

```css
nmcli connection import type "Connection_Type" file exported_connection.conf
```

例如，导入一个以太网连接：

```css
nmcli connection import type ethernet file exported_connection.conf
```

重命名网络连接：

```css
nmcli connection modify "Old_Connection_Name" connection.id "New_Connection_Name"
```

查看系统上所有设备的状态和详细信息：

```css
nmcli device
```

查看特定设备的详细信息：

```css
nmcli device show "Interface_Name"
```

重新加载NetworkManager配置：

```css
nmcli general reload
```

重启NetworkManager：

```css
nmcli general restart
```

启用或禁用IPv6：

```css
nmcli connection modify "Connection_Name" ipv6.method auto
nmcli connection modify "Connection_Name" ipv6.method ignore
```

设置静态IPv6地址：

```css
nmcli connection modify "Connection_Name" ipv6.addresses "2001:db8::2/64" ipv6.gateway "2001:db8::1" ipv6.dns "2001:4860:4860::8888,2001:4860:4860::8844"
```

设置DHCP选项：

```css
nmcli connection modify "Connection_Name" ipv4.dhcp-send-hostname yes
nmcli connection modify "Connection_Name" ipv4.dhcp-hostname "MyHostname"
```

设置自动连接：

```css
nmcli connection modify "Connection_Name" connection.autoconnect yes
nmcli connection modify "Connection_Name" connection.autoconnect no
```

修改DNS服务器：

```css
nmcli connection modify "Connection_Name" ipv4.dns "8.8.8.8,8.8.4.4"
nmcli connection modify "Connection_Name" ipv6.dns "2001:4860:4860::8888,2001:4860:4860::8844"
```

创建一个新的网络连接，并将其配置为绑定（bonding）模式。

```css
nmcli connection add type bond con-name mybond0 ifname bond0 mode active-backup ipv4.method manual ipv4.addresses 10.0.0.100/24

nmcli connection add：此命令用于创建新的网络连接。
type bond：指定新连接的类型为 bond。bond 是一种网络接口，允许将多个物理接口聚合成一个逻辑接口，以实现负载平衡、故障转移等功能。
con-name mybond0：为新创建的 bond 连接指定一个名称，即 mybond0。
ifname bond0：指定 bond 连接的接口名称，即 bond0。
mode active-backup：设置 bond 模式为 active-backup。在 active-backup 模式下，只有一个从接口处于活动状态，其他接口处于备份状态。如果活动接口故障，系统会自动切换到备份接口。这种模式主要用于实现故障转移。
ipv4.method manual：设置 IPv4 配置方法为手动（manual）。这意味着您需要手动指定 IP 地址、子网掩码、网关等参数。
ipv4.addresses 10.0.0.100/24：分配给 bond 接口的 IPv4 地址。在本例中，IP 地址为 10.0.0.100，子网掩码为 /24（即 255.255.255.0）。
执行此命令后，将创建一个名为 mybond0 的新 bond 连接，配置为 active-backup 模式，并具有指定的 IP 地址。接下来，您需要将物理接口（如 eth0、eth1 等）添加到此 bond 连接中，以便它们可以作为 bond 成员正常工作。
```

这个命令用于创建一个新的网络连接，并将其配置为绑定（bonding）模式。在这个例子中，我们创建了一个名为 `mybond0` 的新 bond 连接，使用 `bond0` 作为网络接口名称，并设置 bond 模式为 active-backup。此外，还将 IPv4 配置为手动模式，并分配 IP 地址 `10.0.0.100/24`。
    
## fping

`fping`（Fast Ping）是一个用于快速检测网络主机状态的命令行工具。与标准的 `ping` 命令相比，`fping` 具有一些独特的特性和优势，例如能够同时 ping 多个主机，以及提供更灵活的输出选项。`fping` 可以用于检测网络连接性、监控网络状态、诊断网络问题等场景。

以下是一些常见的 `fping` 用法：

1.检测单个主机的连通性：

```css
fping example.com
```

2.检测多个主机的连通性：

```css
fping example.com example.org example.net
```

3.从文件中读取主机列表并检测它们的连通性：

```css
fping -f hosts.txt
```

其中，`hosts.txt` 文件应包含一个主机名或 IP 地址列表，每行一个。

4.设置 ping 次数和间隔时间：

```css
fping -c 5 -p 500 example.com
```

这将对 `example.com` 发送 5 次 ping 请求，每次请求之间的间隔为 500 毫秒。

5.设置超时时间：

```css
fping -t 1000 example.com
```

这将设置 ping 请求的超时时间为 1000 毫秒。

注意：`fping` 在某些操作系统中可能不是默认安装的。根据您所使用的操作系统和包管理器，您可能需要使用 `apt-get`（Debian/Ubuntu）、`yum`（CentOS/RHEL）或 `brew`（macOS）等工具来安装 `fping`。

## nmap

`nmap`（Network Mapper）是一个功能强大的网络扫描和安全审计工具。它广泛用于网络发现、安全测试、网络管理以及漏洞检测等场景。`nmap` 可以帮助用户发现开放的端口、运行的服务、操作系统信息等，从而评估网络安全风险。

`nmap` 的基本语法格式如下：

```css
nmap [Scan Type] [Options] {targets}
```

- `Scan Type`：可选的扫描类型，如 `-sS`（SYN 扫描）、`-sT`（全连接扫描）等。如果不指定，`nmap` 默认使用 SYN 扫描。
- `Options`：可选的参数和选项，如 `-p`（指定端口）、`-O`（操作系统检测）等。可以根据需求组合使用多个选项。
- `targets`：目标主机，可以是主机名、IP 地址、CIDR 子网或 IP 地址范围。可以同时指定多个目标。

1.**扫描类型：**

- `-sS`：SYN 扫描（默认扫描类型），仅发送 TCP SYN 数据包；
- `-sT`：全连接扫描，发送完整的 TCP 握手数据包；
- `-sU`：UDP 扫描，扫描 UDP 端口；
- `-sN`, `-sF`, `-sX`：TCP NULL、FIN、Xmas 扫描，发送特殊的 TCP 数据包；
- `-sP`：Ping 扫描，只检查主机是否在线，不扫描端口；
- `-sn`：Ping 扫描，禁用端口扫描；
- `-sA`：ACK 扫描，发送 TCP ACK 数据包；
- `-sW`：Window 扫描，发送 TCP ACK 数据包并检查窗口大小；
- `-s0`:   IP协议扫描。

2.**扫描选项：**

- `-p`：指定要扫描的端口，如 `-p80,443` 或 `-p1-1024`；
- `-F`：快速扫描，扫描约 100 个常用端口；
- `-O`：操作系统检测，尝试识别目标主机的操作系统；
- `-sV`：服务版本检测，尝试识别目标主机的服务及其版本；
- `-A`：详细扫描，包括操作系统检测、服务版本检测、脚本扫描和 traceroute；
- `-e`:   使用指定网络接口扫描；
- `-6`：IPv6 扫描，使用 IPv6 地址进行扫描。

3.**发现选项：**

- `-Pn`：跳过主机发现，直接扫描；
- `-PE`, `-PP`, `-PM`：使用 ICMP echo、timestamp 和 netmask 请求进行主机发现；
- `-PS`, `-PA`, `-PU`, `-PY`：使用 TCP SYN/ACK、UDP 或 SCTP 握手进行主机发现。

4.**时间和性能选项**：

- `-T`：设置时间模板，范围为 0（最慢）到 5（最快），如 `-T4`；
- `--min-hostgroup`, `--max-hostgroup`：设置并行扫描的主机组大小；
- `--min-parallelism`, `--max-parallelism`：设置并行扫描的数据包数量；
- `--min-rtt-timeout`, `--max-rtt-timeout`, `--initial-rtt-timeout`：设置 RTT 超时时间。

5.**输出选项**：

- `-oN`：将扫描结果输出到普通文本文件；
- `-oX`：将扫描结果输出到 XML 文件；
- `-oG`：将扫描结果输出到 grepable 文本文件；
- `-oA`：将扫描结果输出到所有格式（普通文本、XML 和 grepable）的文件。

6.**脚本选项**：

- `--script`：使用 Nmap Scripting Engine（NSE）运行指定的脚本，如 `--script=http-title`；
- `--script-args`：为 NSE 脚本提供参数，如 `--script-args=username=admin,password=1234`；
- `--script-updatedb`：更新 NSE 脚本数据库。

7.**其他选项**：

- `-v`：增加详细输出，可以使用多个 `-v` 以提高详细程度；
- `-h` 或 `--help`：显示帮助信息；
- `-iL`：从文件读取目标主机列表，每行一个主机名或 IP 地址；
- `-exclude`：排除特定主机或范围，如 `-exclude 192.168.1.1,192.168.1.10-192.168.1.20`；
- `-exclude-file`：从文件中排除特定主机；
- `--resolve-all`：强制解析所有目标主机的 DNS 名称。

8.**常见的用法：**

端口扫描：

```css
nmap example.com
```

这将扫描 `example.com` 上的默认端口。

扫描指定端口：

```css
nmap -p 80,443,8080 example.com
```

这将扫描 `example.com` 上的指定端口（80、443、8080）。

扫描端口范围：

```css
nmap -p 1-1024 example.com
```

这将扫描 `example.com` 上的端口范围（1 到 1024）。

对 `example.com` 执行操作系统检测和服务版本检测：

```css
nmap -O -sV example.com
```

这将尝试检测 `example.com` 上运行的服务及其版本。

扫描整个子网：

```css
nmap 192.168.1.0/24
```

这将扫描 `192.168.1.0/24` 子网上的所有主机。

对 `192.168.1.1/24` 子网中的所有主机执行快速扫描：

```css
nmap -T4 -F 192.168.1.1/24
```

这将以较高的速度（`-T4`）对 `example.com` 进行快速扫描（`-F`）。

对 `example.com` 执行全连接扫描：

```css
nmap -sT example.com
```

TCP SYN 扫描指定端口：

```css
nmap -sS -p 22,80,443 example.com
```

UDP 扫描指定端口：

```css
nmap -sU -p 53,67,68,123 example.com
```

IP协议扫描：

```css
nmap -sO example.com
```

此命令扫描支持的IP协议。

扫描主机列表文件：

```css
nmap -iL target_list.txt
```

这里 `target_list.txt` 包含了一个主机名或 IP 地址的列表，每行一个。

使用指定网络接口扫描：

```css
nmap -e eth0 example.com
```

这里 `-e` 选项指定了要使用的网络接口，例如 `eth0`。

识别主机支持的 SSL/TLS 协议：

```css
nmap --script ssl-enum-ciphers example.com
```

使用 Nmap Scripting Engine（NSE）执行特定脚本，检查目标主机支持的 SSL/TLS 协议及加密套件。

扫描并显示 traceroute:

```css
nmap --traceroute example.com
```

此选项将在扫描完成后显示到目标主机的路由。

    
